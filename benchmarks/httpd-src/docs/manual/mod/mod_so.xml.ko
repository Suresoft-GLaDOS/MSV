<?xml version="1.0" encoding="EUC-KR" ?>
<!DOCTYPE modulesynopsis SYSTEM "../style/modulesynopsis.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.ko.xsl"?>
<!-- English Revision: 420990:1727637 (outdated) -->

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<modulesynopsis metafile="mod_so.xml.meta">

<name>mod_so</name>
<description>시작할때 혹은 재시작할때 실행가능한 코드와 모듈을
서버로 읽어들인다</description>
<status>Extension</status>
<sourcefile>mod_so.c</sourcefile>
<identifier>so_module</identifier>
<compatibility>윈도우즈에서 (항상 포함하는) Base 모듈이다.</compatibility>

<summary>

    <p>몇몇 운영체제에서 아파치는 <a href="../dso.html">동적공유객체</a>
    (DSO) 기술을 사용하여 서버를 다시 컴파일하지 않고도 실행중에
    모듈을 읽어들일 수 있다.</p>
    
    <p>읽어들일 코드는, 유닉스에서는 (<code>.so</code> 확장자를
    가진) 일반적인 공유객체파일이고, 윈도우즈에서는 <code>.so</code>
    혹은 <code>.dll</code> 확장자를 가진다.</p>

    <note type="warning"><title>경고</title>
    <p>아파치 1.3 모듈을 아파치 2.0에서 사용할 수 없다.
    아파치 2.0이 동적으로 읽어들이거나 아파치와 같이 컴파일하려면
    모듈을 수정해야 한다.</p>
    </note>
</summary>

<section id="windows"><title>윈도우즈에서 읽어들일 모듈 만들기</title>

    <note><title>주의</title>
    <p>윈도우즈의 모듈명 형식은 아파치 1.3.15와 2.0에서 변경되었다.
    모듈명은 이제 mod_foo.so식이다.</p>

    <p>mod_so는 아직도 ApacheModuleFoo.dll 식의 모듈을 읽어들일
    수 있지만, 새로운 이름 규칙을 선호한다. 모듈을 2.0에 맞게
    수정한다면 이름을 2.0 규칙에 알맞게 고치길 바란다.</p></note>

    <p>아파치 모듈 API는 유닉스 버전이거나 윈도우즈 버전이거나
    같다. 몇몇 API는 윈도우즈에 없는 유닉스 구조에 의존하기때문에
    사용할 수 없지만, 유닉스에서 실행되는 많은 모듈을 수정없이
    혹은 조금 수정하여 윈도우즈에서 사용할 수 있다.</p>

    <p>모듈은 두가지 방법으로 서버에 추가할 수 있다. 유닉스에서는
    모듈을 서버와 같이 컴파일할 수 있다. 윈도우즈용 아파치는
    유닉스와 달리 <code>Configure</code> 프로그램이 없기때문에
    모듈의 소스파일을 ApacheCore 프로젝트 파일에 추가하고, 심볼을
    <code>os\win32\modules.c</code> 파일에 추가해야 한다.</p>

    <p>두번째 방법은 모듈을 서버가
    <code><directive>LoadModule</directive></code> 지시어를
    사용하여 시작할때 읽어들일 수 있는 공유라이브러리 DLL로
    만드는 것이다. 이 모듈 DLL을 배포하면 서버를 재컴파일하지
    않고 어떤 윈도우즈용 아파치에서도 모듈을 사용할 수 있다.</p>

    <p>모듈 DLL을 만들기위해서는 모듈의 소스파일을 조금 수정해야
    한다. DLL은 module record를 export해야 한다. (아래 참고)
    이를 위해 모듈의 module record 정의에 (아파치 헤더파일에
    정의된) <code>AP_MODULE_DECLARE_DATA</code>를 추가한다.
    예를 들어, 다음과 같은 모듈이 있다면:</p>

<example>
    module foo_module;
</example>

    <p>다음과 같이 수정한다:</p>
<example>
    module AP_MODULE_DECLARE_DATA foo_module;
</example>

    <p>이 부분은 윈도우즈에서만 사용하기때문에 변경하여도 유닉스에서
    소스를 그대로 사용할 수 있다. 또, <code>.DEF</code> 파일에
    익숙하다면 대신 이 파일을 사용하여 module record를 export할
    수도 있다.</p>

    <p>이제 모듈을 포함한 DLL을 만든다. 이를 공유라이브러리
    libhttpd.dll을 컴파일할때 만든 libhttpd.lib export 라이브러리와
    링크한다. 아파치 헤더파일을 올바로 찾도록 컴파일러 설정을
    수정해야 할지도 모른다. 서버의 modules 디렉토리에서 이
    라이브러리를 찾을 수 있다. 컴파일환경을 올바로 설정하기위해
    기존 모듈의 .dsp 파일을 가져다 쓰거나 직접 만든 .dsp와
    컴파일러/링커 옵션을 비교하는 것이 좋다.</p>

    <p>이제 모듈을 DLL로 만든다. 이것을 서버의
    <code>modules</code> 디렉토리에 두고,
    <directive>LoadModule</directive> 지시어를 사용하여 읽어들인다.</p>

</section>

<directivesynopsis>
<name>LoadFile</name>
<description>지정한 목적파일이나 라이브러리를 읽어들인다</description>
<syntax>LoadFile <em>filename</em> [<em>filename</em>] ...</syntax>
<contextlist>
<context>server config</context>
</contextlist>

<usage>

    <p>LoadFile 지시어는 서버가 시작하거나 재시작할때 지정한
    목적파일이나 라이브러리를 읽어들인다(link in). 이 지시어는
    어떤 모듈이 동작하기위해 필요한 코드를 추가로 읽어들일때
    사용한다. <em>Filename</em>은 절대경로이거나 <a
    href="core.html#serverroot">ServerRoot</a>에 대한 상대경로이다.</p>

    <p>예를 들어:</p>

    <example>LoadFile libexec/libxmlparse.so</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LoadModule</name>
<description>목적파일이나 라이브러리를 읽어들이고, 사용가능한
모듈 목록에 추가한다</description>
<syntax>LoadModule <em>module filename</em></syntax>
<contextlist>
<context>server config</context>
</contextlist>

<usage>
    <p>LoadModule 지시어는 목적파일 혹은 라이브러리 <em>filename</em>을
    읽어들이고, 사용가능한 모듈 목록에 <em>module</em>이라는
    모듈 구조체를 추가한다. <em>Module</em>은 파일의
    <code>module</code> 자료형 외부변수명이며, 모듈 문서의 <a
    href="module-dict.html#ModuleIdentifier">모듈명</a>에
    나온다. 예를 들면:</p>

    <example>
      LoadModule status_module modules/mod_status.so
    </example>

    <p>ServerRoot의 modules 하위디렉토리에서 지정한 모듈을 읽어들인다.</p>
</usage>

</directivesynopsis>
</modulesynopsis>

