#define __COMPILE_2
#define __COMPILE_4
#define __COMPILE_5
#define __COMPILE_7
#define __COMPILE_9
#define __COMPILE_10
#define __COMPILE_11
#define __COMPILE_12
#define __COMPILE_13
#define __COMPILE_14
#define __COMPILE_16
#define __COMPILE_18
#define __COMPILE_19
#define __COMPILE_20
#define __COMPILE_21
#define __COMPILE_22
#define __COMPILE_24
#define __COMPILE_25
#define __COMPILE_26
#define __COMPILE_27
#define __COMPILE_28
#define __COMPILE_29
#define __COMPILE_30
#define __COMPILE_31
#define __COMPILE_33
#define __COMPILE_34
#define __COMPILE_35
#define __COMPILE_36
#define __COMPILE_37
#define __COMPILE_38
#define __COMPILE_39
#define __COMPILE_40
#define __COMPILE_41
#define __COMPILE_42
#define __COMPILE_43
#define __COMPILE_44
#define __COMPILE_45
#define __COMPILE_46
#define __COMPILE_47
#define __COMPILE_48
#define __COMPILE_49
#define __COMPILE_50
#define __COMPILE_51
#define __COMPILE_52
#define __COMPILE_53
#define __COMPILE_54
#define __COMPILE_55
#define __COMPILE_56
#define __COMPILE_57
#define __COMPILE_58
#define __COMPILE_59
#define __COMPILE_60
#define __COMPILE_61
#define __COMPILE_62
#define __COMPILE_63
#define __COMPILE_64
#define __COMPILE_65
#define __COMPILE_66
#define __COMPILE_67
#define __COMPILE_68
#define __COMPILE_69
#define __COMPILE_70
#define __COMPILE_71
#define __COMPILE_72
#define __COMPILE_73
#define __COMPILE_74
#define __COMPILE_75
#define __COMPILE_76
#define __COMPILE_77
#define __COMPILE_78
#define __COMPILE_79
#define __COMPILE_80
#define __COMPILE_81
#define __COMPILE_82
#define __COMPILE_83
#define __COMPILE_84
#define __COMPILE_87
#define __COMPILE_88
#define __COMPILE_89
#define __COMPILE_90
#define __COMPILE_91
#define __COMPILE_92
#define __COMPILE_93
#define __COMPILE_94
#define __COMPILE_95
#define __COMPILE_96
#define __COMPILE_97
#define __COMPILE_98
#define __COMPILE_99
#define __COMPILE_100
#define __COMPILE_101
#define __COMPILE_102
#define __COMPILE_103
#define __COMPILE_104
#define __COMPILE_105
#define __COMPILE_106
#define __COMPILE_107
#define __COMPILE_108
#define __COMPILE_109
#define __COMPILE_110
#define __COMPILE_111
#define __COMPILE_112
#define __COMPILE_113
#define __COMPILE_114
#define __COMPILE_115
#define __COMPILE_116
#define __COMPILE_117
#define __COMPILE_118
#define __COMPILE_119
#define __COMPILE_120
#define __COMPILE_121
#define __COMPILE_122
#define __COMPILE_123
#define __COMPILE_124
#define __COMPILE_125
#define __COMPILE_126
#define __COMPILE_127
#define __COMPILE_129
#define __COMPILE_130
#define __COMPILE_131
#define __COMPILE_132
#define __COMPILE_133
#define __COMPILE_134
#define __COMPILE_135
#define __COMPILE_136
#define __COMPILE_137
#define __COMPILE_138
#define __COMPILE_139
#define __COMPILE_140
#define __COMPILE_141
#define __COMPILE_142
#define __COMPILE_143
#define __COMPILE_144
#define __COMPILE_145
#define __COMPILE_146
#define __COMPILE_147
#define __COMPILE_148
#define __COMPILE_149
#define __COMPILE_150
#define __COMPILE_151
#define __COMPILE_152
#define __COMPILE_153
#define __COMPILE_154
#define __COMPILE_155
#define __COMPILE_156
#define __COMPILE_157
#define __COMPILE_158
#define __COMPILE_159
#define __COMPILE_160
#define __COMPILE_161
#define __COMPILE_162
#define __COMPILE_163
#define __COMPILE_164
#define __COMPILE_165
#define __COMPILE_166
#define __COMPILE_167
#define __COMPILE_168
#define __COMPILE_169
#define __COMPILE_170
#define __COMPILE_171
#define __COMPILE_172
#define __COMPILE_173
#define __COMPILE_174
#define __COMPILE_175
#define __COMPILE_176
#define __COMPILE_177
#define __COMPILE_178
#define __COMPILE_179
#define __COMPILE_180
#define __COMPILE_181
#define __COMPILE_182
#define __COMPILE_183
#define __COMPILE_184
#define __COMPILE_185
#define __COMPILE_186
#define __COMPILE_187
#define __COMPILE_188
#define __COMPILE_189
#define __COMPILE_190
#define __COMPILE_191
#define __COMPILE_192
#define __COMPILE_193
#define __COMPILE_194
#define __COMPILE_195
#define __COMPILE_196
#define __COMPILE_197
#define __COMPILE_198
#define __COMPILE_199
#define __COMPILE_200
#define __COMPILE_201
#define __COMPILE_202
#define __COMPILE_203
#define __COMPILE_204
#define __COMPILE_205
#define __COMPILE_206
#define __COMPILE_207
#define __COMPILE_208
#define __COMPILE_209
#define __COMPILE_210
#define __COMPILE_211
#define __COMPILE_212
#define __COMPILE_213
#define __COMPILE_214
#define __COMPILE_215
#define __COMPILE_216
#define __COMPILE_217
#define __COMPILE_218
#define __COMPILE_219
#define __COMPILE_220
#define __COMPILE_221
#define __COMPILE_222
#define __COMPILE_223
#define __COMPILE_224
#define __COMPILE_225
#define __COMPILE_226
#define __COMPILE_228
#define __COMPILE_229
#define __COMPILE_230
#define __COMPILE_231
#define __COMPILE_232
#define __COMPILE_233
#define __COMPILE_234
#define __COMPILE_235
#define __COMPILE_236
#define __COMPILE_237
#define __COMPILE_238
#define __COMPILE_239
#define __COMPILE_240
#define __COMPILE_241
#define __COMPILE_242
#define __COMPILE_243
#define __COMPILE_244
#define __COMPILE_245
#define __COMPILE_246
#define __COMPILE_247
#define __COMPILE_248
#define __COMPILE_249
#define __COMPILE_250
#define __COMPILE_251
#define __COMPILE_252
#define __COMPILE_253
#define __COMPILE_254
#define __COMPILE_255
#define __COMPILE_256
#define __COMPILE_257
#define __COMPILE_258
#define __COMPILE_259
#define __COMPILE_260
#define __COMPILE_261
#define __COMPILE_262
#define __COMPILE_263
#define __COMPILE_264
#define __COMPILE_265
#define __COMPILE_266
#define __COMPILE_267
#define __COMPILE_268
#define __COMPILE_269
#define __COMPILE_270
#define __COMPILE_271
#define __COMPILE_272
#define __COMPILE_273
#define __COMPILE_274
#define __COMPILE_275
#define __COMPILE_276
#define __COMPILE_277
#define __COMPILE_278
#define __COMPILE_279
#define __COMPILE_280
#define __COMPILE_281
#define __COMPILE_282
#define __COMPILE_283
#define __COMPILE_284
#define __COMPILE_285
#define __COMPILE_286
#define __COMPILE_287
#define __COMPILE_288
#define __COMPILE_289
#define __COMPILE_290
#define __COMPILE_291
#define __COMPILE_292
#define __COMPILE_293
#define __COMPILE_294
#define __COMPILE_295
#define __COMPILE_296
#define __COMPILE_297
#define __COMPILE_298
#define __COMPILE_299
#define __COMPILE_300
#define __COMPILE_332
#define __COMPILE_333
#define __COMPILE_334
#define __COMPILE_335
#define __COMPILE_336
#define __COMPILE_337
#define __COMPILE_338
#define __COMPILE_339
#define __COMPILE_340
#define __COMPILE_341
#define __COMPILE_342
#define __COMPILE_343
#define __COMPILE_344
#define __COMPILE_345
#define __COMPILE_346
#define __COMPILE_347
#define __COMPILE_348
#define __COMPILE_349
#define __COMPILE_350
#define __COMPILE_351
#define __COMPILE_352
#define __COMPILE_353
#define __COMPILE_354
#define __COMPILE_355
#define __COMPILE_356
#define __COMPILE_357
#define __COMPILE_358
#define __COMPILE_359
#define __COMPILE_360
#define __COMPILE_361
#define __COMPILE_362
#define __COMPILE_363
#define __COMPILE_364
#define __COMPILE_365
#define __COMPILE_366
#define __COMPILE_367
#define __COMPILE_368
#define __COMPILE_369
#define __COMPILE_370
#define __COMPILE_371
#define __COMPILE_372
#define __COMPILE_373
#define __COMPILE_374
#define __COMPILE_375
#define __COMPILE_376
#define __COMPILE_377
#define __COMPILE_378
#define __COMPILE_379
#define __COMPILE_380
#define __COMPILE_381
#define __COMPILE_382
#define __COMPILE_383
#define __COMPILE_384
#define __COMPILE_385
#define __COMPILE_386
#define __COMPILE_387
#define __COMPILE_388
#define __COMPILE_389
#define __COMPILE_390
#define __COMPILE_391
#define __COMPILE_392
#define __COMPILE_393
#define __COMPILE_394
#define __COMPILE_395
#define __COMPILE_396
#define __COMPILE_397
#define __COMPILE_398
#define __COMPILE_399
#define __COMPILE_400
#define __COMPILE_401
#define __COMPILE_402
#define __COMPILE_403
#define __COMPILE_404
#define __COMPILE_405
#define __COMPILE_406
#define __COMPILE_407
#define __COMPILE_408
#define __COMPILE_409
#define __COMPILE_410
#define __COMPILE_411
#define __COMPILE_412
#define __COMPILE_413
#define __COMPILE_414
#define __COMPILE_415
#define __COMPILE_416
#define __COMPILE_417
#define __COMPILE_418
#define __COMPILE_419
#define __COMPILE_420
#define __COMPILE_421
#define __COMPILE_422
#define __COMPILE_423
#define __COMPILE_424
#define __COMPILE_425
#define __COMPILE_426
#define __COMPILE_427
#define __COMPILE_428
#define __COMPILE_429
#define __COMPILE_430
#define __COMPILE_431
#define __COMPILE_432
#define __COMPILE_433
#define __COMPILE_434
#define __COMPILE_435
#define __COMPILE_436
#define __COMPILE_437
#define __COMPILE_438
#define __COMPILE_439
#define __COMPILE_440
#define __COMPILE_441
#define __COMPILE_442
#define __COMPILE_443
#define __COMPILE_444
#define __COMPILE_445
#define __COMPILE_446
#define __COMPILE_447
#define __COMPILE_448
#define __COMPILE_449
#define __COMPILE_450
#define __COMPILE_451
#define __COMPILE_452
#define __COMPILE_453
#define __COMPILE_454
#define __COMPILE_455
#define __COMPILE_456
#define __COMPILE_457
#define __COMPILE_458
#define __COMPILE_459
#define __COMPILE_460
#define __COMPILE_461
#define __COMPILE_462
#define __COMPILE_463
#define __COMPILE_464
#define __COMPILE_465
#define __COMPILE_466
#define __COMPILE_467
#define __COMPILE_468
#define __COMPILE_469
#define __COMPILE_470
#define __COMPILE_471
#define __COMPILE_472
#define __COMPILE_473
#define __COMPILE_474
#define __COMPILE_475
#define __COMPILE_476
#define __COMPILE_477
#define __COMPILE_478
#define __COMPILE_479
#define __COMPILE_480
#define __COMPILE_481
#define __COMPILE_482
#define __COMPILE_483
#define __COMPILE_484
#define __COMPILE_485
#define __COMPILE_486
#define __COMPILE_487
#define __COMPILE_488
#define __COMPILE_489
#define __COMPILE_490
#define __COMPILE_491
#define __COMPILE_492
#define __COMPILE_493
#define __COMPILE_494
#define __COMPILE_495
#define __COMPILE_496
#define __COMPILE_497
#define __COMPILE_498
#define __COMPILE_499
#define __COMPILE_500
#define __COMPILE_501
#define __COMPILE_502
#define __COMPILE_503
#define __COMPILE_504
#define __COMPILE_505
#define __COMPILE_506
#define __COMPILE_507
#define __COMPILE_508
#define __COMPILE_509
#define __COMPILE_510
#define __COMPILE_511
#define __COMPILE_512
#define __COMPILE_513
#define __COMPILE_514
#define __COMPILE_515
#define __COMPILE_516
#define __COMPILE_517
#define __COMPILE_518
#define __COMPILE_519
#define __COMPILE_520
#define __COMPILE_521
#define __COMPILE_522
#define __COMPILE_523
#define __COMPILE_524
#define __COMPILE_525
#define __COMPILE_526
#define __COMPILE_527
#define __COMPILE_528
#define __COMPILE_529
#define __COMPILE_530
#define __COMPILE_531
#define __COMPILE_532
#define __COMPILE_533
#define __COMPILE_534
#define __COMPILE_535
#define __COMPILE_536
#define __COMPILE_537
#define __COMPILE_538
#define __COMPILE_539
#define __COMPILE_540
#define __COMPILE_541
#define __COMPILE_542
#define __COMPILE_543
#define __COMPILE_544
// compile_fin
int __get_mutant(); int __is_neg(const char *location,char *lid,int count, ...); int __abst_hole(); char *__stat_write_init(const char *func_name);void __write_stat(char *str,const char *var_name,void *var_addr,int size); void __stat_file_close(const char *func_name,char *str);long long __mutate(const long long,const char *,const char *); int __trident_choice(char* lid, char* typestr,int* rvals, char** rvals_ids, int rvals_size,int** lvals, char** lvals_ids, int lvals_size);int __trident_output(char* id, char* typestr, int value);float fabs_trident(float a);int __choose(const char *);void *__var_select(unsigned int var_count,void *vars[]);void *__var_select_2(unsigned int var_count,void *vars[]);long long __const_select(unsigned int const_count, ...);void* memset(void*, int, unsigned long); 
/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface

   Copyright (C) 1999, 2001-2002, 2006-2007, 2009 Free Software Foundation,
   Inc.
   Copyright (C) 1992-1993 Jean-loup Gailly

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */

/*
 * The unzip code was written and put in the public domain by Mark Adler.
 * Portions of the lzw code are derived from the public domain 'compress'
 * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
 * Ken Turkowski, Dave Mack and Peter Jannesen.
 *
 * See the license_msg below and the file COPYING for the software license.
 * See the file algorithm.doc for the compression algorithms and file formats.
 */

static char  *license_msg[] = {
"Copyright (C) 2007 Free Software Foundation, Inc.",
"Copyright (C) 1993 Jean-loup Gailly.",
"This is free software.  You may redistribute copies of it under the terms of",
"the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.",
"There is NO WARRANTY, to the extent permitted by law.",
0};

/* Compress files with zip algorithm and 'compress' interface.
 * See help() function below for all options.
 * Outputs:
 *        file.gz:   compressed file with same mode, owner, and utimes
 *     or stdout with -c option or if stdin used as input.
 * If the output file name had to be truncated, the original name is kept
 * in the compressed file.
 * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.
 *
 * Using gz on MSDOS would create too many file name conflicts. For
 * example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for
 * tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.
 * I also considered 12345678.txt -> 12345txt.gz but this truncates the name
 * too heavily. There is no ideal solution given the MSDOS 8+3 limitation.
 *
 * For the meaning of all compilation flags, see comments in Makefile.in.
 */

#include <config.h>
#include <ctype.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/stat.h>
#include <errno.h>

#include "closein.h"
#include "tailor.h"
#include "gzip.h"
#include "lzw.h"
#include "revision.h"

#include "fcntl-safer.h"
#include "getopt.h"
#include "stat-time.h"

		/* configuration */

#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#ifdef HAVE_LIMITS_H
#  include <limits.h>
#endif

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#if defined STDC_HEADERS || defined HAVE_STDLIB_H
#  include <stdlib.h>
#else
   extern int errno;
#endif

#ifndef NO_DIR
# define NO_DIR 0
#endif
#if !NO_DIR
# include <dirent.h>
# ifndef _D_EXACT_NAMLEN
#  define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)
# endif
#endif

#ifdef CLOSEDIR_VOID
# define CLOSEDIR(d) (closedir(d), 0)
#else
# define CLOSEDIR(d) closedir(d)
#endif

#ifndef NO_UTIME
#  include <utimens.h>
#endif

#define RW_USER (S_IRUSR | S_IWUSR)  /* creation mode for open() */

#ifndef MAX_PATH_LEN
#  define MAX_PATH_LEN   1024 /* max pathname length */
#endif

#ifndef SEEK_END
#  define SEEK_END 2
#endif

#ifndef CHAR_BIT
#  define CHAR_BIT 8
#endif

#ifdef off_t
  off_t lseek OF((int fd, off_t offset, int whence));
#endif

#ifndef OFF_T_MIN
#define OFF_T_MIN (~ (off_t) 0 << (sizeof (off_t) * CHAR_BIT - 1))
#endif

#ifndef OFF_T_MAX
#define OFF_T_MAX (~ (off_t) 0 - OFF_T_MIN)
#endif

/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
   present.  */
#ifndef SA_NOCLDSTOP
# define SA_NOCLDSTOP 0
# define sigprocmask(how, set, oset) /* empty */
# define sigset_t int
# if ! HAVE_SIGINTERRUPT
#  define siginterrupt(sig, flag) /* empty */
# endif
#endif

#ifndef HAVE_WORKING_O_NOFOLLOW
# define HAVE_WORKING_O_NOFOLLOW 0
#endif

#ifndef ELOOP
# define ELOOP EINVAL
#endif

/* Separator for file name parts (see shorten_name()) */
#ifdef NO_MULTIPLE_DOTS
#  define PART_SEP "-"
#else
#  define PART_SEP "."
#endif

		/* global buffers */

DECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
DECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
DECLARE(ush, d_buf,  DIST_BUFSIZE);
DECLARE(uch, window, 2L*WSIZE);
#ifndef MAXSEG_64K
    DECLARE(ush, tab_prefix, 1L<<BITS);
#else
    DECLARE(ush, tab_prefix0, 1L<<(BITS-1));
    DECLARE(ush, tab_prefix1, 1L<<(BITS-1));
#endif

		/* local variables */

int ascii = 0;        /* convert end-of-lines to local OS conventions */
int to_stdout = 0;    /* output to stdout (-c) */
int decompress = 0;   /* decompress (-d) */
int force = 0;        /* don't ask questions, compress links (-f) */
int no_name = -1;     /* don't save or restore the original file name */
int no_time = -1;     /* don't save or restore the original file time */
int recursive = 0;    /* recurse through directories (-r) */
int list = 0;         /* list the file contents (-l) */
int verbose = 0;      /* be verbose (-v) */
int quiet = 0;        /* be very quiet (-q) */
int do_lzw = 0;       /* generate output compatible with old compress (-Z) */
int test = 0;         /* test .gz file integrity */
int foreground = 0;   /* set if program run in foreground */
char *program_name;   /* program name */
int maxbits = BITS;   /* max bits per code for LZW */
int method = DEFLATED;/* compression method */
int level = 6;        /* compression level */
int exit_code = OK;   /* program exit code */
int save_orig_name;   /* set if original name must be saved */
int last_member;      /* set for .zip and .Z files */
int part_nb;          /* number of parts in .gz file */
struct timespec time_stamp; /* original time stamp (modification time) */
off_t ifile_size;      /* input file size, -1 for devices (debug only) */
char *env;            /* contents of GZIP env variable */
char **args = NULL;   /* argv pointer if GZIP env variable defined */
char *z_suffix;       /* default suffix (can be set with --suffix) */
size_t z_len;         /* strlen(z_suffix) */

/* The set of signals that are caught.  */
static sigset_t caught_signals;

/* If nonzero then exit with status WARNING, rather than with the usual
   signal status, on receipt of a signal with this value.  This
   suppresses a "Broken Pipe" message with some shells.  */
static int volatile exiting_signal;

/* If nonnegative, close this file descriptor and unlink ofname on error.  */
static int volatile remove_ofname_fd = -1;

off_t bytes_in;             /* number of input bytes */
off_t bytes_out;            /* number of output bytes */
off_t total_in;		    /* input bytes for all files */
off_t total_out;	    /* output bytes for all files */
char ifname[MAX_PATH_LEN]; /* input file name */
char ofname[MAX_PATH_LEN]; /* output file name */
struct stat istat;         /* status for input file */
int  ifd;                  /* input file descriptor */
int  ofd;                  /* output file descriptor */
unsigned insize;           /* valid bytes in inbuf */
unsigned inptr;            /* index of next byte to be processed in inbuf */
unsigned outcnt;           /* bytes in output buffer */

static int handled_sig[] =
  {
    /* SIGINT must be first, as 'foreground' depends on it.  */
    SIGINT

#ifdef SIGHUP
    , SIGHUP
#endif
#ifdef SIGPIPE
    , SIGPIPE
#else
# define SIGPIPE 0
#endif
#ifdef SIGTERM
    , SIGTERM
#endif
#ifdef SIGXCPU
    , SIGXCPU
#endif
#ifdef SIGXFSZ
    , SIGXFSZ
#endif
  };

struct option longopts[] =
{
 /* { name  has_arg  *flag  val } */
    {"ascii",      0, 0, 'a'}, /* ascii text mode */
    {"to-stdout",  0, 0, 'c'}, /* write output on standard output */
    {"stdout",     0, 0, 'c'}, /* write output on standard output */
    {"decompress", 0, 0, 'd'}, /* decompress */
    {"uncompress", 0, 0, 'd'}, /* decompress */
 /* {"encrypt",    0, 0, 'e'},    encrypt */
    {"force",      0, 0, 'f'}, /* force overwrite of output file */
    {"help",       0, 0, 'h'}, /* give help */
 /* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
    {"list",       0, 0, 'l'}, /* list .gz file contents */
    {"license",    0, 0, 'L'}, /* display software license */
    {"no-name",    0, 0, 'n'}, /* don't save or restore original name & time */
    {"name",       0, 0, 'N'}, /* save or restore original name & time */
    {"quiet",      0, 0, 'q'}, /* quiet mode */
    {"silent",     0, 0, 'q'}, /* quiet mode */
    {"recursive",  0, 0, 'r'}, /* recurse through directories */
    {"suffix",     1, 0, 'S'}, /* use given suffix instead of .gz */
    {"test",       0, 0, 't'}, /* test compressed file integrity */
    {"no-time",    0, 0, 'T'}, /* don't save or restore the time stamp */
    {"verbose",    0, 0, 'v'}, /* verbose mode */
    {"version",    0, 0, 'V'}, /* display version number */
    {"fast",       0, 0, '1'}, /* compress faster */
    {"best",       0, 0, '9'}, /* compress better */
    {"lzw",        0, 0, 'Z'}, /* make output compatible with old compress */
    {"bits",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */
    { 0, 0, 0, 0 }
};

/* local functions */

local void try_help     OF((void)) ATTRIBUTE_NORETURN;
local void help         OF((void));
local void license      OF((void));
local void version      OF((void));
local int input_eof	OF((void));
local void treat_stdin  OF((void));
local void treat_file   OF((char *iname));
local int create_outfile OF((void));
local char *get_suffix  OF((char *name));
local int  open_input_file OF((char *iname, struct stat *sbuf));
local int  make_ofname  OF((void));
local void shorten_name  OF((char *name));
local int  get_method   OF((int in));
local void do_list      OF((int ifd, int method));
local int  check_ofname OF((void));
local void copy_stat    OF((struct stat *ifstat));
local void install_signal_handlers OF((void));
local void remove_output_file OF((void));
local RETSIGTYPE abort_gzip_signal OF((int));
local void do_exit      OF((int exitcode)) ATTRIBUTE_NORETURN;
      int main          OF((int argc, char **argv));
int (*work) OF((int infile, int outfile)) = zip; /* function to call */

#if ! NO_DIR
local void treat_dir    OF((int fd, char *dir));
#endif

#define strequ(s1, s2) (strcmp((s1),(s2)) == 0)

static void
try_help ()
{
  fprintf (stderr, "Try `%s --help' for more information.\n",
	   program_name);
  do_exit (ERROR);
}

/* ======================================================================== */
local void help()
{
    static char  *help_msg[] = {
 "Compress or uncompress FILEs (by default, compress FILES in-place).",
 "",
 "Mandatory arguments to long options are mandatory for short options too.",
 "",
#if O_BINARY
 "  -a, --ascii       ascii text; convert end-of-line using local conventions",
#endif
 "  -c, --stdout      write on standard output, keep original files unchanged",
 "  -d, --decompress  decompress",
/*  -e, --encrypt     encrypt */
 "  -f, --force       force overwrite of output file and compress links",
 "  -h, --help        give this help",
/*  -k, --pkzip       force output in pkzip format */
 "  -l, --list        list compressed file contents",
 "  -L, --license     display software license",
#ifdef UNDOCUMENTED
 "  -m, --no-time     do not save or restore the original modification time",
 "  -M, --time        save or restore the original modification time",
#endif
 "  -n, --no-name     do not save or restore the original name and time stamp",
 "  -N, --name        save or restore the original name and time stamp",
 "  -q, --quiet       suppress all warnings",
#if ! NO_DIR
 "  -r, --recursive   operate recursively on directories",
#endif
 "  -S, --suffix=SUF  use suffix SUF on compressed files",
 "  -t, --test        test compressed file integrity",
 "  -v, --verbose     verbose mode",
 "  -V, --version     display version number",
 "  -1, --fast        compress faster",
 "  -9, --best        compress better",
#ifdef LZW
 "  -Z, --lzw         produce output compatible with old compress",
 "  -b, --bits=BITS   max number of bits per code (implies -Z)",
#endif
 "",
 "With no FILE, or when FILE is -, read standard input.",
 "",
 "Report bugs to <bug-gzip@gnu.org>.",
  0};
    char **p = help_msg;

    printf ("Usage: %s [OPTION]... [FILE]...\n", program_name);
    while (*p) printf ("%s\n", *p++);
}

/* ======================================================================== */
local void license()
{
    char **p = license_msg;

    printf ("%s %s\n", program_name, VERSION);
    while (*p) printf ("%s\n", *p++);
}

/* ======================================================================== */
local void version()
{
    license ();
    printf ("\n");
    printf ("Written by Jean-loup Gailly.\n");
}

local void progerror (string)
    char *string;
{
    int e = errno;
    fprintf (stderr, "%s: ", program_name);
    errno = e;
    perror(string);
    exit_code = ERROR;
}

/* ======================================================================== */
int main (argc, argv)
    int argc;
    char **argv;
{
    int file_count;     /* number of files to process */
    size_t proglen;     /* length of program_name */
    int optc;           /* current option */

    EXPAND(argc, argv); /* wild card expansion if necessary */

    program_name = gzip_base_name (argv[0]);
    proglen = strlen (program_name);

    atexit (close_stdin);

    /* Suppress .exe for MSDOS, OS/2 and VMS: */
    if (4 < proglen && strequ (program_name + proglen - 4, ".exe"))
      program_name[proglen - 4] = '\0';

    /* Add options in GZIP environment variable if there is one */
    env = add_envopt(&argc, &argv, OPTIONS_VAR);
    if (env != NULL) args = argv;

#ifndef GNU_STANDARD
# define GNU_STANDARD 1
#endif
#if !GNU_STANDARD
    /* For compatibility with old compress, use program name as an option.
     * Unless you compile with -DGNU_STANDARD=0, this program will behave as
     * gzip even if it is invoked under the name gunzip or zcat.
     *
     * Systems which do not support links can still use -d or -dc.
     * Ignore an .exe extension for MSDOS, OS/2 and VMS.
     */
    if (strncmp (program_name, "un",  2) == 0     /* ungzip, uncompress */
	|| strncmp (program_name, "gun", 3) == 0) /* gunzip */
	decompress = 1;
    else if (strequ (program_name + 1, "cat")     /* zcat, pcat, gcat */
	     || strequ (program_name, "gzcat"))   /* gzcat */
	decompress = to_stdout = 1;
#endif

    z_suffix = Z_SUFFIX;
    z_len = strlen(z_suffix);

    while ((optc = getopt_long (argc, argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
				longopts, (int *)0)) != -1) {
	switch (optc) {
        case 'a':
            ascii = 1; break;
	case 'b':
	    maxbits = atoi(optarg);
	    for (; *optarg; optarg++)
	      if (! ('0' <= *optarg && *optarg <= '9'))
		{
		  fprintf (stderr, "%s: -b operand is not an integer\n",
			   program_name);
		  try_help ();
		}
	    break;
	case 'c':
	    to_stdout = 1; break;
	case 'd':
	    decompress = 1; break;
	case 'f':
	    force++; break;
	case 'h': case 'H':
	    help(); do_exit(OK); break;
	case 'l':
	    list = decompress = to_stdout = 1; break;
	case 'L':
	    license(); do_exit(OK); break;
	case 'm': /* undocumented, may change later */
	    no_time = 1; break;
	case 'M': /* undocumented, may change later */
	    no_time = 0; break;
	case 'n':
	    no_name = no_time = 1; break;
	case 'N':
	    no_name = no_time = 0; break;
	case 'q':
	    quiet = 1; verbose = 0; break;
	case 'r':
#if NO_DIR
	    fprintf (stderr, "%s: -r not supported on this system\n",
		     program_name);
	    try_help ();
#else
	    recursive = 1;
#endif
	    break;
	case 'S':
#ifdef NO_MULTIPLE_DOTS
            if (*optarg == '.') optarg++;
#endif
            z_len = strlen(optarg);
	    z_suffix = optarg;
            break;
	case 't':
	    test = decompress = to_stdout = 1;
	    break;
	case 'v':
	    verbose++; quiet = 0; break;
	case 'V':
	    version(); do_exit(OK); break;
	case 'Z':
#ifdef LZW
	    do_lzw = 1; break;
#else
	    fprintf(stderr, "%s: -Z not supported in this version\n",
		    program_name);
	    try_help ();
	    break;
#endif
	case '1':  case '2':  case '3':  case '4':
	case '5':  case '6':  case '7':  case '8':  case '9':
	    level = optc - '0';
	    break;
	default:
	    /* Error message already emitted by getopt_long. */
	    try_help ();
	}
    } /* loop on all arguments */

    /* By default, save name and timestamp on compression but do not
     * restore them on decompression.
     */
    if (no_time < 0) no_time = decompress;
    if (no_name < 0) no_name = decompress;

    file_count = argc - optind;

#if O_BINARY
#else
    if (ascii && !quiet) {
	fprintf(stderr, "%s: option --ascii ignored on this system\n",
		program_name);
    }
#endif
    if ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) {
        fprintf(stderr, "%s: incorrect suffix '%s'\n",
                program_name, z_suffix);
        do_exit(ERROR);
    }
    if (do_lzw && !decompress) work = lzw;

    /* Allocate all global buffers (for DYN_ALLOC option) */
    ALLOC(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
    ALLOC(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
    ALLOC(ush, d_buf,  DIST_BUFSIZE);
    ALLOC(uch, window, 2L*WSIZE);
#ifndef MAXSEG_64K
    ALLOC(ush, tab_prefix, 1L<<BITS);
#else
    ALLOC(ush, tab_prefix0, 1L<<(BITS-1));
    ALLOC(ush, tab_prefix1, 1L<<(BITS-1));
#endif

    exiting_signal = quiet ? SIGPIPE : 0;
    install_signal_handlers ();

    /* And get to work */
    if (file_count != 0) {
	if (to_stdout && !test && !list && (!decompress || !ascii)) {
	    SET_BINARY_MODE(fileno(stdout));
	}
        while (optind < argc) {
	    treat_file(argv[optind++]);
	}
    } else {  /* Standard input */
	treat_stdin();
    }
    if (list && !quiet && file_count > 1) {
	do_list(-1, -1); /* print totals */
    }
    do_exit(exit_code);
    return exit_code; /* just to avoid lint warning */
}

/* Return nonzero when at end of file on input.  */
local int
input_eof ()
{
  if (!decompress || last_member)
    return 1;

  if (inptr == insize)
    {
      if (insize != INBUFSIZ || fill_inbuf (1) == EOF)
	return 1;

      /* Unget the char that fill_inbuf got.  */
      inptr = 0;
    }

  return 0;
}

/* ========================================================================
 * Compress or decompress stdin
 */
local void treat_stdin()
{
    if (!force && !list &&
	isatty(fileno((FILE *)(decompress ? stdin : stdout)))) {
	/* Do not send compressed data to the terminal or read it from
	 * the terminal. We get here when user invoked the program
	 * without parameters, so be helpful. According to the GNU standards:
	 *
	 *   If there is one behavior you think is most useful when the output
	 *   is to a terminal, and another that you think is most useful when
	 *   the output is a file or a pipe, then it is usually best to make
	 *   the default behavior the one that is useful with output to a
	 *   terminal, and have an option for the other behavior.
	 *
	 * Here we use the --force option to get the other behavior.
	 */
	fprintf(stderr,
    "%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
		program_name, decompress ? "read from" : "written to",
		decompress ? "de" : "");
	fprintf (stderr, "For help, type: %s -h\n", program_name);
	do_exit(ERROR);
    }

    if (decompress || !ascii) {
	SET_BINARY_MODE(fileno(stdin));
    }
    if (!test && !list && (!decompress || !ascii)) {
	SET_BINARY_MODE(fileno(stdout));
    }
    strcpy(ifname, "stdin");
    strcpy(ofname, "stdout");

    /* Get the file's time stamp and size.  */
    if (fstat (fileno (stdin), &istat) != 0)
      {
	progerror ("standard input");
	do_exit (ERROR);
      }
    ifile_size = S_ISREG (istat.st_mode) ? istat.st_size : -1;
    time_stamp.tv_nsec = -1;
    if (!no_time || list)
      time_stamp = get_stat_mtime (&istat);

    clear_bufs(); /* clear input and output buffers */
    to_stdout = 1;
    part_nb = 0;
    ifd = fileno(stdin);

    if (decompress) {
	method = get_method(ifd);
	if (method < 0) {
	    do_exit(exit_code); /* error message already emitted */
	}
    }
    if (list) {
        do_list(ifd, method);
        return;
    }

    /* Actually do the compression/decompression. Loop over zipped members.
     */
    for (;;) {
	if ((*work)(fileno(stdin), fileno(stdout)) != OK) return;

	if (input_eof ())
	  break;

	method = get_method(ifd);
	if (method < 0) return; /* error message already emitted */
	bytes_out = 0;            /* required for length check */
    }

    if (verbose) {
	if (test) {
	    fprintf(stderr, " OK\n");

	} else if (!decompress) {
	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
	    fprintf(stderr, "\n");
#ifdef DISPLAY_STDIN_RATIO
	} else {
	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
	    fprintf(stderr, "\n");
#endif
	}
    }
}

/* ========================================================================
 * Compress or decompress the given file
 */
local void treat_file(iname)
    char *iname;
{
    /* Accept "-" as synonym for stdin */
    if (strequ(iname, "-")) {
	int cflag = to_stdout;
	treat_stdin();
	to_stdout = cflag;
	return;
    }

    /* Check if the input file is present, set ifname and istat: */
    ifd = open_input_file (iname, &istat);
    if (ifd < 0)
      return;

    /* If the input name is that of a directory, recurse or ignore: */
    if (S_ISDIR(istat.st_mode)) {
#if ! NO_DIR
	if (recursive) {
	    treat_dir (ifd, iname);
	    /* Warning: ifname is now garbage */
	    return;
	}
#endif
	close (ifd);
	WARN ((stderr, "%s: %s is a directory -- ignored\n",
	       program_name, ifname));
	return;
    }

    if (! to_stdout)
      {
	if (! S_ISREG (istat.st_mode))
	  {
	    WARN ((stderr,
		   "%s: %s is not a directory or a regular file - ignored\n",
		   program_name, ifname));
	    close (ifd);
	    return;
	  }
	if (istat.st_mode & S_ISUID)
	  {
	    WARN ((stderr, "%s: %s is set-user-ID on execution - ignored\n",
		   program_name, ifname));
	    close (ifd);
	    return;
	  }
	if (istat.st_mode & S_ISGID)
	  {
	    WARN ((stderr, "%s: %s is set-group-ID on execution - ignored\n",
		   program_name, ifname));
	    close (ifd);
	    return;
	  }

	if (! force)
	  {
	    if (istat.st_mode & S_ISVTX)
	      {
		WARN ((stderr,
		       "%s: %s has the sticky bit set - file ignored\n",
		       program_name, ifname));
		close (ifd);
		return;
	      }
	    if (2 <= istat.st_nlink)
	      {
		WARN ((stderr, "%s: %s has %lu other link%c -- unchanged\n",
		       program_name, ifname,
		       (unsigned long int) istat.st_nlink - 1,
		       istat.st_nlink == 2 ? ' ' : 's'));
		close (ifd);
		return;
	      }
	  }
      }

    ifile_size = S_ISREG (istat.st_mode) ? istat.st_size : -1;
    time_stamp.tv_nsec = -1;
    if (!no_time || list)
      time_stamp = get_stat_mtime (&istat);

    /* Generate output file name. For -r and (-t or -l), skip files
     * without a valid gzip suffix (check done in make_ofname).
     */
    if (to_stdout && !list && !test) {
	strcpy(ofname, "stdout");

    } else if (make_ofname() != OK) {
	close (ifd);
	return;
    }

    clear_bufs(); /* clear input and output buffers */
    part_nb = 0;

    if (decompress) {
	method = get_method(ifd); /* updates ofname if original given */
	if (method < 0) {
	    close(ifd);
	    return;               /* error message already emitted */
	}
    }
    if (list) {
        do_list(ifd, method);
        if (close (ifd) != 0)
	  read_error ();
        return;
    }

    /* If compressing to a file, check if ofname is not ambiguous
     * because the operating system truncates names. Otherwise, generate
     * a new ofname and save the original name in the compressed file.
     */
    if (to_stdout) {
	ofd = fileno(stdout);
	/* Keep remove_ofname_fd negative.  */
    } else {
	if (create_outfile() != OK) return;

	if (!decompress && save_orig_name && !verbose && !quiet) {
	    fprintf(stderr, "%s: %s compressed to %s\n",
		    program_name, ifname, ofname);
	}
    }
    /* Keep the name even if not truncated except with --no-name: */
    if (!save_orig_name) save_orig_name = !no_name;

    if (verbose) {
	fprintf(stderr, "%s:\t", ifname);
    }

    /* Actually do the compression/decompression. Loop over zipped members.
     */
    for (;;) {
	if ((*work)(ifd, ofd) != OK) {
	    method = -1; /* force cleanup */
	    break;
	}

	if (input_eof ())
	  break;

	method = get_method(ifd);
	if (method < 0) break;    /* error message already emitted */
	bytes_out = 0;            /* required for length check */
    }

    if (close (ifd) != 0)
      read_error ();

    if (!to_stdout)
      {
	sigset_t oldset;
	int unlink_errno;

	copy_stat (&istat);
	if (close (ofd) != 0)
	  write_error ();

	sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
	remove_ofname_fd = -1;
	unlink_errno = xunlink (ifname) == 0 ? 0 : errno;
	sigprocmask (SIG_SETMASK, &oldset, NULL);

	if (unlink_errno)
	  {
	    WARN ((stderr, "%s: ", program_name));
	    if (!quiet)
	      {
		errno = unlink_errno;
		perror (ifname);
	      }
	  }
      }

    if (method == -1) {
	if (!to_stdout)
	  remove_output_file ();
	return;
    }

    /* Display statistics */
    if(verbose) {
	if (test) {
	    fprintf(stderr, " OK");
	} else if (decompress) {
	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
	} else {
	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
	}
	if (!test && !to_stdout) {
	    fprintf(stderr, " -- replaced with %s", ofname);
	}
	fprintf(stderr, "\n");
    }
}

/* ========================================================================
 * Create the output file. Return OK or ERROR.
 * Try several times if necessary to avoid truncating the z_suffix. For
 * example, do not create a compressed file of name "1234567890123."
 * Sets save_orig_name to true if the file name has been truncated.
 * IN assertions: the input file has already been open (ifd is set) and
 *   ofname has already been updated if there was an original name.
 * OUT assertions: ifd and ofd are closed in case of error.
 */
local int create_outfile()
{
  int name_shortened = 0;
  int flags = (O_WRONLY | O_CREAT | O_EXCL
	       | (ascii && decompress ? 0 : O_BINARY));

  for (;;)
    {
      int open_errno;
      sigset_t oldset;

      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
      remove_ofname_fd = ofd = OPEN (ofname, flags, RW_USER);
      open_errno = errno;
      sigprocmask (SIG_SETMASK, &oldset, NULL);

      if (0 <= ofd)
	break;

      switch (open_errno)
	{
#ifdef ENAMETOOLONG
	case ENAMETOOLONG:
	  shorten_name (ofname);
	  name_shortened = 1;
	  break;
#endif

	case EEXIST:
	  if (check_ofname () != OK)
	    {
	      close (ifd);
	      return ERROR;
	    }
	  break;

	default:
	  progerror (ofname);
	  close (ifd);
	  return ERROR;
	}
    }

  if (name_shortened && decompress)
    {
      /* name might be too long if an original name was saved */
      WARN ((stderr, "%s: %s: warning, name truncated\n",
	     program_name, ofname));
    }

  return OK;
}

/* ========================================================================
 * Return a pointer to the 'z' suffix of a file name, or NULL. For all
 * systems, ".gz", ".z", ".Z", ".taz", ".tgz", "-gz", "-z" and "_z" are
 * accepted suffixes, in addition to the value of the --suffix option.
 * ".tgz" is a useful convention for tar.z files on systems limited
 * to 3 characters extensions. On such systems, ".?z" and ".??z" are
 * also accepted suffixes. For Unix, we do not want to accept any
 * .??z suffix as indicating a compressed file; some people use .xyz
 * to denote volume data.
 *   On systems allowing multiple versions of the same file (such as VMS),
 * this function removes any version suffix in the given name.
 */
local char *get_suffix(name)
    char *name;
{
    int nlen, slen;
    char suffix[MAX_SUFFIX+3]; /* last chars of name, forced to lower case */
    static char *known_suffixes[] =
       {NULL, ".gz", ".z", ".taz", ".tgz", "-gz", "-z", "_z",
#ifdef MAX_EXT_CHARS
          "z",
#endif
          NULL};
    char **suf = known_suffixes;

    *suf = z_suffix;
    if (strequ(z_suffix, "z")) suf++; /* check long suffixes first */

#ifdef SUFFIX_SEP
    /* strip a version number from the file name */
    {
	char *v = strrchr(name, SUFFIX_SEP);
 	if (v != NULL) *v = '\0';
    }
#endif
    nlen = strlen(name);
    if (nlen <= MAX_SUFFIX+2) {
        strcpy(suffix, name);
    } else {
        strcpy(suffix, name+nlen-MAX_SUFFIX-2);
    }
    strlwr(suffix);
    slen = strlen(suffix);
    do {
       int s = strlen(*suf);
       if (slen > s && suffix[slen-s-1] != PATH_SEP
           && strequ(suffix + slen - s, *suf)) {
           return name+nlen-s;
       }
    } while (*++suf != NULL);

    return NULL;
}


/* Open file NAME with the given flags and mode and store its status
   into *ST.  Return a file descriptor to the newly opened file, or -1
   (setting errno) on failure.  */
static int
open_and_stat (char *name, int flags, mode_t mode, struct stat *st)
{
  int fd;

  /* Refuse to follow symbolic links unless -c or -f.  */
  if (!to_stdout && !force)
    {
      if (HAVE_WORKING_O_NOFOLLOW)
	flags |= O_NOFOLLOW;
      else
	{
#if HAVE_LSTAT || defined lstat
	  if (lstat (name, st) != 0)
	    return -1;
	  else if (S_ISLNK (st->st_mode))
	    {
	      errno = ELOOP;
	      return -1;
	    }
#endif
	}
    }

  fd = OPEN (name, flags, mode);
  if (0 <= fd && fstat (fd, st) != 0)
    {
      int e = errno;
      close (fd);
      errno = e;
      return -1;
    }
  return fd;
}


/* ========================================================================
 * Set ifname to the input file name (with a suffix appended if necessary)
 * and istat to its stats. For decompression, if no file exists with the
 * original name, try adding successively z_suffix, .gz, .z, -z and .Z.
 * For MSDOS, we try only z_suffix and z.
 * Return an open file descriptor or -1.
 */
static int
open_input_file (iname, sbuf)
    char *iname;
    struct stat *sbuf;
{
    int ilen;  /* strlen(ifname) */
    int z_suffix_errno = 0;
    static char *suffixes[] = {NULL, ".gz", ".z", "-z", ".Z", NULL};
    char **suf = suffixes;
    char *s;
#ifdef NO_MULTIPLE_DOTS
    char *dot; /* pointer to ifname extension, or NULL */
#endif
    int fd;
    int open_flags = (O_RDONLY | O_NONBLOCK | O_NOCTTY
		      | (ascii && !decompress ? 0 : O_BINARY));

    *suf = z_suffix;

    if (sizeof ifname - 1 <= strlen (iname))
	goto name_too_long;

    strcpy(ifname, iname);

    /* If input file exists, return OK. */
    fd = open_and_stat (ifname, open_flags, RW_USER, sbuf);
    if (0 <= fd)
      return fd;

    if (!decompress || errno != ENOENT) {
	progerror(ifname);
	return -1;
    }
    /* file.ext doesn't exist, try adding a suffix (after removing any
     * version number for VMS).
     */
    s = get_suffix(ifname);
    if (s != NULL) {
	progerror(ifname); /* ifname already has z suffix and does not exist */
	return -1;
    }
#ifdef NO_MULTIPLE_DOTS
    dot = strrchr(ifname, '.');
    if (dot == NULL) {
        strcat(ifname, ".");
        dot = strrchr(ifname, '.');
    }
#endif
    ilen = strlen(ifname);
    if (strequ(z_suffix, ".gz")) suf++;

    /* Search for all suffixes */
    do {
        char *s0 = s = *suf;
        strcpy (ifname, iname);
#ifdef NO_MULTIPLE_DOTS
        if (*s == '.') s++;
        if (*dot == '\0') strcpy (dot, ".");
#endif
#ifdef MAX_EXT_CHARS
	if (MAX_EXT_CHARS < strlen (s) + strlen (dot + 1))
	  dot[MAX_EXT_CHARS + 1 - strlen (s)] = '\0';
#endif
	if (sizeof ifname <= ilen + strlen (s))
	  goto name_too_long;
        strcat(ifname, s);
	fd = open_and_stat (ifname, open_flags, RW_USER, sbuf);
	if (0 <= fd)
	  return fd;
	if (errno != ENOENT)
	  {
	    progerror (ifname);
	    return -1;
	  }
	if (strequ (s0, z_suffix))
	  z_suffix_errno = errno;
    } while (*++suf != NULL);

    /* No suffix found, complain using z_suffix: */
    strcpy(ifname, iname);
#ifdef NO_MULTIPLE_DOTS
    if (*dot == '\0') strcpy(dot, ".");
#endif
#ifdef MAX_EXT_CHARS
    if (MAX_EXT_CHARS < z_len + strlen (dot + 1))
      dot[MAX_EXT_CHARS + 1 - z_len] = '\0';
#endif
    strcat(ifname, z_suffix);
    errno = z_suffix_errno;
    progerror(ifname);
    return -1;

 name_too_long:
    fprintf (stderr, "%s: %s: file name too long\n", program_name, iname);
    exit_code = ERROR;
    return -1;
}

/* ========================================================================
 * Generate ofname given ifname. Return OK, or WARNING if file must be skipped.
 * Sets save_orig_name to true if the file name has been truncated.
 */
local int make_ofname()
{
    char *suff;            /* ofname z suffix */

    strcpy(ofname, ifname);
    /* strip a version number if any and get the gzip suffix if present: */
    suff = get_suffix(ofname);

    if (decompress) {
	if (suff == NULL) {
	    /* With -t or -l, try all files (even without .gz suffix)
	     * except with -r (behave as with just -dr).
             */
            if (!recursive && (list || test)) return OK;

	    /* Avoid annoying messages with -r */
	    if (verbose || (!recursive && !quiet)) {
		WARN((stderr,"%s: %s: unknown suffix -- ignored\n",
		      program_name, ifname));
	    }
	    return WARNING;
	}
	/* Make a special case for .tgz and .taz: */
	strlwr(suff);
	if (strequ(suff, ".tgz") || strequ(suff, ".taz")) {
	    strcpy(suff, ".tar");
	} else {
	    *suff = '\0'; /* strip the z suffix */
	}
        /* ofname might be changed later if infile contains an original name */

    } else if (suff && ! force) {
	/* Avoid annoying messages with -r (see treat_dir()) */
	if (verbose || (!recursive && !quiet)) {
	    /* Don't use WARN, as it affects exit status.  */
	    fprintf (stderr, "%s: %s already has %s suffix -- unchanged\n",
		     program_name, ifname, suff);
	}
	return WARNING;
    } else {
        save_orig_name = 0;

#ifdef NO_MULTIPLE_DOTS
	suff = strrchr(ofname, '.');
	if (suff == NULL) {
	    if (sizeof ofname <= strlen (ofname) + 1)
		goto name_too_long;
            strcat(ofname, ".");
#  ifdef MAX_EXT_CHARS
	    if (strequ(z_suffix, "z")) {
		if (sizeof ofname <= strlen (ofname) + 2)
		    goto name_too_long;
		strcat(ofname, "gz"); /* enough room */
		return OK;
	    }
        /* On the Atari and some versions of MSDOS,
         * ENAMETOOLONG does not work correctly.  So we
         * must truncate here.
         */
        } else if (strlen(suff)-1 + z_len > MAX_SUFFIX) {
            suff[MAX_SUFFIX+1-z_len] = '\0';
            save_orig_name = 1;
#  endif
        }
#endif /* NO_MULTIPLE_DOTS */
	if (sizeof ofname <= strlen (ofname) + z_len)
	    goto name_too_long;
	strcat(ofname, z_suffix);

    } /* decompress ? */
    return OK;

 name_too_long:
    WARN ((stderr, "%s: %s: file name too long\n", program_name, ifname));
    return WARNING;
}


/* ========================================================================
 * Check the magic number of the input file and update ofname if an
 * original name was given and to_stdout is not set.
 * Return the compression method, -1 for error, -2 for warning.
 * Set inptr to the offset of the next byte to be processed.
 * Updates time_stamp if there is one and --no-time is not used.
 * This function may be called repeatedly for an input file consisting
 * of several contiguous gzip'ed members.
 * IN assertions: there is at least one remaining compressed member.
 *   If the member is a zip file, it must be the only one.
 */
local int get_method(in)
    int in;        /* input file descriptor */
{
    uch flags;     /* compression flags */
    char magic[2]; /* magic header */
    int imagic1;   /* like magic[1], but can represent EOF */
    ulg stamp;     /* time stamp */

    /* If --force and --stdout, zcat == cat, so do not complain about
     * premature end of file: use try_byte instead of get_byte.
     */
    if (force && to_stdout) {
	magic[0] = (char)try_byte();
	imagic1 = try_byte ();
	magic[1] = (char) imagic1;
	/* If try_byte returned EOF, magic[1] == (char) EOF.  */
    } else {
	magic[0] = (char)get_byte();
	magic[1] = (char)get_byte();
	imagic1 = 0; /* avoid lint warning */
    }
    method = -1;                 /* unknown yet */
    part_nb++;                   /* number of parts in gzip file */
    header_bytes = 0;
    last_member = RECORD_IO;
    /* assume multiple members in gzip file except for record oriented I/O */

    if (memcmp(magic, GZIP_MAGIC, 2) == 0
        || memcmp(magic, OLD_GZIP_MAGIC, 2) == 0) {

	method = (int)get_byte();
	if (method != DEFLATED) {
	    fprintf(stderr,
		    "%s: %s: unknown method %d -- not supported\n",
		    program_name, ifname, method);
	    exit_code = ERROR;
	    return -1;
	}
	work = unzip;
	flags  = (uch)get_byte();

	if ((flags & ENCRYPTED) != 0) {
	    fprintf(stderr,
		    "%s: %s is encrypted -- not supported\n",
		    program_name, ifname);
	    exit_code = ERROR;
	    return -1;
	}
	if ((flags & CONTINUATION) != 0) {
	    fprintf(stderr,
		    "%s: %s is a multi-part gzip file -- not supported\n",
		    program_name, ifname);
	    exit_code = ERROR;
	    if (force <= 1) return -1;
	}
	if ((flags & RESERVED) != 0) {
	    fprintf(stderr,
		    "%s: %s has flags 0x%x -- not supported\n",
		    program_name, ifname, flags);
	    exit_code = ERROR;
	    if (force <= 1) return -1;
	}
	stamp  = (ulg)get_byte();
	stamp |= ((ulg)get_byte()) << 8;
	stamp |= ((ulg)get_byte()) << 16;
	stamp |= ((ulg)get_byte()) << 24;
	if (stamp != 0 && !no_time)
	  {
	    time_stamp.tv_sec = stamp;
	    time_stamp.tv_nsec = 0;
	  }

	(void)get_byte();  /* Ignore extra flags for the moment */
	(void)get_byte();  /* Ignore OS type for the moment */

	if ((flags & CONTINUATION) != 0) {
	    unsigned part = (unsigned)get_byte();
	    part |= ((unsigned)get_byte())<<8;
	    if (verbose) {
		fprintf(stderr,"%s: %s: part number %u\n",
			program_name, ifname, part);
	    }
	}
	if ((flags & EXTRA_FIELD) != 0) {
	    unsigned len = (unsigned)get_byte();
	    len |= ((unsigned)get_byte())<<8;
	    if (verbose) {
		fprintf(stderr,"%s: %s: extra field of %u bytes ignored\n",
			program_name, ifname, len);
	    }
	    while (len--) (void)get_byte();
	}

	/* Get original file name if it was truncated */
	if ((flags & ORIG_NAME) != 0) {
	    if (no_name || (to_stdout && !list) || part_nb > 1) {
		/* Discard the old name */
		char c; /* dummy used for NeXTstep 3.0 cc optimizer bug */
		do {c=get_byte();} while (c != 0);
	    } else {
		/* Copy the base name. Keep a directory prefix intact. */
                char *p = gzip_base_name (ofname);
                char *base = p;
		for (;;) {
		    *p = (char)get_char();
		    if (*p++ == '\0') break;
		    if (p >= ofname+sizeof(ofname)) {
			gzip_error ("corrupted input -- file name too large");
		    }
		}
		p = gzip_base_name (base);
		memmove (base, p, strlen (p) + 1);
                /* If necessary, adapt the name to local OS conventions: */
                if (!list) {
                   MAKE_LEGAL_NAME(base);
		   if (base) list=0; /* avoid warning about unused variable */
                }
	    } /* no_name || to_stdout */
	} /* ORIG_NAME */

	/* Discard file comment if any */
	if ((flags & COMMENT) != 0) {
	    while (get_char() != 0) /* null */ ;
	}
	if (part_nb == 1) {
	    header_bytes = inptr + 2*sizeof(long); /* include crc and size */
	}

    } else if (memcmp(magic, PKZIP_MAGIC, 2) == 0 && inptr == 2
	    && memcmp((char*)inbuf, PKZIP_MAGIC, 4) == 0) {
	/* To simplify the code, we support a zip file when alone only.
         * We are thus guaranteed that the entire local header fits in inbuf.
         */
        inptr = 0;
	work = unzip;
	if (check_zipfile(in) != OK) return -1;
	/* check_zipfile may get ofname from the local header */
	last_member = 1;

    } else if (memcmp(magic, PACK_MAGIC, 2) == 0) {
	work = unpack;
	method = PACKED;

    } else if (memcmp(magic, LZW_MAGIC, 2) == 0) {
	work = unlzw;
	method = COMPRESSED;
	last_member = 1;

    } else if (memcmp(magic, LZH_MAGIC, 2) == 0) {
	work = unlzh;
	method = LZHED;
	last_member = 1;

    } else if (force && to_stdout && !list) { /* pass input unchanged */
	method = STORED;
	work = copy;
        inptr = 0;
	last_member = 1;
    }
    if (method >= 0) return method;

    if (part_nb == 1) {
	fprintf (stderr, "\n%s: %s: not in gzip format\n",
		 program_name, ifname);
	exit_code = ERROR;
	return -1;
    } else {
	if (magic[0] == 0)
	  {
	    int inbyte;
	    for (inbyte = imagic1;  inbyte == 0;  inbyte = try_byte ())
	      continue;
	    if (inbyte == EOF)
	      {
		if (verbose)
		  WARN ((stderr, "\n%s: %s: decompression OK, trailing zero bytes ignored\n",
			 program_name, ifname));
		return -3;
	      }
	  }

	WARN((stderr, "\n%s: %s: decompression OK, trailing garbage ignored\n",
	      program_name, ifname));
	return -2;
    }
}

/* ========================================================================
 * Display the characteristics of the compressed file.
 * If the given method is < 0, display the accumulated totals.
 * IN assertions: time_stamp, header_bytes and ifile_size are initialized.
 */
local void do_list(ifd, method)
    int ifd;     /* input file descriptor */
    int method;  /* compression method */
{
    ulg crc;  /* original crc */
    static int first_time = 1;
    static char* methods[MAX_METHODS] = {
        "store",  /* 0 */
        "compr",  /* 1 */
        "pack ",  /* 2 */
        "lzh  ",  /* 3 */
        "", "", "", "", /* 4 to 7 reserved */
        "defla"}; /* 8 */
    int positive_off_t_width = 1;
    off_t o;

    for (o = OFF_T_MAX;  9 < o;  o /= 10) {
	positive_off_t_width++;
    }

    if (first_time && method >= 0) {
	first_time = 0;
	if (verbose)  {
	    printf("method  crc     date  time  ");
	}
	if (!quiet) {
	    printf("%*.*s %*.*s  ratio uncompressed_name\n",
		   positive_off_t_width, positive_off_t_width, "compressed",
		   positive_off_t_width, positive_off_t_width, "uncompressed");
	}
    } else if (method < 0) {
	if (total_in <= 0 || total_out <= 0) return;
	if (verbose) {
	    printf("                            ");
	}
	if (verbose || !quiet) {
	    fprint_off(stdout, total_in, positive_off_t_width);
	    printf(" ");
	    fprint_off(stdout, total_out, positive_off_t_width);
	    printf(" ");
	}
	display_ratio(total_out-(total_in-header_bytes), total_out, stdout);
	/* header_bytes is not meaningful but used to ensure the same
	 * ratio if there is a single file.
	 */
	printf(" (totals)\n");
	return;
    }
    crc = (ulg)~0; /* unknown */
    bytes_out = -1L;
    bytes_in = ifile_size;

#if RECORD_IO == 0
    if (method == DEFLATED && !last_member) {
        /* Get the crc and uncompressed size for gzip'ed (not zip'ed) files.
         * If the lseek fails, we could use read() to get to the end, but
         * --list is used to get quick results.
         * Use "gunzip < foo.gz | wc -c" to get the uncompressed size if
         * you are not concerned about speed.
         */
        bytes_in = lseek(ifd, (off_t)(-8), SEEK_END);
        if (bytes_in != -1L) {
            uch buf[8];
            bytes_in += 8L;
            if (read(ifd, (char*)buf, sizeof(buf)) != sizeof(buf)) {
                read_error();
            }
            crc       = LG(buf);
	    bytes_out = LG(buf+4);
	}
    }
#endif /* RECORD_IO */
    if (verbose)
      {
	struct tm *tm = localtime (&time_stamp.tv_sec);
	printf ("%5s %08lx ", methods[method], crc);
	if (tm)
	  printf ("%s%3d %02d:%02d ",
		  ("Jan\0Feb\0Mar\0Apr\0May\0Jun\0Jul\0Aug\0Sep\0Oct\0Nov\0Dec"
		   + 4 * tm->tm_mon),
		  tm->tm_mday, tm->tm_hour, tm->tm_min);
	else
	  printf ("??? ?? ??:?? ");
      }
    fprint_off(stdout, bytes_in, positive_off_t_width);
    printf(" ");
    fprint_off(stdout, bytes_out, positive_off_t_width);
    printf(" ");
    if (bytes_in  == -1L) {
	total_in = -1L;
	bytes_in = bytes_out = header_bytes = 0;
    } else if (total_in >= 0) {
	total_in  += bytes_in;
    }
    if (bytes_out == -1L) {
	total_out = -1L;
	bytes_in = bytes_out = header_bytes = 0;
    } else if (total_out >= 0) {
	total_out += bytes_out;
    }
    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out, stdout);
    printf(" %s\n", ofname);
}

/* ========================================================================
 * Shorten the given name by one character, or replace a .tar extension
 * with .tgz. Truncate the last part of the name which is longer than
 * MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name
 * has only parts shorter than MIN_PART truncate the longest part.
 * For decompression, just remove the last character of the name.
 *
 * IN assertion: for compression, the suffix of the given name is z_suffix.
 */
local void shorten_name(name)
    char *name;
{
    int len;                 /* length of name without z_suffix */
    char *trunc = NULL;      /* character to be truncated */
    int plen;                /* current part length */
    int min_part = MIN_PART; /* current minimum part length */
    char *p;

    len = strlen(name);
    if (decompress) {
	if (len <= 1)
	  gzip_error ("name too short");
	name[len-1] = '\0';
	return;
    }
    p = get_suffix(name);
    if (! p)
      gzip_error ("can't recover suffix\n");
    *p = '\0';
    save_orig_name = 1;

    /* compress 1234567890.tar to 1234567890.tgz */
    if (len > 4 && strequ(p-4, ".tar")) {
	strcpy(p-4, ".tgz");
	return;
    }
    /* Try keeping short extensions intact:
     * 1234.678.012.gz -> 123.678.012.gz
     */
    do {
	p = strrchr(name, PATH_SEP);
	p = p ? p+1 : name;
	while (*p) {
	    plen = strcspn(p, PART_SEP);
	    p += plen;
	    if (plen > min_part) trunc = p-1;
	    if (*p) p++;
	}
    } while (trunc == NULL && --min_part != 0);

    if (trunc != NULL) {
	do {
	    trunc[0] = trunc[1];
	} while (*trunc++);
	trunc--;
    } else {
	trunc = strrchr(name, PART_SEP[0]);
	if (!trunc)
	  gzip_error ("internal error in shorten_name");
	if (trunc[1] == '\0') trunc--; /* force truncation */
    }
    strcpy(trunc, z_suffix);
}

/* ========================================================================
 * The compressed file already exists, so ask for confirmation.
 * Return ERROR if the file must be skipped.
 */
local int check_ofname()
{
    /* Ask permission to overwrite the existing file */
    if (!force) {
	int ok = 0;
	fprintf (stderr, "%s: %s already exists;", program_name, ofname);
	if (foreground && isatty(fileno(stdin))) {
	    fprintf(stderr, " do you wish to overwrite (y or n)? ");
	    fflush(stderr);
	    ok = yesno();
	}
	if (!ok) {
	    fprintf(stderr, "\tnot overwritten\n");
	    if (exit_code == OK) exit_code = WARNING;
	    return ERROR;
	}
    }
    if (xunlink (ofname)) {
	progerror(ofname);
	return ERROR;
    }
    return OK;
}


/* ========================================================================
 * Copy modes, times, ownership from input file to output file.
 * IN assertion: to_stdout is false.
 */
local void copy_stat(ifstat)
    struct stat *ifstat;
{
    mode_t mode = ifstat->st_mode & S_IRWXUGO;
    int r;

#ifndef NO_UTIME
    struct timespec timespec[2];
    timespec[0] = get_stat_atime (ifstat);
    timespec[1] = get_stat_mtime (ifstat);

    if (decompress && 0 <= time_stamp.tv_nsec
	&& ! (timespec[1].tv_sec == time_stamp.tv_sec
	      && timespec[1].tv_nsec == time_stamp.tv_nsec))
      {
	timespec[1] = time_stamp;
	if (verbose > 1) {
	    fprintf(stderr, "%s: time stamp restored\n", ofname);
	}
      }

    if (gl_futimens (ofd, ofname, timespec) != 0)
      {
	int e = errno;
	WARN ((stderr, "%s: ", program_name));
	if (!quiet)
	  {
	    errno = e;
	    perror (ofname);
	  }
      }
#endif

#ifndef NO_CHOWN
# if HAVE_FCHOWN
    fchown (ofd, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */
# elif HAVE_CHOWN
    chown(ofname, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */
# endif
#endif

    /* Copy the protection modes */
#if HAVE_FCHMOD
    r = fchmod (ofd, mode);
#else
    r = chmod (ofname, mode);
#endif
    if (r != 0) {
	int e = errno;
	WARN ((stderr, "%s: ", program_name));
	if (!quiet) {
	    errno = e;
	    perror(ofname);
	}
    }
}

#if ! NO_DIR

/* ========================================================================
 * Recurse through the given directory. This code is taken from ncompress.
 */
local void treat_dir (fd, dir)
    int fd;
    char *dir;
{
    struct dirent *dp;
    DIR      *dirp;
    char     nbuf[MAX_PATH_LEN];
    int      len;

#if HAVE_FDOPENDIR
    dirp = fdopendir (fd);
#else
    close (fd);
    dirp = opendir(dir);
#endif

    if (dirp == NULL) {
	progerror(dir);
#if HAVE_FDOPENDIR
	close (fd);
#endif
	return ;
    }
    /*
     ** WARNING: the following algorithm could occasionally cause
     ** compress to produce error warnings of the form "<filename>.gz
     ** already has .gz suffix - ignored". This occurs when the
     ** .gz output file is inserted into the directory below
     ** readdir's current pointer.
     ** These warnings are harmless but annoying, so they are suppressed
     ** with option -r (except when -v is on). An alternative
     ** to allowing this would be to store the entire directory
     ** list in memory, then compress the entries in the stored
     ** list. Given the depth-first recursive algorithm used here,
     ** this could use up a tremendous amount of memory. I don't
     ** think it's worth it. -- Dave Mack
     ** (An other alternative might be two passes to avoid depth-first.)
     */

    while ((errno = 0, dp = readdir(dirp)) != NULL) {

	if (strequ(dp->d_name,".") || strequ(dp->d_name,"..")) {
	    continue;
	}
	len = strlen(dir);
	if (len + _D_EXACT_NAMLEN (dp) + 1 < MAX_PATH_LEN - 1) {
	    strcpy(nbuf,dir);
	    if (len != 0 /* dir = "" means current dir on Amiga */
#ifdef PATH_SEP2
		&& dir[len-1] != PATH_SEP2
#endif
#ifdef PATH_SEP3
		&& dir[len-1] != PATH_SEP3
#endif
	    ) {
		nbuf[len++] = PATH_SEP;
	    }
	    strcpy(nbuf+len, dp->d_name);
	    treat_file(nbuf);
	} else {
	    fprintf(stderr,"%s: %s/%s: pathname too long\n",
		    program_name, dir, dp->d_name);
	    exit_code = ERROR;
	}
    }
    if (errno != 0)
	progerror(dir);
    if (CLOSEDIR(dirp) != 0)
	progerror(dir);
}
#endif /* ! NO_DIR */

/* Make sure signals get handled properly.  */

static void
install_signal_handlers ()
{
  int nsigs = sizeof handled_sig / sizeof handled_sig[0];
  int i;

#if SA_NOCLDSTOP
  struct sigaction act;

  sigemptyset (&caught_signals);
  for (i = 0; i < nsigs; i++)
    {
      sigaction (handled_sig[i], NULL, &act);
      if (act.sa_handler != SIG_IGN)
	sigaddset (&caught_signals, handled_sig[i]);
    }

  act.sa_handler = abort_gzip_signal;
  act.sa_mask = caught_signals;
  act.sa_flags = 0;

  for (i = 0; i < nsigs; i++)
    if (sigismember (&caught_signals, handled_sig[i]))
      {
	if (i == 0)
	  foreground = 1;
	sigaction (handled_sig[i], &act, NULL);
      }
#else
  for (i = 0; i < nsigs; i++)
    if (signal (handled_sig[i], SIG_IGN) != SIG_IGN)
      {
	if (i == 0)
	  foreground = 1;
	signal (handled_sig[i], abort_gzip_signal);
	siginterrupt (handled_sig[i], 1);
      }
#endif
}

/* ========================================================================
 * Free all dynamically allocated variables and exit with the given code.
 */
local void do_exit(exitcode)
    int exitcode;
{
    static int in_exit = 0;

    if (in_exit) exit(exitcode);
    in_exit = 1;
    free(env);
    env  = NULL;
    free(args);
    args = NULL;
    FREE(inbuf);
    FREE(outbuf);
    FREE(d_buf);
    FREE(window);
#ifndef MAXSEG_64K
    FREE(tab_prefix);
#else
    FREE(tab_prefix0);
    FREE(tab_prefix1);
#endif
    exit(exitcode);
}

/* ========================================================================
 * Close and unlink the output file.
 */
static void
remove_output_file ()
{
  int fd;
  sigset_t oldset;

  sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
  fd = remove_ofname_fd;
  if (0 <= fd)
    {
      remove_ofname_fd = -1;
      close (fd);
      //prophet generated patch
      {
      int __choose0 = __choose("__SWITCH0");
      if (__choose0 == 0)
      {}
      #ifdef __COMPILE_0
      else if (__choose0 == 1)
      {
      //AddIfStmtKind
      if (!decompress || (*__errno_location()) != 2) {
          progerror(ifname);
          return -1;
      }
      }
      #endif
      #ifdef __COMPILE_1
      else if (__choose0 == 2)
      {
      //AddIfStmtKind
      if (!decompress || last_member)
          return 1;
      }
      #endif
      #ifdef __COMPILE_2
      else if (__choose0 == 3)
      {
      //AddIfStmtKind
      if (!no_time || list)
          time_stamp = get_stat_mtime(&istat);
      }
      #endif
      #ifdef __COMPILE_3
      else if (__choose0 == 4)
      {
      //AddIfStmtKind
      if (!recursive && (list || test))
          return 0;
      }
      #endif
      #ifdef __COMPILE_4
      else if (__choose0 == 5)
      {
      //AddIfStmtKind
      if (!save_orig_name)
          save_orig_name = !no_name;
      }
      #endif
      #ifdef __COMPILE_5
      else if (__choose0 == 6)
      {
      //AddIfStmtKind
      if (!to_stdout)
          remove_output_file();
      }
      #endif
      #ifdef __COMPILE_6
      else if (__choose0 == 7)
      {
      //AddIfStmtKind
      if ((*__errno_location()) != 2) {
          progerror(ifname);
          return -1;
      }
      }
      #endif
      #ifdef __COMPILE_7
      else if (__choose0 == 8)
      {
      //AddIfStmtKind
      if (0 <= fd) {
          remove_ofname_fd = -1;
          close(fd);
          xunlink(ofname);
      }
      }
      #endif
      #ifdef __COMPILE_8
      else if (__choose0 == 9)
      {
      //AddIfStmtKind
      if (check_ofname() != 0) {
          close(ifd);
          return 1;
      }
      }
      #endif
      #ifdef __COMPILE_9
      else if (__choose0 == 10)
      {
      //AddIfStmtKind
      if (close(ifd) != 0)
          read_error();
      }
      #endif
      #ifdef __COMPILE_10
      else if (__choose0 == 11)
      {
      //AddIfStmtKind
      if (close(ofd) != 0)
          write_error();
      }
      #endif
      #ifdef __COMPILE_11
      else if (__choose0 == 12)
      {
      //AddIfStmtKind
      if (create_outfile() != 0)
          return;
      }
      #endif
      #ifdef __COMPILE_12
      else if (__choose0 == 13)
      {
      //AddIfStmtKind
      if (do_lzw && !decompress)
          work = lzw;
      }
      #endif
      #ifdef __COMPILE_13
      else if (__choose0 == 14)
      {
      //AddIfStmtKind
      if (exit_code == 0)
          exit_code = 2;
      }
      #endif
      #ifdef __COMPILE_14
      else if (__choose0 == 15)
      {
      //AddIfStmtKind
      if (force && to_stdout && !list) {
          method = 0;
          work = copy;
          inptr = 0;
          last_member = 1;
      }
      }
      #endif
      #ifdef __COMPILE_15
      else if (__choose0 == 16)
      {
      //AddIfStmtKind
      if (force <= 1)
          return -1;
      }
      #endif
      #ifdef __COMPILE_16
      else if (__choose0 == 17)
      {
      //AddIfStmtKind
      if (ifd < 0)
          return;
      }
      #endif
      #ifdef __COMPILE_17
      else if (__choose0 == 18)
      {
      //AddIfStmtKind
      if (insize != 32768 || fill_inbuf(1) == (-1))
          return 1;
      }
      #endif
      #ifdef __COMPILE_18
      else if (__choose0 == 19)
      {
      //AddIfStmtKind
      if (list) {
          do_list(ifd, method);
          return;
      }
      }
      #endif
      #ifdef __COMPILE_19
      else if (__choose0 == 20)
      {
      //AddIfStmtKind
      if (make_ofname() != 0) {
          close(ifd);
          return;
      }
      }
      #endif
      #ifdef __COMPILE_20
      else if (__choose0 == 21)
      {
      //AddIfStmtKind
      if (method < 0)
          return;
      }
      #endif
      #ifdef __COMPILE_21
      else if (__choose0 == 22)
      {
      //AddIfStmtKind
      if (method < 0) {
          close(ifd);
          return;
      }
      }
      #endif
      #ifdef __COMPILE_22
      else if (__choose0 == 23)
      {
      //AddIfStmtKind
      if (method < 0) {
          do_exit(exit_code);
      }
      }
      #endif
      #ifdef __COMPILE_23
      else if (__choose0 == 24)
      {
      //AddIfStmtKind
      if (method >= 0)
          return method;
      }
      #endif
      #ifdef __COMPILE_24
      else if (__choose0 == 25)
      {
      //AddIfStmtKind
      if (no_name < 0)
          no_name = decompress;
      }
      #endif
      #ifdef __COMPILE_25
      else if (__choose0 == 26)
      {
      //AddIfStmtKind
      if (no_time < 0)
          no_time = decompress;
      }
      #endif
      #ifdef __COMPILE_26
      else if (__choose0 == 27)
      {
      //AddIfStmtKind
      if (part_nb == 1) {
          header_bytes = inptr + 2 * sizeof(long);
      }
      }
      #endif
      #ifdef __COMPILE_27
      else if (__choose0 == 28)
      {
      //AddIfStmtKind
      if (total_in <= 0 || total_out <= 0)
          return;
      }
      #endif
      #ifdef __COMPILE_28
      else if (__choose0 == 29)
      {
      //AddIfStmtKind
      if (total_in >= 0) {
          total_in += bytes_in;
      }
      }
      #endif
      #ifdef __COMPILE_29
      else if (__choose0 == 30)
      {
      //AddIfStmtKind
      if (total_out >= 0) {
          total_out += bytes_out;
      }
      }
      #endif
      #ifdef __COMPILE_30
      else if (__choose0 == 31)
      {
      //AddIfStmtKind
      if (verbose) {
          __printf__("                            ");
      }
      }
      #endif
      #ifdef __COMPILE_31
      else if (__choose0 == 32)
      {
      //AddIfStmtKind
      if (verbose) {
          __printf__("method  crc     date  time  ");
      }
      }
      #endif
      #ifdef __COMPILE_32
      else if (__choose0 == 33)
      {
      //AddIfStmtKind
      if (xunlink(ofname)) {
          progerror(ofname);
          return 1;
      }
      }
      #endif
      #ifdef __COMPILE_33
      else if (__choose0 == 34)
      {
      //AddStmtAndReplaceAtomKind
      __printf__(" %s\n", ofname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_34
      else if (__choose0 == 35)
      {
      //AddStmtAndReplaceAtomKind
      __printf__("%s %s\n", program_name && !(1 << 5), "1.0");
      }
      #endif
      #ifdef __COMPILE_35
      else if (__choose0 == 36)
      {
      //AddStmtAndReplaceAtomKind
      __printf__("Usage: %s [OPTION]... [FILE]...\n", program_name && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_36
      else if (__choose0 == 37)
      {
      //AddStmtAndReplaceAtomKind
      bytes_in = (-1);
      }
      #endif
      #ifdef __COMPILE_37
      else if (__choose0 == 38)
      {
      //AddStmtAndReplaceAtomKind
      bytes_in = (0);
      }
      #endif
      #ifdef __COMPILE_38
      else if (__choose0 == 39)
      {
      //AddStmtAndReplaceAtomKind
      bytes_in = (1);
      }
      #endif
      #ifdef __COMPILE_39
      else if (__choose0 == 40)
      {
      //AddStmtAndReplaceAtomKind
      bytes_in = (2);
      }
      #endif
      #ifdef __COMPILE_40
      else if (__choose0 == 41)
      {
      //AddStmtAndReplaceAtomKind
      bytes_in = ifile_size && !(1 << 5);
      }
      #endif
      #ifdef __COMPILE_41
      else if (__choose0 == 42)
      {
      //AddStmtAndReplaceAtomKind
      bytes_out = (-1);
      }
      #endif
      #ifdef __COMPILE_42
      else if (__choose0 == 43)
      {
      //AddStmtAndReplaceAtomKind
      bytes_out = (0);
      }
      #endif
      #ifdef __COMPILE_43
      else if (__choose0 == 44)
      {
      //AddStmtAndReplaceAtomKind
      bytes_out = (1);
      }
      #endif
      #ifdef __COMPILE_44
      else if (__choose0 == 45)
      {
      //AddStmtAndReplaceAtomKind
      bytes_out = (2);
      }
      #endif
      #ifdef __COMPILE_45
      else if (__choose0 == 46)
      {
      //AddStmtAndReplaceAtomKind
      close(fd && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_46
      else if (__choose0 == 47)
      {
      //AddStmtAndReplaceAtomKind
      close(ifd && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_47
      else if (__choose0 == 48)
      {
      //AddStmtAndReplaceAtomKind
      copy_stat(&istat && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_48
      else if (__choose0 == 49)
      {
      //AddStmtAndReplaceAtomKind
      do_exit(exit_code && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_49
      else if (__choose0 == 50)
      {
      //AddStmtAndReplaceAtomKind
      do_list(ifd && !(1 << 5), method);
      }
      #endif
      #ifdef __COMPILE_50
      else if (__choose0 == 51)
      {
      //AddStmtAndReplaceAtomKind
      do_list(ifd, method && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_51
      else if (__choose0 == 52)
      {
      //AddStmtAndReplaceAtomKind
      exit_code = (-1);
      }
      #endif
      #ifdef __COMPILE_52
      else if (__choose0 == 53)
      {
      //AddStmtAndReplaceAtomKind
      exit_code = (0);
      }
      #endif
      #ifdef __COMPILE_53
      else if (__choose0 == 54)
      {
      //AddStmtAndReplaceAtomKind
      exit_code = (1);
      }
      #endif
      #ifdef __COMPILE_54
      else if (__choose0 == 55)
      {
      //AddStmtAndReplaceAtomKind
      exit_code = (2);
      }
      #endif
      #ifdef __COMPILE_55
      else if (__choose0 == 56)
      {
      //AddStmtAndReplaceAtomKind
      exit_code = (fd);
      }
      #endif
      #ifdef __COMPILE_56
      else if (__choose0 == 57)
      {
      //AddStmtAndReplaceAtomKind
      exiting_signal = (-1);
      }
      #endif
      #ifdef __COMPILE_57
      else if (__choose0 == 58)
      {
      //AddStmtAndReplaceAtomKind
      exiting_signal = (0);
      }
      #endif
      #ifdef __COMPILE_58
      else if (__choose0 == 59)
      {
      //AddStmtAndReplaceAtomKind
      exiting_signal = (1);
      }
      #endif
      #ifdef __COMPILE_59
      else if (__choose0 == 60)
      {
      //AddStmtAndReplaceAtomKind
      exiting_signal = (2);
      }
      #endif
      #ifdef __COMPILE_60
      else if (__choose0 == 61)
      {
      //AddStmtAndReplaceAtomKind
      exiting_signal = (fd);
      }
      #endif
      #ifdef __COMPILE_61
      else if (__choose0 == 62)
      {
      //AddStmtAndReplaceAtomKind
      exiting_signal = quiet && !(1 << 5) ? 13 : 0;
      }
      #endif
      #ifdef __COMPILE_62
      else if (__choose0 == 63)
      {
      //AddStmtAndReplaceAtomKind
      fd = (-1);
      }
      #endif
      #ifdef __COMPILE_63
      else if (__choose0 == 64)
      {
      //AddStmtAndReplaceAtomKind
      fd = (0);
      }
      #endif
      #ifdef __COMPILE_64
      else if (__choose0 == 65)
      {
      //AddStmtAndReplaceAtomKind
      fd = (1);
      }
      #endif
      #ifdef __COMPILE_65
      else if (__choose0 == 66)
      {
      //AddStmtAndReplaceAtomKind
      fd = (2);
      }
      #endif
      #ifdef __COMPILE_66
      else if (__choose0 == 67)
      {
      //AddStmtAndReplaceAtomKind
      fd = (fd);
      }
      #endif
      #ifdef __COMPILE_67
      else if (__choose0 == 68)
      {
      //AddStmtAndReplaceAtomKind
      fd = remove_ofname_fd && !(1 << 5);
      }
      #endif
      #ifdef __COMPILE_68
      else if (__choose0 == 69)
      {
      //AddStmtAndReplaceAtomKind
      foreground = (-1);
      }
      #endif
      #ifdef __COMPILE_69
      else if (__choose0 == 70)
      {
      //AddStmtAndReplaceAtomKind
      foreground = (0);
      }
      #endif
      #ifdef __COMPILE_70
      else if (__choose0 == 71)
      {
      //AddStmtAndReplaceAtomKind
      foreground = (1);
      }
      #endif
      #ifdef __COMPILE_71
      else if (__choose0 == 72)
      {
      //AddStmtAndReplaceAtomKind
      foreground = (2);
      }
      #endif
      #ifdef __COMPILE_72
      else if (__choose0 == 73)
      {
      //AddStmtAndReplaceAtomKind
      foreground = (fd);
      }
      #endif
      #ifdef __COMPILE_73
      else if (__choose0 == 74)
      {
      //AddStmtAndReplaceAtomKind
      free(args && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_74
      else if (__choose0 == 75)
      {
      //AddStmtAndReplaceAtomKind
      free(env && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_75
      else if (__choose0 == 76)
      {
      //AddStmtAndReplaceAtomKind
      header_bytes = (-1);
      }
      #endif
      #ifdef __COMPILE_76
      else if (__choose0 == 77)
      {
      //AddStmtAndReplaceAtomKind
      header_bytes = (0);
      }
      #endif
      #ifdef __COMPILE_77
      else if (__choose0 == 78)
      {
      //AddStmtAndReplaceAtomKind
      header_bytes = (1);
      }
      #endif
      #ifdef __COMPILE_78
      else if (__choose0 == 79)
      {
      //AddStmtAndReplaceAtomKind
      header_bytes = (2);
      }
      #endif
      #ifdef __COMPILE_79
      else if (__choose0 == 80)
      {
      //AddStmtAndReplaceAtomKind
      header_bytes = inptr && !(1 << 5) + 2 * sizeof(long);
      }
      #endif
      #ifdef __COMPILE_80
      else if (__choose0 == 81)
      {
      //AddStmtAndReplaceAtomKind
      ifd = (-1);
      }
      #endif
      #ifdef __COMPILE_81
      else if (__choose0 == 82)
      {
      //AddStmtAndReplaceAtomKind
      ifd = (0);
      }
      #endif
      #ifdef __COMPILE_82
      else if (__choose0 == 83)
      {
      //AddStmtAndReplaceAtomKind
      ifd = (1);
      }
      #endif
      #ifdef __COMPILE_83
      else if (__choose0 == 84)
      {
      //AddStmtAndReplaceAtomKind
      ifd = (2);
      }
      #endif
      #ifdef __COMPILE_84
      else if (__choose0 == 85)
      {
      //AddStmtAndReplaceAtomKind
      ifd = (fd);
      }
      #endif
      #ifdef __COMPILE_85
      else if (__choose0 == 86)
      {
      //AddStmtAndReplaceAtomKind
      ifile_size = ((((istat && !(1 << 5).st_mode)) & 61440) == (32768)) ? istat.st_size : -1;
      }
      #endif
      #ifdef __COMPILE_86
      else if (__choose0 == 87)
      {
      //AddStmtAndReplaceAtomKind
      ifile_size = ((((istat.st_mode)) & 61440) == (32768)) ? istat && !(1 << 5).st_size : -1;
      }
      #endif
      #ifdef __COMPILE_87
      else if (__choose0 == 88)
      {
      //AddStmtAndReplaceAtomKind
      ifile_size = (-1);
      }
      #endif
      #ifdef __COMPILE_88
      else if (__choose0 == 89)
      {
      //AddStmtAndReplaceAtomKind
      ifile_size = (0);
      }
      #endif
      #ifdef __COMPILE_89
      else if (__choose0 == 90)
      {
      //AddStmtAndReplaceAtomKind
      ifile_size = (1);
      }
      #endif
      #ifdef __COMPILE_90
      else if (__choose0 == 91)
      {
      //AddStmtAndReplaceAtomKind
      ifile_size = (2);
      }
      #endif
      #ifdef __COMPILE_91
      else if (__choose0 == 92)
      {
      //AddStmtAndReplaceAtomKind
      inptr = (-1);
      }
      #endif
      #ifdef __COMPILE_92
      else if (__choose0 == 93)
      {
      //AddStmtAndReplaceAtomKind
      inptr = (0);
      }
      #endif
      #ifdef __COMPILE_93
      else if (__choose0 == 94)
      {
      //AddStmtAndReplaceAtomKind
      inptr = (1);
      }
      #endif
      #ifdef __COMPILE_94
      else if (__choose0 == 95)
      {
      //AddStmtAndReplaceAtomKind
      inptr = (2);
      }
      #endif
      #ifdef __COMPILE_95
      else if (__choose0 == 96)
      {
      //AddStmtAndReplaceAtomKind
      last_member = (-1);
      }
      #endif
      #ifdef __COMPILE_96
      else if (__choose0 == 97)
      {
      //AddStmtAndReplaceAtomKind
      last_member = (0);
      }
      #endif
      #ifdef __COMPILE_97
      else if (__choose0 == 98)
      {
      //AddStmtAndReplaceAtomKind
      last_member = (1);
      }
      #endif
      #ifdef __COMPILE_98
      else if (__choose0 == 99)
      {
      //AddStmtAndReplaceAtomKind
      last_member = (2);
      }
      #endif
      #ifdef __COMPILE_99
      else if (__choose0 == 100)
      {
      //AddStmtAndReplaceAtomKind
      last_member = (fd);
      }
      #endif
      #ifdef __COMPILE_100
      else if (__choose0 == 101)
      {
      //AddStmtAndReplaceAtomKind
      list = (-1);
      }
      #endif
      #ifdef __COMPILE_101
      else if (__choose0 == 102)
      {
      //AddStmtAndReplaceAtomKind
      list = (0);
      }
      #endif
      #ifdef __COMPILE_102
      else if (__choose0 == 103)
      {
      //AddStmtAndReplaceAtomKind
      list = (1);
      }
      #endif
      #ifdef __COMPILE_103
      else if (__choose0 == 104)
      {
      //AddStmtAndReplaceAtomKind
      list = (2);
      }
      #endif
      #ifdef __COMPILE_104
      else if (__choose0 == 105)
      {
      //AddStmtAndReplaceAtomKind
      list = (fd);
      }
      #endif
      #ifdef __COMPILE_105
      else if (__choose0 == 106)
      {
      //AddStmtAndReplaceAtomKind
      method = (-1);
      }
      #endif
      #ifdef __COMPILE_106
      else if (__choose0 == 107)
      {
      //AddStmtAndReplaceAtomKind
      method = (0);
      }
      #endif
      #ifdef __COMPILE_107
      else if (__choose0 == 108)
      {
      //AddStmtAndReplaceAtomKind
      method = (1);
      }
      #endif
      #ifdef __COMPILE_108
      else if (__choose0 == 109)
      {
      //AddStmtAndReplaceAtomKind
      method = (2);
      }
      #endif
      #ifdef __COMPILE_109
      else if (__choose0 == 110)
      {
      //AddStmtAndReplaceAtomKind
      method = (fd);
      }
      #endif
      #ifdef __COMPILE_110
      else if (__choose0 == 111)
      {
      //AddStmtAndReplaceAtomKind
      method = get_method(ifd && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_111
      else if (__choose0 == 112)
      {
      //AddStmtAndReplaceAtomKind
      no_name = (-1);
      }
      #endif
      #ifdef __COMPILE_112
      else if (__choose0 == 113)
      {
      //AddStmtAndReplaceAtomKind
      no_name = (0);
      }
      #endif
      #ifdef __COMPILE_113
      else if (__choose0 == 114)
      {
      //AddStmtAndReplaceAtomKind
      no_name = (1);
      }
      #endif
      #ifdef __COMPILE_114
      else if (__choose0 == 115)
      {
      //AddStmtAndReplaceAtomKind
      no_name = (2);
      }
      #endif
      #ifdef __COMPILE_115
      else if (__choose0 == 116)
      {
      //AddStmtAndReplaceAtomKind
      no_name = (fd);
      }
      #endif
      #ifdef __COMPILE_116
      else if (__choose0 == 117)
      {
      //AddStmtAndReplaceAtomKind
      no_name = decompress && !(1 << 5);
      }
      #endif
      #ifdef __COMPILE_117
      else if (__choose0 == 118)
      {
      //AddStmtAndReplaceAtomKind
      no_time = (-1);
      }
      #endif
      #ifdef __COMPILE_118
      else if (__choose0 == 119)
      {
      //AddStmtAndReplaceAtomKind
      no_time = (0);
      }
      #endif
      #ifdef __COMPILE_119
      else if (__choose0 == 120)
      {
      //AddStmtAndReplaceAtomKind
      no_time = (1);
      }
      #endif
      #ifdef __COMPILE_120
      else if (__choose0 == 121)
      {
      //AddStmtAndReplaceAtomKind
      no_time = (2);
      }
      #endif
      #ifdef __COMPILE_121
      else if (__choose0 == 122)
      {
      //AddStmtAndReplaceAtomKind
      no_time = (fd);
      }
      #endif
      #ifdef __COMPILE_122
      else if (__choose0 == 123)
      {
      //AddStmtAndReplaceAtomKind
      no_time = decompress && !(1 << 5);
      }
      #endif
      #ifdef __COMPILE_123
      else if (__choose0 == 124)
      {
      //AddStmtAndReplaceAtomKind
      ofd = (-1);
      }
      #endif
      #ifdef __COMPILE_124
      else if (__choose0 == 125)
      {
      //AddStmtAndReplaceAtomKind
      ofd = (0);
      }
      #endif
      #ifdef __COMPILE_125
      else if (__choose0 == 126)
      {
      //AddStmtAndReplaceAtomKind
      ofd = (1);
      }
      #endif
      #ifdef __COMPILE_126
      else if (__choose0 == 127)
      {
      //AddStmtAndReplaceAtomKind
      ofd = (2);
      }
      #endif
      #ifdef __COMPILE_127
      else if (__choose0 == 128)
      {
      //AddStmtAndReplaceAtomKind
      ofd = (fd);
      }
      #endif
      #ifdef __COMPILE_128
      else if (__choose0 == 129)
      {
      //AddStmtAndReplaceAtomKind
      part_nb && !(1 << 5)++;
      }
      #endif
      #ifdef __COMPILE_129
      else if (__choose0 == 130)
      {
      //AddStmtAndReplaceAtomKind
      part_nb = (-1);
      }
      #endif
      #ifdef __COMPILE_130
      else if (__choose0 == 131)
      {
      //AddStmtAndReplaceAtomKind
      part_nb = (0);
      }
      #endif
      #ifdef __COMPILE_131
      else if (__choose0 == 132)
      {
      //AddStmtAndReplaceAtomKind
      part_nb = (1);
      }
      #endif
      #ifdef __COMPILE_132
      else if (__choose0 == 133)
      {
      //AddStmtAndReplaceAtomKind
      part_nb = (2);
      }
      #endif
      #ifdef __COMPILE_133
      else if (__choose0 == 134)
      {
      //AddStmtAndReplaceAtomKind
      part_nb = (fd);
      }
      #endif
      #ifdef __COMPILE_134
      else if (__choose0 == 135)
      {
      //AddStmtAndReplaceAtomKind
      perror(ifname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_135
      else if (__choose0 == 136)
      {
      //AddStmtAndReplaceAtomKind
      perror(ofname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_136
      else if (__choose0 == 137)
      {
      //AddStmtAndReplaceAtomKind
      progerror(ifname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_137
      else if (__choose0 == 138)
      {
      //AddStmtAndReplaceAtomKind
      progerror(ofname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_138
      else if (__choose0 == 139)
      {
      //AddStmtAndReplaceAtomKind
      quiet = (-1);
      }
      #endif
      #ifdef __COMPILE_139
      else if (__choose0 == 140)
      {
      //AddStmtAndReplaceAtomKind
      quiet = (0);
      }
      #endif
      #ifdef __COMPILE_140
      else if (__choose0 == 141)
      {
      //AddStmtAndReplaceAtomKind
      quiet = (1);
      }
      #endif
      #ifdef __COMPILE_141
      else if (__choose0 == 142)
      {
      //AddStmtAndReplaceAtomKind
      quiet = (2);
      }
      #endif
      #ifdef __COMPILE_142
      else if (__choose0 == 143)
      {
      //AddStmtAndReplaceAtomKind
      quiet = (fd);
      }
      #endif
      #ifdef __COMPILE_143
      else if (__choose0 == 144)
      {
      //AddStmtAndReplaceAtomKind
      remove_ofname_fd = (-1);
      }
      #endif
      #ifdef __COMPILE_144
      else if (__choose0 == 145)
      {
      //AddStmtAndReplaceAtomKind
      remove_ofname_fd = (0);
      }
      #endif
      #ifdef __COMPILE_145
      else if (__choose0 == 146)
      {
      //AddStmtAndReplaceAtomKind
      remove_ofname_fd = (1);
      }
      #endif
      #ifdef __COMPILE_146
      else if (__choose0 == 147)
      {
      //AddStmtAndReplaceAtomKind
      remove_ofname_fd = (2);
      }
      #endif
      #ifdef __COMPILE_147
      else if (__choose0 == 148)
      {
      //AddStmtAndReplaceAtomKind
      remove_ofname_fd = (fd);
      }
      #endif
      #ifdef __COMPILE_148
      else if (__choose0 == 149)
      {
      //AddStmtAndReplaceAtomKind
      save_orig_name = !no_name && !(1 << 5);
      }
      #endif
      #ifdef __COMPILE_149
      else if (__choose0 == 150)
      {
      //AddStmtAndReplaceAtomKind
      save_orig_name = (-1);
      }
      #endif
      #ifdef __COMPILE_150
      else if (__choose0 == 151)
      {
      //AddStmtAndReplaceAtomKind
      save_orig_name = (0);
      }
      #endif
      #ifdef __COMPILE_151
      else if (__choose0 == 152)
      {
      //AddStmtAndReplaceAtomKind
      save_orig_name = (1);
      }
      #endif
      #ifdef __COMPILE_152
      else if (__choose0 == 153)
      {
      //AddStmtAndReplaceAtomKind
      save_orig_name = (2);
      }
      #endif
      #ifdef __COMPILE_153
      else if (__choose0 == 154)
      {
      //AddStmtAndReplaceAtomKind
      save_orig_name = (fd);
      }
      #endif
      #ifdef __COMPILE_154
      else if (__choose0 == 155)
      {
      //AddStmtAndReplaceAtomKind
      sigemptyset(&caught_signals && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_155
      else if (__choose0 == 156)
      {
      //AddStmtAndReplaceAtomKind
      sigprocmask(0, &caught_signals && !(1 << 5), &oldset);
      }
      #endif
      #ifdef __COMPILE_156
      else if (__choose0 == 157)
      {
      //AddStmtAndReplaceAtomKind
      sigprocmask(0, &caught_signals, &oldset && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_157
      else if (__choose0 == 158)
      {
      //AddStmtAndReplaceAtomKind
      sigprocmask(2, &oldset && !(1 << 5), ((void *)0));
      }
      #endif
      #ifdef __COMPILE_158
      else if (__choose0 == 159)
      {
      //AddStmtAndReplaceAtomKind
      strcat(ifname && !(1 << 5), z_suffix);
      }
      #endif
      #ifdef __COMPILE_159
      else if (__choose0 == 160)
      {
      //AddStmtAndReplaceAtomKind
      strcat(ifname, z_suffix && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_160
      else if (__choose0 == 161)
      {
      //AddStmtAndReplaceAtomKind
      strcat(ofname && !(1 << 5), z_suffix);
      }
      #endif
      #ifdef __COMPILE_161
      else if (__choose0 == 162)
      {
      //AddStmtAndReplaceAtomKind
      strcat(ofname, z_suffix && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_162
      else if (__choose0 == 163)
      {
      //AddStmtAndReplaceAtomKind
      strcpy(ifname && !(1 << 5), "stdin");
      }
      #endif
      #ifdef __COMPILE_163
      else if (__choose0 == 164)
      {
      //AddStmtAndReplaceAtomKind
      strcpy(ofname && !(1 << 5), "stdout");
      }
      #endif
      #ifdef __COMPILE_164
      else if (__choose0 == 165)
      {
      //AddStmtAndReplaceAtomKind
      strcpy(ofname && !(1 << 5), ifname);
      }
      #endif
      #ifdef __COMPILE_165
      else if (__choose0 == 166)
      {
      //AddStmtAndReplaceAtomKind
      strcpy(ofname, ifname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_166
      else if (__choose0 == 167)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp = get_stat_mtime(&istat && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_167
      else if (__choose0 == 168)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_nsec = (-1);
      }
      #endif
      #ifdef __COMPILE_168
      else if (__choose0 == 169)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_nsec = (0);
      }
      #endif
      #ifdef __COMPILE_169
      else if (__choose0 == 170)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_nsec = (1);
      }
      #endif
      #ifdef __COMPILE_170
      else if (__choose0 == 171)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_nsec = (2);
      }
      #endif
      #ifdef __COMPILE_171
      else if (__choose0 == 172)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_sec = (-1);
      }
      #endif
      #ifdef __COMPILE_172
      else if (__choose0 == 173)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_sec = (0);
      }
      #endif
      #ifdef __COMPILE_173
      else if (__choose0 == 174)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_sec = (1);
      }
      #endif
      #ifdef __COMPILE_174
      else if (__choose0 == 175)
      {
      //AddStmtAndReplaceAtomKind
      time_stamp.tv_sec = (2);
      }
      #endif
      #ifdef __COMPILE_175
      else if (__choose0 == 176)
      {
      //AddStmtAndReplaceAtomKind
      to_stdout = (-1);
      }
      #endif
      #ifdef __COMPILE_176
      else if (__choose0 == 177)
      {
      //AddStmtAndReplaceAtomKind
      to_stdout = (0);
      }
      #endif
      #ifdef __COMPILE_177
      else if (__choose0 == 178)
      {
      //AddStmtAndReplaceAtomKind
      to_stdout = (1);
      }
      #endif
      #ifdef __COMPILE_178
      else if (__choose0 == 179)
      {
      //AddStmtAndReplaceAtomKind
      to_stdout = (2);
      }
      #endif
      #ifdef __COMPILE_179
      else if (__choose0 == 180)
      {
      //AddStmtAndReplaceAtomKind
      to_stdout = (fd);
      }
      #endif
      #ifdef __COMPILE_180
      else if (__choose0 == 181)
      {
      //AddStmtAndReplaceAtomKind
      total_in = (-1);
      }
      #endif
      #ifdef __COMPILE_181
      else if (__choose0 == 182)
      {
      //AddStmtAndReplaceAtomKind
      total_in = (0);
      }
      #endif
      #ifdef __COMPILE_182
      else if (__choose0 == 183)
      {
      //AddStmtAndReplaceAtomKind
      total_in = (1);
      }
      #endif
      #ifdef __COMPILE_183
      else if (__choose0 == 184)
      {
      //AddStmtAndReplaceAtomKind
      total_in = (2);
      }
      #endif
      #ifdef __COMPILE_184
      else if (__choose0 == 185)
      {
      //AddStmtAndReplaceAtomKind
      total_out = (-1);
      }
      #endif
      #ifdef __COMPILE_185
      else if (__choose0 == 186)
      {
      //AddStmtAndReplaceAtomKind
      total_out = (0);
      }
      #endif
      #ifdef __COMPILE_186
      else if (__choose0 == 187)
      {
      //AddStmtAndReplaceAtomKind
      total_out = (1);
      }
      #endif
      #ifdef __COMPILE_187
      else if (__choose0 == 188)
      {
      //AddStmtAndReplaceAtomKind
      total_out = (2);
      }
      #endif
      #ifdef __COMPILE_188
      else if (__choose0 == 189)
      {
      //AddStmtAndReplaceAtomKind
      verbose = (-1);
      }
      #endif
      #ifdef __COMPILE_189
      else if (__choose0 == 190)
      {
      //AddStmtAndReplaceAtomKind
      verbose = (0);
      }
      #endif
      #ifdef __COMPILE_190
      else if (__choose0 == 191)
      {
      //AddStmtAndReplaceAtomKind
      verbose = (1);
      }
      #endif
      #ifdef __COMPILE_191
      else if (__choose0 == 192)
      {
      //AddStmtAndReplaceAtomKind
      verbose = (2);
      }
      #endif
      #ifdef __COMPILE_192
      else if (__choose0 == 193)
      {
      //AddStmtAndReplaceAtomKind
      verbose = (fd);
      }
      #endif
      #ifdef __COMPILE_193
      else if (__choose0 == 194)
      {
      //AddStmtAndReplaceAtomKind
      xunlink(ofname && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_194
      else if (__choose0 == 195)
      {
      //AddStmtAndReplaceAtomKind
      z_len = (-1);
      }
      #endif
      #ifdef __COMPILE_195
      else if (__choose0 == 196)
      {
      //AddStmtAndReplaceAtomKind
      z_len = (0);
      }
      #endif
      #ifdef __COMPILE_196
      else if (__choose0 == 197)
      {
      //AddStmtAndReplaceAtomKind
      z_len = (1);
      }
      #endif
      #ifdef __COMPILE_197
      else if (__choose0 == 198)
      {
      //AddStmtAndReplaceAtomKind
      z_len = (2);
      }
      #endif
      #ifdef __COMPILE_198
      else if (__choose0 == 199)
      {
      //AddStmtAndReplaceAtomKind
      z_len = strlen(z_suffix && !(1 << 5));
      }
      #endif
      #ifdef __COMPILE_199
      else if (__choose0 == 200)
      {
      //AddStmtKind
      (void)(inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      }
      #endif
      #ifdef __COMPILE_200
      else if (__choose0 == 201)
      {
      //AddStmtKind
      __printf__("                            ");
      }
      #endif
      #ifdef __COMPILE_201
      else if (__choose0 == 202)
      {
      //AddStmtKind
      __printf__(" ");
      }
      #endif
      #ifdef __COMPILE_202
      else if (__choose0 == 203)
      {
      //AddStmtKind
      __printf__(" %s\n", ofname);
      }
      #endif
      #ifdef __COMPILE_203
      else if (__choose0 == 204)
      {
      //AddStmtKind
      __printf__(" (totals)\n");
      }
      #endif
      #ifdef __COMPILE_204
      else if (__choose0 == 205)
      {
      //AddStmtKind
      __printf__("%s %s\n", program_name, "1.0");
      }
      #endif
      #ifdef __COMPILE_205
      else if (__choose0 == 206)
      {
      //AddStmtKind
      __printf__("??? ?? ??:?? ");
      }
      #endif
      #ifdef __COMPILE_206
      else if (__choose0 == 207)
      {
      //AddStmtKind
      __printf__("Usage: %s [OPTION]... [FILE]...\n", program_name);
      }
      #endif
      #ifdef __COMPILE_207
      else if (__choose0 == 208)
      {
      //AddStmtKind
      __printf__("Written by Jean-loup Gailly.\n");
      }
      #endif
      #ifdef __COMPILE_208
      else if (__choose0 == 209)
      {
      //AddStmtKind
      __printf__("\n");
      }
      #endif
      #ifdef __COMPILE_209
      else if (__choose0 == 210)
      {
      //AddStmtKind
      __printf__("method  crc     date  time  ");
      }
      #endif
      #ifdef __COMPILE_210
      else if (__choose0 == 211)
      {
      //AddStmtKind
      _exit(2);
      }
      #endif
      #ifdef __COMPILE_211
      else if (__choose0 == 212)
      {
      //AddStmtKind
      args = ((void *)0);
      }
      #endif
      #ifdef __COMPILE_212
      else if (__choose0 == 213)
      {
      //AddStmtKind
      atexit(close_stdin);
      }
      #endif
      #ifdef __COMPILE_213
      else if (__choose0 == 214)
      {
      //AddStmtKind
      bytes_in = 0;
      }
      #endif
      #ifdef __COMPILE_214
      else if (__choose0 == 215)
      {
      //AddStmtKind
      bytes_in = ifile_size;
      }
      #endif
      #ifdef __COMPILE_215
      else if (__choose0 == 216)
      {
      //AddStmtKind
      bytes_out = -1L;
      }
      #endif
      #ifdef __COMPILE_216
      else if (__choose0 == 217)
      {
      //AddStmtKind
      bytes_out = 0;
      }
      #endif
      #ifdef __COMPILE_217
      else if (__choose0 == 218)
      {
      //AddStmtKind
      clear_bufs();
      }
      #endif
      #ifdef __COMPILE_218
      else if (__choose0 == 219)
      {
      //AddStmtKind
      close(fd);
      }
      #endif
      #ifdef __COMPILE_219
      else if (__choose0 == 220)
      {
      //AddStmtKind
      close(ifd);
      }
      #endif
      #ifdef __COMPILE_220
      else if (__choose0 == 221)
      {
      //AddStmtKind
      copy_stat(&istat);
      }
      #endif
      #ifdef __COMPILE_221
      else if (__choose0 == 222)
      {
      //AddStmtKind
      do_exit(0);
      }
      #endif
      #ifdef __COMPILE_222
      else if (__choose0 == 223)
      {
      //AddStmtKind
      do_exit(1);
      }
      #endif
      #ifdef __COMPILE_223
      else if (__choose0 == 224)
      {
      //AddStmtKind
      do_exit(exit_code);
      }
      #endif
      #ifdef __COMPILE_224
      else if (__choose0 == 225)
      {
      //AddStmtKind
      do_list(-1, -1);
      }
      #endif
      #ifdef __COMPILE_225
      else if (__choose0 == 226)
      {
      //AddStmtKind
      do_list(ifd, method);
      }
      #endif
      #ifdef __COMPILE_226
      else if (__choose0 == 227)
      {
      //AddStmtKind
      env = ((void *)0);
      }
      #endif
      #ifdef __COMPILE_227
      else if (__choose0 == 228)
      {
      //AddStmtKind
      env = add_envopt(&argc, &argv, "GZIP");
      }
      #endif
      #ifdef __COMPILE_228
      else if (__choose0 == 229)
      {
      //AddStmtKind
      exit_code = 1;
      }
      #endif
      #ifdef __COMPILE_229
      else if (__choose0 == 230)
      {
      //AddStmtKind
      exit_code = 2;
      }
      #endif
      #ifdef __COMPILE_230
      else if (__choose0 == 231)
      {
      //AddStmtKind
      exiting_signal = quiet ? 13 : 0;
      }
      #endif
      #ifdef __COMPILE_231
      else if (__choose0 == 232)
      {
      //AddStmtKind
      fd = remove_ofname_fd;
      }
      #endif
      #ifdef __COMPILE_232
      else if (__choose0 == 233)
      {
      //AddStmtKind
      foreground = 1;
      }
      #endif
      #ifdef __COMPILE_233
      else if (__choose0 == 234)
      {
      //AddStmtKind
      free(args);
      }
      #endif
      #ifdef __COMPILE_234
      else if (__choose0 == 235)
      {
      //AddStmtKind
      free(env);
      }
      #endif
      #ifdef __COMPILE_235
      else if (__choose0 == 236)
      {
      //AddStmtKind
      gzip_error("can't recover suffix\n");
      }
      #endif
      #ifdef __COMPILE_236
      else if (__choose0 == 237)
      {
      //AddStmtKind
      gzip_error("corrupted input -- file name too large");
      }
      #endif
      #ifdef __COMPILE_237
      else if (__choose0 == 238)
      {
      //AddStmtKind
      gzip_error("internal error in shorten_name");
      }
      #endif
      #ifdef __COMPILE_238
      else if (__choose0 == 239)
      {
      //AddStmtKind
      gzip_error("name too short");
      }
      #endif
      #ifdef __COMPILE_239
      else if (__choose0 == 240)
      {
      //AddStmtKind
      header_bytes = 0;
      }
      #endif
      #ifdef __COMPILE_240
      else if (__choose0 == 241)
      {
      //AddStmtKind
      header_bytes = inptr + 2 * sizeof(long);
      }
      #endif
      #ifdef __COMPILE_241
      else if (__choose0 == 242)
      {
      //AddStmtKind
      ifile_size = ((((istat.st_mode)) & 61440) == (32768)) ? istat.st_size : -1;
      }
      #endif
      #ifdef __COMPILE_242
      else if (__choose0 == 243)
      {
      //AddStmtKind
      inptr = 0;
      }
      #endif
      #ifdef __COMPILE_243
      else if (__choose0 == 244)
      {
      //AddStmtKind
      install_signal_handlers();
      }
      #endif
      #ifdef __COMPILE_244
      else if (__choose0 == 245)
      {
      //AddStmtKind
      last_member = 0;
      }
      #endif
      #ifdef __COMPILE_245
      else if (__choose0 == 246)
      {
      //AddStmtKind
      last_member = 1;
      }
      #endif
      #ifdef __COMPILE_246
      else if (__choose0 == 247)
      {
      //AddStmtKind
      license();
      }
      #endif
      #ifdef __COMPILE_247
      else if (__choose0 == 248)
      {
      //AddStmtKind
      list = 0;
      }
      #endif
      #ifdef __COMPILE_248
      else if (__choose0 == 249)
      {
      //AddStmtKind
      method = (int)(inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      }
      #endif
      #ifdef __COMPILE_249
      else if (__choose0 == 250)
      {
      //AddStmtKind
      method = -1;
      }
      #endif
      #ifdef __COMPILE_250
      else if (__choose0 == 251)
      {
      //AddStmtKind
      method = 0;
      }
      #endif
      #ifdef __COMPILE_251
      else if (__choose0 == 252)
      {
      //AddStmtKind
      method = 1;
      }
      #endif
      #ifdef __COMPILE_252
      else if (__choose0 == 253)
      {
      //AddStmtKind
      method = 2;
      }
      #endif
      #ifdef __COMPILE_253
      else if (__choose0 == 254)
      {
      //AddStmtKind
      method = 3;
      }
      #endif
      #ifdef __COMPILE_254
      else if (__choose0 == 255)
      {
      //AddStmtKind
      method = get_method(ifd);
      }
      #endif
      #ifdef __COMPILE_255
      else if (__choose0 == 256)
      {
      //AddStmtKind
      no_name = decompress;
      }
      #endif
      #ifdef __COMPILE_256
      else if (__choose0 == 257)
      {
      //AddStmtKind
      no_time = decompress;
      }
      #endif
      #ifdef __COMPILE_257
      else if (__choose0 == 258)
      {
      //AddStmtKind
      part_nb = 0;
      }
      #endif
      #ifdef __COMPILE_258
      else if (__choose0 == 259)
      {
      //AddStmtKind
      part_nb++;
      }
      #endif
      #ifdef __COMPILE_259
      else if (__choose0 == 260)
      {
      //AddStmtKind
      perror(ifname);
      }
      #endif
      #ifdef __COMPILE_260
      else if (__choose0 == 261)
      {
      //AddStmtKind
      perror(ofname);
      }
      #endif
      #ifdef __COMPILE_261
      else if (__choose0 == 262)
      {
      //AddStmtKind
      progerror("standard input");
      }
      #endif
      #ifdef __COMPILE_262
      else if (__choose0 == 263)
      {
      //AddStmtKind
      progerror(ifname);
      }
      #endif
      #ifdef __COMPILE_263
      else if (__choose0 == 264)
      {
      //AddStmtKind
      progerror(ofname);
      }
      #endif
      #ifdef __COMPILE_264
      else if (__choose0 == 265)
      {
      //AddStmtKind
      quiet = 0;
      }
      #endif
      #ifdef __COMPILE_265
      else if (__choose0 == 266)
      {
      //AddStmtKind
      read_error();
      }
      #endif
      #ifdef __COMPILE_266
      else if (__choose0 == 267)
      {
      //AddStmtKind
      remove_ofname_fd = -1;
      }
      #endif
      #ifdef __COMPILE_267
      else if (__choose0 == 268)
      {
      //AddStmtKind
      remove_output_file();
      }
      #endif
      #ifdef __COMPILE_268
      else if (__choose0 == 269)
      {
      //AddStmtKind
      save_orig_name = !no_name;
      }
      #endif
      #ifdef __COMPILE_269
      else if (__choose0 == 270)
      {
      //AddStmtKind
      save_orig_name = 0;
      }
      #endif
      #ifdef __COMPILE_270
      else if (__choose0 == 271)
      {
      //AddStmtKind
      save_orig_name = 1;
      }
      #endif
      #ifdef __COMPILE_271
      else if (__choose0 == 272)
      {
      //AddStmtKind
      sigemptyset(&caught_signals);
      }
      #endif
      #ifdef __COMPILE_272
      else if (__choose0 == 273)
      {
      //AddStmtKind
      sigprocmask(0, &caught_signals, &oldset);
      }
      #endif
      #ifdef __COMPILE_273
      else if (__choose0 == 274)
      {
      //AddStmtKind
      sigprocmask(2, &oldset, ((void *)0));
      }
      #endif
      #ifdef __COMPILE_274
      else if (__choose0 == 275)
      {
      //AddStmtKind
      strcat(ifname, z_suffix);
      }
      #endif
      #ifdef __COMPILE_275
      else if (__choose0 == 276)
      {
      //AddStmtKind
      strcat(ofname, z_suffix);
      }
      #endif
      #ifdef __COMPILE_276
      else if (__choose0 == 277)
      {
      //AddStmtKind
      strcpy(ifname, "stdin");
      }
      #endif
      #ifdef __COMPILE_277
      else if (__choose0 == 278)
      {
      //AddStmtKind
      strcpy(ofname, "stdout");
      }
      #endif
      #ifdef __COMPILE_278
      else if (__choose0 == 279)
      {
      //AddStmtKind
      strcpy(ofname, ifname);
      }
      #endif
      #ifdef __COMPILE_279
      else if (__choose0 == 280)
      {
      //AddStmtKind
      time_stamp = get_stat_mtime(&istat);
      }
      #endif
      #ifdef __COMPILE_280
      else if (__choose0 == 281)
      {
      //AddStmtKind
      time_stamp.tv_nsec = -1;
      }
      #endif
      #ifdef __COMPILE_281
      else if (__choose0 == 282)
      {
      //AddStmtKind
      time_stamp.tv_nsec = 0;
      }
      #endif
      #ifdef __COMPILE_282
      else if (__choose0 == 283)
      {
      //AddStmtKind
      to_stdout = 1;
      }
      #endif
      #ifdef __COMPILE_283
      else if (__choose0 == 284)
      {
      //AddStmtKind
      total_in = -1L;
      }
      #endif
      #ifdef __COMPILE_284
      else if (__choose0 == 285)
      {
      //AddStmtKind
      total_out = -1L;
      }
      #endif
      #ifdef __COMPILE_285
      else if (__choose0 == 286)
      {
      //AddStmtKind
      treat_stdin();
      }
      #endif
      #ifdef __COMPILE_286
      else if (__choose0 == 287)
      {
      //AddStmtKind
      try_help();
      }
      #endif
      #ifdef __COMPILE_287
      else if (__choose0 == 288)
      {
      //AddStmtKind
      verbose = 0;
      }
      #endif
      #ifdef __COMPILE_288
      else if (__choose0 == 289)
      {
      //AddStmtKind
      work = copy;
      }
      #endif
      #ifdef __COMPILE_289
      else if (__choose0 == 290)
      {
      //AddStmtKind
      work = lzw;
      }
      #endif
      #ifdef __COMPILE_290
      else if (__choose0 == 291)
      {
      //AddStmtKind
      work = unlzh;
      }
      #endif
      #ifdef __COMPILE_291
      else if (__choose0 == 292)
      {
      //AddStmtKind
      work = unlzw;
      }
      #endif
      #ifdef __COMPILE_292
      else if (__choose0 == 293)
      {
      //AddStmtKind
      work = unpack;
      }
      #endif
      #ifdef __COMPILE_293
      else if (__choose0 == 294)
      {
      //AddStmtKind
      work = unzip;
      }
      #endif
      #ifdef __COMPILE_294
      else if (__choose0 == 295)
      {
      //AddStmtKind
      write_error();
      }
      #endif
      #ifdef __COMPILE_295
      else if (__choose0 == 296)
      {
      //AddStmtKind
      xunlink(ofname);
      }
      #endif
      #ifdef __COMPILE_296
      else if (__choose0 == 297)
      {
      //AddStmtKind
      z_len = strlen(z_suffix);
      }
      #endif
      #ifdef __COMPILE_297
      else if (__choose0 == 298)
      {
      //AddStmtKind
      z_suffix = ".gz";
      }
      #endif
      #ifdef __COMPILE_298
      else if (__choose0 == 299)
      {
      //IfExitKind
      if (__is_neg("0-299", "L1863", 2, &(fd), sizeof (fd), &(remove_ofname_fd),
      			 sizeof (remove_ofname_fd)))
          return;
      }
      #endif
      int __choose1 = __choose("__SWITCH1");
      if (__choose1 == 0)
      {
      xunlink (ofname);
      
      }
      #ifdef __COMPILE_299
      else if (__choose1 == 1)
      {
      //GuardKind
      if (!__is_neg("1-1", "L1863", 2, &(fd), sizeof (fd), &(remove_ofname_fd), sizeof (remove_ofname_fd)))
          xunlink(ofname);
      
      }
      #endif
      #ifdef __COMPILE_300
      else if (__choose1 == 2)
      {
      //MSVExtFunctionReplaceKind
      __stpcpy(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_301
      else if (__choose1 == 3)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_302
      else if (__choose1 == 4)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_303
      else if (__choose1 == 5)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_304
      else if (__choose1 == 6)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_305
      else if (__choose1 == 7)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, ascii);
      
      }
      #endif
      #ifdef __COMPILE_306
      else if (__choose1 == 8)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, block_mode);
      
      }
      #endif
      #ifdef __COMPILE_307
      else if (__choose1 == 9)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, decompress);
      
      }
      #endif
      #ifdef __COMPILE_308
      else if (__choose1 == 10)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, decrypt);
      
      }
      #endif
      #ifdef __COMPILE_309
      else if (__choose1 == 11)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, do_lzw);
      
      }
      #endif
      #ifdef __COMPILE_310
      else if (__choose1 == 12)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, exit_code);
      
      }
      #endif
      #ifdef __COMPILE_311
      else if (__choose1 == 13)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, exiting_signal);
      
      }
      #endif
      #ifdef __COMPILE_312
      else if (__choose1 == 14)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, fd);
      
      }
      #endif
      #ifdef __COMPILE_313
      else if (__choose1 == 15)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, force);
      
      }
      #endif
      #ifdef __COMPILE_314
      else if (__choose1 == 16)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, foreground);
      
      }
      #endif
      #ifdef __COMPILE_315
      else if (__choose1 == 17)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, ifd);
      
      }
      #endif
      #ifdef __COMPILE_316
      else if (__choose1 == 18)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, last_member);
      
      }
      #endif
      #ifdef __COMPILE_317
      else if (__choose1 == 19)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, level);
      
      }
      #endif
      #ifdef __COMPILE_318
      else if (__choose1 == 20)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, list);
      
      }
      #endif
      #ifdef __COMPILE_319
      else if (__choose1 == 21)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, maxbits);
      
      }
      #endif
      #ifdef __COMPILE_320
      else if (__choose1 == 22)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, method);
      
      }
      #endif
      #ifdef __COMPILE_321
      else if (__choose1 == 23)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, no_name);
      
      }
      #endif
      #ifdef __COMPILE_322
      else if (__choose1 == 24)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, no_time);
      
      }
      #endif
      #ifdef __COMPILE_323
      else if (__choose1 == 25)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, ofd);
      
      }
      #endif
      #ifdef __COMPILE_324
      else if (__choose1 == 26)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, part_nb);
      
      }
      #endif
      #ifdef __COMPILE_325
      else if (__choose1 == 27)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, quiet);
      
      }
      #endif
      #ifdef __COMPILE_326
      else if (__choose1 == 28)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, recursive);
      
      }
      #endif
      #ifdef __COMPILE_327
      else if (__choose1 == 29)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, remove_ofname_fd);
      
      }
      #endif
      #ifdef __COMPILE_328
      else if (__choose1 == 30)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, save_orig_name);
      
      }
      #endif
      #ifdef __COMPILE_329
      else if (__choose1 == 31)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, test);
      
      }
      #endif
      #ifdef __COMPILE_330
      else if (__choose1 == 32)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, to_stdout);
      
      }
      #endif
      #ifdef __COMPILE_331
      else if (__choose1 == 33)
      {
      //MSVExtFunctionReplaceKind
      encrypt(ofname, verbose);
      
      }
      #endif
      #ifdef __COMPILE_332
      else if (__choose1 == 34)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_333
      else if (__choose1 == 35)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_334
      else if (__choose1 == 36)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_335
      else if (__choose1 == 37)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_336
      else if (__choose1 == 38)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, inptr);
      
      }
      #endif
      #ifdef __COMPILE_337
      else if (__choose1 == 39)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, insize);
      
      }
      #endif
      #ifdef __COMPILE_338
      else if (__choose1 == 40)
      {
      //MSVExtFunctionReplaceKind
      file_read(ofname, outcnt);
      
      }
      #endif
      #ifdef __COMPILE_339
      else if (__choose1 == 41)
      {
      //MSVExtFunctionReplaceKind
      getcwd(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_340
      else if (__choose1 == 42)
      {
      //MSVExtFunctionReplaceKind
      getcwd(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_341
      else if (__choose1 == 43)
      {
      //MSVExtFunctionReplaceKind
      getcwd(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_342
      else if (__choose1 == 44)
      {
      //MSVExtFunctionReplaceKind
      getcwd(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_343
      else if (__choose1 == 45)
      {
      //MSVExtFunctionReplaceKind
      getcwd(ofname, z_len);
      
      }
      #endif
      #ifdef __COMPILE_344
      else if (__choose1 == 46)
      {
      //MSVExtFunctionReplaceKind
      getdomainname(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_345
      else if (__choose1 == 47)
      {
      //MSVExtFunctionReplaceKind
      getdomainname(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_346
      else if (__choose1 == 48)
      {
      //MSVExtFunctionReplaceKind
      getdomainname(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_347
      else if (__choose1 == 49)
      {
      //MSVExtFunctionReplaceKind
      getdomainname(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_348
      else if (__choose1 == 50)
      {
      //MSVExtFunctionReplaceKind
      getdomainname(ofname, z_len);
      
      }
      #endif
      #ifdef __COMPILE_349
      else if (__choose1 == 51)
      {
      //MSVExtFunctionReplaceKind
      gethostname(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_350
      else if (__choose1 == 52)
      {
      //MSVExtFunctionReplaceKind
      gethostname(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_351
      else if (__choose1 == 53)
      {
      //MSVExtFunctionReplaceKind
      gethostname(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_352
      else if (__choose1 == 54)
      {
      //MSVExtFunctionReplaceKind
      gethostname(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_353
      else if (__choose1 == 55)
      {
      //MSVExtFunctionReplaceKind
      gethostname(ofname, z_len);
      
      }
      #endif
      #ifdef __COMPILE_354
      else if (__choose1 == 56)
      {
      //MSVExtFunctionReplaceKind
      getlogin_r(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_355
      else if (__choose1 == 57)
      {
      //MSVExtFunctionReplaceKind
      getlogin_r(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_356
      else if (__choose1 == 58)
      {
      //MSVExtFunctionReplaceKind
      getlogin_r(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_357
      else if (__choose1 == 59)
      {
      //MSVExtFunctionReplaceKind
      getlogin_r(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_358
      else if (__choose1 == 60)
      {
      //MSVExtFunctionReplaceKind
      getlogin_r(ofname, z_len);
      
      }
      #endif
      #ifdef __COMPILE_359
      else if (__choose1 == 61)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_360
      else if (__choose1 == 62)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_361
      else if (__choose1 == 63)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_362
      else if (__choose1 == 64)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_363
      else if (__choose1 == 65)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, ascii);
      
      }
      #endif
      #ifdef __COMPILE_364
      else if (__choose1 == 66)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, block_mode);
      
      }
      #endif
      #ifdef __COMPILE_365
      else if (__choose1 == 67)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, decompress);
      
      }
      #endif
      #ifdef __COMPILE_366
      else if (__choose1 == 68)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, decrypt);
      
      }
      #endif
      #ifdef __COMPILE_367
      else if (__choose1 == 69)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, do_lzw);
      
      }
      #endif
      #ifdef __COMPILE_368
      else if (__choose1 == 70)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, exit_code);
      
      }
      #endif
      #ifdef __COMPILE_369
      else if (__choose1 == 71)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, exiting_signal);
      
      }
      #endif
      #ifdef __COMPILE_370
      else if (__choose1 == 72)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, fd);
      
      }
      #endif
      #ifdef __COMPILE_371
      else if (__choose1 == 73)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, force);
      
      }
      #endif
      #ifdef __COMPILE_372
      else if (__choose1 == 74)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, foreground);
      
      }
      #endif
      #ifdef __COMPILE_373
      else if (__choose1 == 75)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, ifd);
      
      }
      #endif
      #ifdef __COMPILE_374
      else if (__choose1 == 76)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, last_member);
      
      }
      #endif
      #ifdef __COMPILE_375
      else if (__choose1 == 77)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, level);
      
      }
      #endif
      #ifdef __COMPILE_376
      else if (__choose1 == 78)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, list);
      
      }
      #endif
      #ifdef __COMPILE_377
      else if (__choose1 == 79)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, maxbits);
      
      }
      #endif
      #ifdef __COMPILE_378
      else if (__choose1 == 80)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, method);
      
      }
      #endif
      #ifdef __COMPILE_379
      else if (__choose1 == 81)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, no_name);
      
      }
      #endif
      #ifdef __COMPILE_380
      else if (__choose1 == 82)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, no_time);
      
      }
      #endif
      #ifdef __COMPILE_381
      else if (__choose1 == 83)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, ofd);
      
      }
      #endif
      #ifdef __COMPILE_382
      else if (__choose1 == 84)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, part_nb);
      
      }
      #endif
      #ifdef __COMPILE_383
      else if (__choose1 == 85)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, quiet);
      
      }
      #endif
      #ifdef __COMPILE_384
      else if (__choose1 == 86)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, recursive);
      
      }
      #endif
      #ifdef __COMPILE_385
      else if (__choose1 == 87)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, remove_ofname_fd);
      
      }
      #endif
      #ifdef __COMPILE_386
      else if (__choose1 == 88)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, save_orig_name);
      
      }
      #endif
      #ifdef __COMPILE_387
      else if (__choose1 == 89)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, test);
      
      }
      #endif
      #ifdef __COMPILE_388
      else if (__choose1 == 90)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, to_stdout);
      
      }
      #endif
      #ifdef __COMPILE_389
      else if (__choose1 == 91)
      {
      //MSVExtFunctionReplaceKind
      mkostemp(ofname, verbose);
      
      }
      #endif
      #ifdef __COMPILE_390
      else if (__choose1 == 92)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_391
      else if (__choose1 == 93)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_392
      else if (__choose1 == 94)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_393
      else if (__choose1 == 95)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_394
      else if (__choose1 == 96)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, ascii);
      
      }
      #endif
      #ifdef __COMPILE_395
      else if (__choose1 == 97)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, block_mode);
      
      }
      #endif
      #ifdef __COMPILE_396
      else if (__choose1 == 98)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, decompress);
      
      }
      #endif
      #ifdef __COMPILE_397
      else if (__choose1 == 99)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, decrypt);
      
      }
      #endif
      #ifdef __COMPILE_398
      else if (__choose1 == 100)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, do_lzw);
      
      }
      #endif
      #ifdef __COMPILE_399
      else if (__choose1 == 101)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, exit_code);
      
      }
      #endif
      #ifdef __COMPILE_400
      else if (__choose1 == 102)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, exiting_signal);
      
      }
      #endif
      #ifdef __COMPILE_401
      else if (__choose1 == 103)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, fd);
      
      }
      #endif
      #ifdef __COMPILE_402
      else if (__choose1 == 104)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, force);
      
      }
      #endif
      #ifdef __COMPILE_403
      else if (__choose1 == 105)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, foreground);
      
      }
      #endif
      #ifdef __COMPILE_404
      else if (__choose1 == 106)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, ifd);
      
      }
      #endif
      #ifdef __COMPILE_405
      else if (__choose1 == 107)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, last_member);
      
      }
      #endif
      #ifdef __COMPILE_406
      else if (__choose1 == 108)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, level);
      
      }
      #endif
      #ifdef __COMPILE_407
      else if (__choose1 == 109)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, list);
      
      }
      #endif
      #ifdef __COMPILE_408
      else if (__choose1 == 110)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, maxbits);
      
      }
      #endif
      #ifdef __COMPILE_409
      else if (__choose1 == 111)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, method);
      
      }
      #endif
      #ifdef __COMPILE_410
      else if (__choose1 == 112)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, no_name);
      
      }
      #endif
      #ifdef __COMPILE_411
      else if (__choose1 == 113)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, no_time);
      
      }
      #endif
      #ifdef __COMPILE_412
      else if (__choose1 == 114)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, ofd);
      
      }
      #endif
      #ifdef __COMPILE_413
      else if (__choose1 == 115)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, part_nb);
      
      }
      #endif
      #ifdef __COMPILE_414
      else if (__choose1 == 116)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, quiet);
      
      }
      #endif
      #ifdef __COMPILE_415
      else if (__choose1 == 117)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, recursive);
      
      }
      #endif
      #ifdef __COMPILE_416
      else if (__choose1 == 118)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, remove_ofname_fd);
      
      }
      #endif
      #ifdef __COMPILE_417
      else if (__choose1 == 119)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, save_orig_name);
      
      }
      #endif
      #ifdef __COMPILE_418
      else if (__choose1 == 120)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, test);
      
      }
      #endif
      #ifdef __COMPILE_419
      else if (__choose1 == 121)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, to_stdout);
      
      }
      #endif
      #ifdef __COMPILE_420
      else if (__choose1 == 122)
      {
      //MSVExtFunctionReplaceKind
      mkostemp64(ofname, verbose);
      
      }
      #endif
      #ifdef __COMPILE_421
      else if (__choose1 == 123)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_422
      else if (__choose1 == 124)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_423
      else if (__choose1 == 125)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_424
      else if (__choose1 == 126)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_425
      else if (__choose1 == 127)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, ascii);
      
      }
      #endif
      #ifdef __COMPILE_426
      else if (__choose1 == 128)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, block_mode);
      
      }
      #endif
      #ifdef __COMPILE_427
      else if (__choose1 == 129)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, decompress);
      
      }
      #endif
      #ifdef __COMPILE_428
      else if (__choose1 == 130)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, decrypt);
      
      }
      #endif
      #ifdef __COMPILE_429
      else if (__choose1 == 131)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, do_lzw);
      
      }
      #endif
      #ifdef __COMPILE_430
      else if (__choose1 == 132)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, exit_code);
      
      }
      #endif
      #ifdef __COMPILE_431
      else if (__choose1 == 133)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, exiting_signal);
      
      }
      #endif
      #ifdef __COMPILE_432
      else if (__choose1 == 134)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, fd);
      
      }
      #endif
      #ifdef __COMPILE_433
      else if (__choose1 == 135)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, force);
      
      }
      #endif
      #ifdef __COMPILE_434
      else if (__choose1 == 136)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, foreground);
      
      }
      #endif
      #ifdef __COMPILE_435
      else if (__choose1 == 137)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, ifd);
      
      }
      #endif
      #ifdef __COMPILE_436
      else if (__choose1 == 138)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, last_member);
      
      }
      #endif
      #ifdef __COMPILE_437
      else if (__choose1 == 139)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, level);
      
      }
      #endif
      #ifdef __COMPILE_438
      else if (__choose1 == 140)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, list);
      
      }
      #endif
      #ifdef __COMPILE_439
      else if (__choose1 == 141)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, maxbits);
      
      }
      #endif
      #ifdef __COMPILE_440
      else if (__choose1 == 142)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, method);
      
      }
      #endif
      #ifdef __COMPILE_441
      else if (__choose1 == 143)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, no_name);
      
      }
      #endif
      #ifdef __COMPILE_442
      else if (__choose1 == 144)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, no_time);
      
      }
      #endif
      #ifdef __COMPILE_443
      else if (__choose1 == 145)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, ofd);
      
      }
      #endif
      #ifdef __COMPILE_444
      else if (__choose1 == 146)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, part_nb);
      
      }
      #endif
      #ifdef __COMPILE_445
      else if (__choose1 == 147)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, quiet);
      
      }
      #endif
      #ifdef __COMPILE_446
      else if (__choose1 == 148)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, recursive);
      
      }
      #endif
      #ifdef __COMPILE_447
      else if (__choose1 == 149)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, remove_ofname_fd);
      
      }
      #endif
      #ifdef __COMPILE_448
      else if (__choose1 == 150)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, save_orig_name);
      
      }
      #endif
      #ifdef __COMPILE_449
      else if (__choose1 == 151)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, test);
      
      }
      #endif
      #ifdef __COMPILE_450
      else if (__choose1 == 152)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, to_stdout);
      
      }
      #endif
      #ifdef __COMPILE_451
      else if (__choose1 == 153)
      {
      //MSVExtFunctionReplaceKind
      mkstemps(ofname, verbose);
      
      }
      #endif
      #ifdef __COMPILE_452
      else if (__choose1 == 154)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_453
      else if (__choose1 == 155)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_454
      else if (__choose1 == 156)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_455
      else if (__choose1 == 157)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_456
      else if (__choose1 == 158)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, ascii);
      
      }
      #endif
      #ifdef __COMPILE_457
      else if (__choose1 == 159)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, block_mode);
      
      }
      #endif
      #ifdef __COMPILE_458
      else if (__choose1 == 160)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, decompress);
      
      }
      #endif
      #ifdef __COMPILE_459
      else if (__choose1 == 161)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, decrypt);
      
      }
      #endif
      #ifdef __COMPILE_460
      else if (__choose1 == 162)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, do_lzw);
      
      }
      #endif
      #ifdef __COMPILE_461
      else if (__choose1 == 163)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, exit_code);
      
      }
      #endif
      #ifdef __COMPILE_462
      else if (__choose1 == 164)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, exiting_signal);
      
      }
      #endif
      #ifdef __COMPILE_463
      else if (__choose1 == 165)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, fd);
      
      }
      #endif
      #ifdef __COMPILE_464
      else if (__choose1 == 166)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, force);
      
      }
      #endif
      #ifdef __COMPILE_465
      else if (__choose1 == 167)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, foreground);
      
      }
      #endif
      #ifdef __COMPILE_466
      else if (__choose1 == 168)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, ifd);
      
      }
      #endif
      #ifdef __COMPILE_467
      else if (__choose1 == 169)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, last_member);
      
      }
      #endif
      #ifdef __COMPILE_468
      else if (__choose1 == 170)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, level);
      
      }
      #endif
      #ifdef __COMPILE_469
      else if (__choose1 == 171)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, list);
      
      }
      #endif
      #ifdef __COMPILE_470
      else if (__choose1 == 172)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, maxbits);
      
      }
      #endif
      #ifdef __COMPILE_471
      else if (__choose1 == 173)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, method);
      
      }
      #endif
      #ifdef __COMPILE_472
      else if (__choose1 == 174)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, no_name);
      
      }
      #endif
      #ifdef __COMPILE_473
      else if (__choose1 == 175)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, no_time);
      
      }
      #endif
      #ifdef __COMPILE_474
      else if (__choose1 == 176)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, ofd);
      
      }
      #endif
      #ifdef __COMPILE_475
      else if (__choose1 == 177)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, part_nb);
      
      }
      #endif
      #ifdef __COMPILE_476
      else if (__choose1 == 178)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, quiet);
      
      }
      #endif
      #ifdef __COMPILE_477
      else if (__choose1 == 179)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, recursive);
      
      }
      #endif
      #ifdef __COMPILE_478
      else if (__choose1 == 180)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, remove_ofname_fd);
      
      }
      #endif
      #ifdef __COMPILE_479
      else if (__choose1 == 181)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, save_orig_name);
      
      }
      #endif
      #ifdef __COMPILE_480
      else if (__choose1 == 182)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, test);
      
      }
      #endif
      #ifdef __COMPILE_481
      else if (__choose1 == 183)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, to_stdout);
      
      }
      #endif
      #ifdef __COMPILE_482
      else if (__choose1 == 184)
      {
      //MSVExtFunctionReplaceKind
      mkstemps64(ofname, verbose);
      
      }
      #endif
      #ifdef __COMPILE_483
      else if (__choose1 == 185)
      {
      //MSVExtFunctionReplaceKind
      open_input_file(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_484
      else if (__choose1 == 186)
      {
      //MSVExtFunctionReplaceKind
      setstate_r(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_485
      else if (__choose1 == 187)
      {
      //MSVExtFunctionReplaceKind
      stpcpy(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_486
      else if (__choose1 == 188)
      {
      //MSVExtFunctionReplaceKind
      strcat(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_487
      else if (__choose1 == 189)
      {
      //MSVExtFunctionReplaceKind
      strcpy(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_488
      else if (__choose1 == 190)
      {
      //MSVExtFunctionReplaceKind
      strtok(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_489
      else if (__choose1 == 191)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, -1);
      
      }
      #endif
      #ifdef __COMPILE_490
      else if (__choose1 == 192)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, 0);
      
      }
      #endif
      #ifdef __COMPILE_491
      else if (__choose1 == 193)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, 1);
      
      }
      #endif
      #ifdef __COMPILE_492
      else if (__choose1 == 194)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, 2);
      
      }
      #endif
      #ifdef __COMPILE_493
      else if (__choose1 == 195)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, ascii);
      
      }
      #endif
      #ifdef __COMPILE_494
      else if (__choose1 == 196)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, block_mode);
      
      }
      #endif
      #ifdef __COMPILE_495
      else if (__choose1 == 197)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, decompress);
      
      }
      #endif
      #ifdef __COMPILE_496
      else if (__choose1 == 198)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, decrypt);
      
      }
      #endif
      #ifdef __COMPILE_497
      else if (__choose1 == 199)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, do_lzw);
      
      }
      #endif
      #ifdef __COMPILE_498
      else if (__choose1 == 200)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, exit_code);
      
      }
      #endif
      #ifdef __COMPILE_499
      else if (__choose1 == 201)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, exiting_signal);
      
      }
      #endif
      #ifdef __COMPILE_500
      else if (__choose1 == 202)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, fd);
      
      }
      #endif
      #ifdef __COMPILE_501
      else if (__choose1 == 203)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, force);
      
      }
      #endif
      #ifdef __COMPILE_502
      else if (__choose1 == 204)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, foreground);
      
      }
      #endif
      #ifdef __COMPILE_503
      else if (__choose1 == 205)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, ifd);
      
      }
      #endif
      #ifdef __COMPILE_504
      else if (__choose1 == 206)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, last_member);
      
      }
      #endif
      #ifdef __COMPILE_505
      else if (__choose1 == 207)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, level);
      
      }
      #endif
      #ifdef __COMPILE_506
      else if (__choose1 == 208)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, list);
      
      }
      #endif
      #ifdef __COMPILE_507
      else if (__choose1 == 209)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, maxbits);
      
      }
      #endif
      #ifdef __COMPILE_508
      else if (__choose1 == 210)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, method);
      
      }
      #endif
      #ifdef __COMPILE_509
      else if (__choose1 == 211)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, no_name);
      
      }
      #endif
      #ifdef __COMPILE_510
      else if (__choose1 == 212)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, no_time);
      
      }
      #endif
      #ifdef __COMPILE_511
      else if (__choose1 == 213)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, ofd);
      
      }
      #endif
      #ifdef __COMPILE_512
      else if (__choose1 == 214)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, part_nb);
      
      }
      #endif
      #ifdef __COMPILE_513
      else if (__choose1 == 215)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, quiet);
      
      }
      #endif
      #ifdef __COMPILE_514
      else if (__choose1 == 216)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, recursive);
      
      }
      #endif
      #ifdef __COMPILE_515
      else if (__choose1 == 217)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, remove_ofname_fd);
      
      }
      #endif
      #ifdef __COMPILE_516
      else if (__choose1 == 218)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, save_orig_name);
      
      }
      #endif
      #ifdef __COMPILE_517
      else if (__choose1 == 219)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, test);
      
      }
      #endif
      #ifdef __COMPILE_518
      else if (__choose1 == 220)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, to_stdout);
      
      }
      #endif
      #ifdef __COMPILE_519
      else if (__choose1 == 221)
      {
      //MSVExtFunctionReplaceKind
      wctomb(ofname, verbose);
      
      }
      #endif
      #ifdef __COMPILE_520
      else if (__choose1 == 222)
      {
      //MSVExtRemoveStmtKind
      {
      }
      
      }
      #endif
      #ifdef __COMPILE_521
      else if (__choose1 == 223)
      {
      //ReplaceFunctionKind
      ctermid(ofname);
      
      }
      #endif
      #ifdef __COMPILE_522
      else if (__choose1 == 224)
      {
      //ReplaceFunctionKind
      cuserid(ofname);
      
      }
      #endif
      #ifdef __COMPILE_523
      else if (__choose1 == 225)
      {
      //ReplaceFunctionKind
      get_suffix(ofname);
      
      }
      #endif
      #ifdef __COMPILE_524
      else if (__choose1 == 226)
      {
      //ReplaceFunctionKind
      getwd(ofname);
      
      }
      #endif
      #ifdef __COMPILE_525
      else if (__choose1 == 227)
      {
      //ReplaceFunctionKind
      gzip_base_name(ofname);
      
      }
      #endif
      #ifdef __COMPILE_526
      else if (__choose1 == 228)
      {
      //ReplaceFunctionKind
      gzip_error(ofname);
      
      }
      #endif
      #ifdef __COMPILE_527
      else if (__choose1 == 229)
      {
      //ReplaceFunctionKind
      make_simple_name(ofname);
      
      }
      #endif
      #ifdef __COMPILE_528
      else if (__choose1 == 230)
      {
      //ReplaceFunctionKind
      mkdtemp(ofname);
      
      }
      #endif
      #ifdef __COMPILE_529
      else if (__choose1 == 231)
      {
      //ReplaceFunctionKind
      mkstemp(ofname);
      
      }
      #endif
      #ifdef __COMPILE_530
      else if (__choose1 == 232)
      {
      //ReplaceFunctionKind
      mkstemp64(ofname);
      
      }
      #endif
      #ifdef __COMPILE_531
      else if (__choose1 == 233)
      {
      //ReplaceFunctionKind
      mktemp(ofname);
      
      }
      #endif
      #ifdef __COMPILE_532
      else if (__choose1 == 234)
      {
      //ReplaceFunctionKind
      progerror(ofname);
      
      }
      #endif
      #ifdef __COMPILE_533
      else if (__choose1 == 235)
      {
      //ReplaceFunctionKind
      putenv(ofname);
      
      }
      #endif
      #ifdef __COMPILE_534
      else if (__choose1 == 236)
      {
      //ReplaceFunctionKind
      setstate(ofname);
      
      }
      #endif
      #ifdef __COMPILE_535
      else if (__choose1 == 237)
      {
      //ReplaceFunctionKind
      shorten_name(ofname);
      
      }
      #endif
      #ifdef __COMPILE_536
      else if (__choose1 == 238)
      {
      //ReplaceFunctionKind
      strfry(ofname);
      
      }
      #endif
      #ifdef __COMPILE_537
      else if (__choose1 == 239)
      {
      //ReplaceFunctionKind
      strlwr(ofname);
      
      }
      #endif
      #ifdef __COMPILE_538
      else if (__choose1 == 240)
      {
      //ReplaceFunctionKind
      tmpnam(ofname);
      
      }
      #endif
      #ifdef __COMPILE_539
      else if (__choose1 == 241)
      {
      //ReplaceFunctionKind
      tmpnam_r(ofname);
      
      }
      #endif
      #ifdef __COMPILE_540
      else if (__choose1 == 242)
      {
      //ReplaceFunctionKind
      treat_file(ofname);
      
      }
      #endif
      #ifdef __COMPILE_541
      else if (__choose1 == 243)
      {
      //ReplaceFunctionKind
      warning(ofname);
      
      }
      #endif
      #ifdef __COMPILE_542
      else if (__choose1 == 244)
      {
      //ReplaceKind
      xunlink((&fd));
      
      }
      #endif
      #ifdef __COMPILE_543
      else if (__choose1 == 245)
      {
      //ReplaceKind
      xunlink((&oldset));
      
      }
      #endif
      #ifdef __COMPILE_544
      else if (__choose1 == 246)
      {
      //ReplaceKind
      xunlink(ofname && !(1 << 5));
      
      }
      #endif
      }
    }
  sigprocmask (SIG_SETMASK, &oldset, NULL);
}

/* ========================================================================
 * Error handler.
 */
void
abort_gzip ()
{
   remove_output_file ();
   do_exit(ERROR);
}

/* ========================================================================
 * Signal handler.
 */
static RETSIGTYPE
abort_gzip_signal (sig)
     int sig;
{
  if (! SA_NOCLDSTOP)
    signal (sig, SIG_IGN);
   remove_output_file ();
   if (sig == exiting_signal)
     _exit (WARNING);
   signal (sig, SIG_DFL);
   raise (sig);
}
