#define __COMPILE_0
#define __COMPILE_1
#define __COMPILE_2
#define __COMPILE_3
#define __COMPILE_4
#define __COMPILE_5
#define __COMPILE_6
#define __COMPILE_7
#define __COMPILE_8
#define __COMPILE_9
#define __COMPILE_10
#define __COMPILE_11
#define __COMPILE_12
#define __COMPILE_13
#define __COMPILE_14
#define __COMPILE_15
#define __COMPILE_16
#define __COMPILE_17
#define __COMPILE_18
#define __COMPILE_19
#define __COMPILE_20
#define __COMPILE_21
#define __COMPILE_22
#define __COMPILE_23
#define __COMPILE_24
#define __COMPILE_25
#define __COMPILE_26
#define __COMPILE_27
#define __COMPILE_28
#define __COMPILE_29
#define __COMPILE_30
#define __COMPILE_31
#define __COMPILE_32
#define __COMPILE_33
#define __COMPILE_34
#define __COMPILE_35
#define __COMPILE_36
#define __COMPILE_37
#define __COMPILE_38
#define __COMPILE_39
#define __COMPILE_40
#define __COMPILE_41
#define __COMPILE_42
#define __COMPILE_43
#define __COMPILE_44
#define __COMPILE_45
#define __COMPILE_46
#define __COMPILE_47
#define __COMPILE_48
#define __COMPILE_49
#define __COMPILE_50
#define __COMPILE_51
#define __COMPILE_52
#define __COMPILE_53
#define __COMPILE_54
#define __COMPILE_55
#define __COMPILE_56
#define __COMPILE_57
#define __COMPILE_58
#define __COMPILE_59
#define __COMPILE_60
#define __COMPILE_61
#define __COMPILE_62
#define __COMPILE_63
#define __COMPILE_64
#define __COMPILE_65
#define __COMPILE_66
#define __COMPILE_67
#define __COMPILE_68
#define __COMPILE_69
#define __COMPILE_70
#define __COMPILE_71
#define __COMPILE_72
#define __COMPILE_73
#define __COMPILE_74
#define __COMPILE_75
#define __COMPILE_76
#define __COMPILE_77
#define __COMPILE_78
#define __COMPILE_79
#define __COMPILE_80
#define __COMPILE_81
#define __COMPILE_82
#define __COMPILE_83
#define __COMPILE_84
#define __COMPILE_85
#define __COMPILE_86
#define __COMPILE_87
#define __COMPILE_88
#define __COMPILE_89
#define __COMPILE_90
#define __COMPILE_91
#define __COMPILE_92
#define __COMPILE_93
#define __COMPILE_94
#define __COMPILE_95
#define __COMPILE_96
#define __COMPILE_97
#define __COMPILE_98
#define __COMPILE_99
#define __COMPILE_100
#define __COMPILE_101
#define __COMPILE_102
#define __COMPILE_103
#define __COMPILE_104
#define __COMPILE_105
#define __COMPILE_106
#define __COMPILE_107
#define __COMPILE_108
#define __COMPILE_109
#define __COMPILE_110
#define __COMPILE_111
#define __COMPILE_112
#define __COMPILE_113
#define __COMPILE_114
#define __COMPILE_115
#define __COMPILE_116
#define __COMPILE_117
#define __COMPILE_118
#define __COMPILE_119
#define __COMPILE_120
#define __COMPILE_121
#define __COMPILE_122
#define __COMPILE_123
#define __COMPILE_124
#define __COMPILE_125
#define __COMPILE_126
#define __COMPILE_127
#define __COMPILE_128
#define __COMPILE_129
#define __COMPILE_130
#define __COMPILE_131
#define __COMPILE_132
#define __COMPILE_133
#define __COMPILE_134
#define __COMPILE_135
#define __COMPILE_136
#define __COMPILE_137
#define __COMPILE_138
#define __COMPILE_139
#define __COMPILE_140
#define __COMPILE_141
#define __COMPILE_142
#define __COMPILE_143
#define __COMPILE_144
#define __COMPILE_145
#define __COMPILE_146
#define __COMPILE_147
#define __COMPILE_148
#define __COMPILE_149
#define __COMPILE_150
#define __COMPILE_151
#define __COMPILE_152
#define __COMPILE_153
#define __COMPILE_154
#define __COMPILE_155
#define __COMPILE_156
#define __COMPILE_157
#define __COMPILE_158
#define __COMPILE_159
#define __COMPILE_160
#define __COMPILE_161
#define __COMPILE_162
#define __COMPILE_163
#define __COMPILE_164
#define __COMPILE_165
#define __COMPILE_166
#define __COMPILE_167
#define __COMPILE_168
#define __COMPILE_169
#define __COMPILE_170
#define __COMPILE_171
#define __COMPILE_172
#define __COMPILE_173
#define __COMPILE_174
#define __COMPILE_175
#define __COMPILE_176
#define __COMPILE_177
#define __COMPILE_178
#define __COMPILE_179
#define __COMPILE_180
#define __COMPILE_181
#define __COMPILE_182
#define __COMPILE_183
#define __COMPILE_184
#define __COMPILE_185
#define __COMPILE_186
#define __COMPILE_187
#define __COMPILE_188
#define __COMPILE_189
#define __COMPILE_190
#define __COMPILE_191
#define __COMPILE_192
#define __COMPILE_193
#define __COMPILE_194
#define __COMPILE_195
#define __COMPILE_196
#define __COMPILE_197
#define __COMPILE_198
#define __COMPILE_199
#define __COMPILE_200
#define __COMPILE_201
#define __COMPILE_202
#define __COMPILE_203
#define __COMPILE_204
#define __COMPILE_205
#define __COMPILE_206
#define __COMPILE_207
#define __COMPILE_208
#define __COMPILE_209
#define __COMPILE_210
#define __COMPILE_211
#define __COMPILE_212
#define __COMPILE_213
#define __COMPILE_214
#define __COMPILE_215
#define __COMPILE_216
#define __COMPILE_217
#define __COMPILE_218
#define __COMPILE_219
#define __COMPILE_220
#define __COMPILE_221
#define __COMPILE_222
#define __COMPILE_223
#define __COMPILE_224
#define __COMPILE_225
#define __COMPILE_226
#define __COMPILE_227
#define __COMPILE_228
#define __COMPILE_229
#define __COMPILE_230
#define __COMPILE_231
#define __COMPILE_232
#define __COMPILE_233
#define __COMPILE_234
#define __COMPILE_235
#define __COMPILE_236
#define __COMPILE_237
#define __COMPILE_238
#define __COMPILE_239
#define __COMPILE_240
#define __COMPILE_241
#define __COMPILE_242
#define __COMPILE_243
#define __COMPILE_244
#define __COMPILE_245
#define __COMPILE_246
#define __COMPILE_247
#define __COMPILE_248
#define __COMPILE_249
#define __COMPILE_250
#define __COMPILE_251
#define __COMPILE_252
#define __COMPILE_253
#define __COMPILE_254
#define __COMPILE_255
#define __COMPILE_256
#define __COMPILE_257
#define __COMPILE_258
#define __COMPILE_259
#define __COMPILE_260
#define __COMPILE_261
#define __COMPILE_262
#define __COMPILE_263
#define __COMPILE_264
#define __COMPILE_265
#define __COMPILE_266
#define __COMPILE_267
#define __COMPILE_268
#define __COMPILE_269
#define __COMPILE_270
#define __COMPILE_271
#define __COMPILE_272
#define __COMPILE_273
#define __COMPILE_274
#define __COMPILE_275
#define __COMPILE_276
#define __COMPILE_277
// compile_fin
int __get_mutant(); int __is_neg(const char *location,char *lid,int count, ...); int __abst_hole(); char *__stat_write_init(const char *func_name);void __write_stat(char *str,const char *var_name,void *var_addr,int size); void __stat_file_close(const char *func_name,char *str);long long __mutate(const long long,const char *,const char *); int __trident_choice(char* lid, char* typestr,int* rvals, char** rvals_ids, int rvals_size,int** lvals, char** lvals_ids, int lvals_size);int __trident_output(char* id, char* typestr, int value);float fabs_trident(float a);int __choose(const char *);void *__var_select(unsigned int var_count,void *vars[]);void *__var_select_2(unsigned int var_count,void *vars[]);long long __const_select(unsigned int const_count, ...);void* memset(void*, int, unsigned long); 
/*
    An implementation of Buffered I/O as defined by PEP 3116 - "New I/O"

    Classes defined here: BufferedIOBase, BufferedReader, BufferedWriter,
    BufferedRandom.

    Written by Amaury Forgeot d'Arc and Antoine Pitrou
*/

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#include "pythread.h"
#include "_iomodule.h"

/*
 * BufferedIOBase class, inherits from IOBase.
 */
PyDoc_STRVAR(bufferediobase_doc,
    "Base class for buffered IO objects.\n"
    "\n"
    "The main difference with RawIOBase is that the read() method\n"
    "supports omitting the size argument, and does not have a default\n"
    "implementation that defers to readinto().\n"
    "\n"
    "In addition, read(), readinto() and write() may raise\n"
    "BlockingIOError if the underlying raw stream is in non-blocking\n"
    "mode and not ready; unlike their raw counterparts, they will never\n"
    "return None.\n"
    "\n"
    "A typical implementation should not inherit from a RawIOBase\n"
    "implementation, but wrap one.\n"
    );

static PyObject *
bufferediobase_readinto(PyObject *self, PyObject *args)
{
    Py_buffer buf;
    Py_ssize_t len;
    PyObject *data;

    if (!PyArg_ParseTuple(args, "w*:readinto", &buf)) {
        return NULL;
    }

    data = PyObject_CallMethod(self, "read", "n", buf.len);
    if (data == NULL)
        goto error;

    if (!PyBytes_Check(data)) {
        Py_DECREF(data);
        PyErr_SetString(PyExc_TypeError, "read() should return bytes");
        goto error;
    }

    len = Py_SIZE(data);
    memcpy(buf.buf, PyBytes_AS_STRING(data), len);

    PyBuffer_Release(&buf);
    Py_DECREF(data);

    return PyLong_FromSsize_t(len);

  error:
    PyBuffer_Release(&buf);
    return NULL;
}

static PyObject *
bufferediobase_unsupported(const char *message)
{
    PyErr_SetString(IO_STATE->unsupported_operation, message);
    return NULL;
}

PyDoc_STRVAR(bufferediobase_detach_doc,
    "Disconnect this buffer from its underlying raw stream and return it.\n"
    "\n"
    "After the raw stream has been detached, the buffer is in an unusable\n"
    "state.\n");

static PyObject *
bufferediobase_detach(PyObject *self)
{
    return bufferediobase_unsupported("detach");
}

PyDoc_STRVAR(bufferediobase_read_doc,
    "Read and return up to n bytes.\n"
    "\n"
    "If the argument is omitted, None, or negative, reads and\n"
    "returns all data until EOF.\n"
    "\n"
    "If the argument is positive, and the underlying raw stream is\n"
    "not 'interactive', multiple raw reads may be issued to satisfy\n"
    "the byte count (unless EOF is reached first).  But for\n"
    "interactive raw streams (as well as sockets and pipes), at most\n"
    "one raw read will be issued, and a short result does not imply\n"
    "that EOF is imminent.\n"
    "\n"
    "Returns an empty bytes object on EOF.\n"
    "\n"
    "Returns None if the underlying raw stream was open in non-blocking\n"
    "mode and no data is available at the moment.\n");

static PyObject *
bufferediobase_read(PyObject *self, PyObject *args)
{
    return bufferediobase_unsupported("read");
}

PyDoc_STRVAR(bufferediobase_read1_doc,
    "Read and return up to n bytes, with at most one read() call\n"
    "to the underlying raw stream. A short result does not imply\n"
    "that EOF is imminent.\n"
    "\n"
    "Returns an empty bytes object on EOF.\n");

static PyObject *
bufferediobase_read1(PyObject *self, PyObject *args)
{
    return bufferediobase_unsupported("read1");
}

PyDoc_STRVAR(bufferediobase_write_doc,
    "Write the given buffer to the IO stream.\n"
    "\n"
    "Returns the number of bytes written, which is never less than\n"
    "len(b).\n"
    "\n"
    "Raises BlockingIOError if the buffer is full and the\n"
    "underlying raw stream cannot accept more data at the moment.\n");

static PyObject *
bufferediobase_write(PyObject *self, PyObject *args)
{
    return bufferediobase_unsupported("write");
}


static PyMethodDef bufferediobase_methods[] = {
    {"detach", (PyCFunction)bufferediobase_detach, METH_NOARGS, bufferediobase_detach_doc},
    {"read", bufferediobase_read, METH_VARARGS, bufferediobase_read_doc},
    {"read1", bufferediobase_read1, METH_VARARGS, bufferediobase_read1_doc},
    {"readinto", bufferediobase_readinto, METH_VARARGS, NULL},
    {"write", bufferediobase_write, METH_VARARGS, bufferediobase_write_doc},
    {NULL, NULL}
};

PyTypeObject PyBufferedIOBase_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "_io._BufferedIOBase",      /*tp_name*/
    0,                          /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    0,                          /*tp_dealloc*/
    0,                          /*tp_print*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_compare */
    0,                          /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash */
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,  /*tp_flags*/
    bufferediobase_doc,         /* tp_doc */
    0,                          /* tp_traverse */
    0,                          /* tp_clear */
    0,                          /* tp_richcompare */
    0,                          /* tp_weaklistoffset */
    0,                          /* tp_iter */
    0,                          /* tp_iternext */
    bufferediobase_methods,     /* tp_methods */
    0,                          /* tp_members */
    0,                          /* tp_getset */
    &PyIOBase_Type,             /* tp_base */
    0,                          /* tp_dict */
    0,                          /* tp_descr_get */
    0,                          /* tp_descr_set */
    0,                          /* tp_dictoffset */
    0,                          /* tp_init */
    0,                          /* tp_alloc */
    0,                          /* tp_new */
};


typedef struct {
    PyObject_HEAD

    PyObject *raw;
    int ok;    /* Initialized? */
    int detached;
    int readable;
    int writable;
    int deallocating;

    /* True if this is a vanilla Buffered object (rather than a user derived
       class) *and* the raw stream is a vanilla FileIO object. */
    int fast_closed_checks;

    /* Absolute position inside the raw stream (-1 if unknown). */
    Py_off_t abs_pos;

    /* A static buffer of size `buffer_size` */
    char *buffer;
    /* Current logical position in the buffer. */
    Py_off_t pos;
    /* Position of the raw stream in the buffer. */
    Py_off_t raw_pos;

    /* Just after the last buffered byte in the buffer, or -1 if the buffer
       isn't ready for reading. */
    Py_off_t read_end;

    /* Just after the last byte actually written */
    Py_off_t write_pos;
    /* Just after the last byte waiting to be written, or -1 if the buffer
       isn't ready for writing. */
    Py_off_t write_end;

#ifdef WITH_THREAD
    PyThread_type_lock lock;
    volatile long owner;
#endif

    Py_ssize_t buffer_size;
    Py_ssize_t buffer_mask;

    PyObject *dict;
    PyObject *weakreflist;
} buffered;

/*
    Implementation notes:

    * BufferedReader, BufferedWriter and BufferedRandom try to share most
      methods (this is helped by the members `readable` and `writable`, which
      are initialized in the respective constructors)
    * They also share a single buffer for reading and writing. This enables
      interleaved reads and writes without flushing. It also makes the logic
      a bit trickier to get right.
    * The absolute position of the raw stream is cached, if possible, in the
      `abs_pos` member. It must be updated every time an operation is done
      on the raw stream. If not sure, it can be reinitialized by calling
      _buffered_raw_tell(), which queries the raw stream (_buffered_raw_seek()
      also does it). To read it, use RAW_TELL().
    * Three helpers, _bufferedreader_raw_read, _bufferedwriter_raw_write and
      _bufferedwriter_flush_unlocked do a lot of useful housekeeping.

    NOTE: we should try to maintain block alignment of reads and writes to the
    raw stream (according to the buffer size), but for now it is only done
    in read() and friends.

*/

/* These macros protect the buffered object against concurrent operations. */

#ifdef WITH_THREAD

static int
_enter_buffered_busy(buffered *self)
{
    if (self->owner == PyThread_get_thread_ident()) {
        PyErr_Format(PyExc_RuntimeError,
                     "reentrant call inside %R", self);
        return 0;
    }
    Py_BEGIN_ALLOW_THREADS
    PyThread_acquire_lock(self->lock, 1);
    Py_END_ALLOW_THREADS
    return 1;
}

#define ENTER_BUFFERED(self) \
    ( (PyThread_acquire_lock(self->lock, 0) ? \
       1 : _enter_buffered_busy(self)) \
     && (self->owner = PyThread_get_thread_ident(), 1) )

#define LEAVE_BUFFERED(self) \
    do { \
        self->owner = 0; \
        PyThread_release_lock(self->lock); \
    } while(0);

#else
#define ENTER_BUFFERED(self) 1
#define LEAVE_BUFFERED(self)
#endif

#define CHECK_INITIALIZED(self) \
    if (self->ok <= 0) { \
        if (self->detached) { \
            PyErr_SetString(PyExc_ValueError, \
                 "raw stream has been detached"); \
        } else { \
            PyErr_SetString(PyExc_ValueError, \
                "I/O operation on uninitialized object"); \
        } \
        return NULL; \
    }

#define CHECK_INITIALIZED_INT(self) \
    if (self->ok <= 0) { \
        if (self->detached) { \
            PyErr_SetString(PyExc_ValueError, \
                 "raw stream has been detached"); \
        } else { \
            PyErr_SetString(PyExc_ValueError, \
                "I/O operation on uninitialized object"); \
        } \
        return -1; \
    }

#define IS_CLOSED(self) \
    (self->fast_closed_checks \
     ? _PyFileIO_closed(self->raw) \
     : buffered_closed(self))

#define CHECK_CLOSED(self, error_msg) \
    if (IS_CLOSED(self)) { \
        PyErr_SetString(PyExc_ValueError, error_msg); \
        return NULL; \
    }


#define VALID_READ_BUFFER(self) \
    (self->readable && self->read_end != -1)

#define VALID_WRITE_BUFFER(self) \
    (self->writable && self->write_end != -1)

#define ADJUST_POSITION(self, _new_pos) \
    do { \
        self->pos = _new_pos; \
        if (VALID_READ_BUFFER(self) && self->read_end < self->pos) \
            self->read_end = self->pos; \
    } while(0)

#define READAHEAD(self) \
    ((self->readable && VALID_READ_BUFFER(self)) \
        ? (self->read_end - self->pos) : 0)

#define RAW_OFFSET(self) \
    (((VALID_READ_BUFFER(self) || VALID_WRITE_BUFFER(self)) \
        && self->raw_pos >= 0) ? self->raw_pos - self->pos : 0)

#define RAW_TELL(self) \
    (self->abs_pos != -1 ? self->abs_pos : _buffered_raw_tell(self))

#define MINUS_LAST_BLOCK(self, size) \
    (self->buffer_mask ? \
        (size & ~self->buffer_mask) : \
        (self->buffer_size * (size / self->buffer_size)))


static void
buffered_dealloc(buffered *self)
{
    self->deallocating = 1;
    if (self->ok && _PyIOBase_finalize((PyObject *) self) < 0)
        return;
    _PyObject_GC_UNTRACK(self);
    self->ok = 0;
    if (self->weakreflist != NULL)
        PyObject_ClearWeakRefs((PyObject *)self);
    Py_CLEAR(self->raw);
    if (self->buffer) {
        PyMem_Free(self->buffer);
        self->buffer = NULL;
    }
#ifdef WITH_THREAD
    if (self->lock) {
        PyThread_free_lock(self->lock);
        self->lock = NULL;
    }
#endif
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free((PyObject *)self);
}

static int
buffered_traverse(buffered *self, visitproc visit, void *arg)
{
    Py_VISIT(self->raw);
    Py_VISIT(self->dict);
    return 0;
}

static int
buffered_clear(buffered *self)
{
    if (self->ok && _PyIOBase_finalize((PyObject *) self) < 0)
        return -1;
    self->ok = 0;
    Py_CLEAR(self->raw);
    Py_CLEAR(self->dict);
    return 0;
}

/* Because this can call arbitrary code, it shouldn't be called when
   the refcount is 0 (that is, not directly from tp_dealloc unless
   the refcount has been temporarily re-incremented). */
static PyObject *
buffered_dealloc_warn(buffered *self, PyObject *source)
{
    if (self->ok && self->raw) {
        PyObject *r;
        r = PyObject_CallMethod(self->raw, "_dealloc_warn", "O", source);
        if (r)
            Py_DECREF(r);
        else
            PyErr_Clear();
    }
    Py_RETURN_NONE;
}

/*
 * _BufferedIOMixin methods
 * This is not a class, just a collection of methods that will be reused
 * by BufferedReader and BufferedWriter
 */

/* Flush and close */

static PyObject *
buffered_simple_flush(buffered *self, PyObject *args)
{
    CHECK_INITIALIZED(self)
    return PyObject_CallMethodObjArgs(self->raw, _PyIO_str_flush, NULL);
}

static int
buffered_closed(buffered *self)
{
    int closed;
    PyObject *res;
    CHECK_INITIALIZED_INT(self)
    res = PyObject_GetAttr(self->raw, _PyIO_str_closed);
    if (res == NULL)
        return -1;
    closed = PyObject_IsTrue(res);
    Py_DECREF(res);
    return closed;
}

static PyObject *
buffered_closed_get(buffered *self, void *context)
{
    CHECK_INITIALIZED(self)
    return PyObject_GetAttr(self->raw, _PyIO_str_closed);
}

static PyObject *
buffered_close(buffered *self, PyObject *args)
{
    PyObject *res = NULL;
    int r;

    CHECK_INITIALIZED(self)
    if (!ENTER_BUFFERED(self))
        return NULL;

    r = buffered_closed(self);
    if (r < 0)
        goto end;
    if (r > 0) {
        res = Py_None;
        Py_INCREF(res);
        goto end;
    }

    if (self->deallocating) {
        PyObject *r = buffered_dealloc_warn(self, (PyObject *) self);
        if (r)
            Py_DECREF(r);
        else
            PyErr_Clear();
    }
    /* flush() will most probably re-take the lock, so drop it first */
    LEAVE_BUFFERED(self)
    res = PyObject_CallMethodObjArgs((PyObject *)self, _PyIO_str_flush, NULL);
    if (!ENTER_BUFFERED(self))
        return NULL;
    if (res == NULL) {
        goto end;
    }
    Py_XDECREF(res);

    res = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_close, NULL);

end:
    LEAVE_BUFFERED(self)
    return res;
}

/* detach */

static PyObject *
buffered_detach(buffered *self, PyObject *args)
{
    PyObject *raw, *res;
    CHECK_INITIALIZED(self)
    res = PyObject_CallMethodObjArgs((PyObject *)self, _PyIO_str_flush, NULL);
    if (res == NULL)
        return NULL;
    Py_DECREF(res);
    raw = self->raw;
    self->raw = NULL;
    self->detached = 1;
    self->ok = 0;
    return raw;
}

/* Inquiries */

static PyObject *
buffered_seekable(buffered *self, PyObject *args)
{
    CHECK_INITIALIZED(self)
    return PyObject_CallMethodObjArgs(self->raw, _PyIO_str_seekable, NULL);
}

static PyObject *
buffered_readable(buffered *self, PyObject *args)
{
    CHECK_INITIALIZED(self)
    return PyObject_CallMethodObjArgs(self->raw, _PyIO_str_readable, NULL);
}

static PyObject *
buffered_writable(buffered *self, PyObject *args)
{
    CHECK_INITIALIZED(self)
    return PyObject_CallMethodObjArgs(self->raw, _PyIO_str_writable, NULL);
}

static PyObject *
buffered_name_get(buffered *self, void *context)
{
    CHECK_INITIALIZED(self)
    return PyObject_GetAttrString(self->raw, "name");
}

static PyObject *
buffered_mode_get(buffered *self, void *context)
{
    CHECK_INITIALIZED(self)
    return PyObject_GetAttrString(self->raw, "mode");
}

/* Lower-level APIs */

static PyObject *
buffered_fileno(buffered *self, PyObject *args)
{
    CHECK_INITIALIZED(self)
    return PyObject_CallMethodObjArgs(self->raw, _PyIO_str_fileno, NULL);
}

static PyObject *
buffered_isatty(buffered *self, PyObject *args)
{
    CHECK_INITIALIZED(self)
    return PyObject_CallMethodObjArgs(self->raw, _PyIO_str_isatty, NULL);
}

/* Serialization */

static PyObject *
buffered_getstate(buffered *self, PyObject *args)
{
    PyErr_Format(PyExc_TypeError,
                 "cannot serialize '%s' object", Py_TYPE(self)->tp_name);
    return NULL;
}

/* Forward decls */
static PyObject *
_bufferedwriter_flush_unlocked(buffered *, int);
static Py_ssize_t
_bufferedreader_fill_buffer(buffered *self);
static void
_bufferedreader_reset_buf(buffered *self);
static void
_bufferedwriter_reset_buf(buffered *self);
static PyObject *
_bufferedreader_peek_unlocked(buffered *self, Py_ssize_t);
static PyObject *
_bufferedreader_read_all(buffered *self);
static PyObject *
_bufferedreader_read_fast(buffered *self, Py_ssize_t);
static PyObject *
_bufferedreader_read_generic(buffered *self, Py_ssize_t);
static Py_ssize_t
_bufferedreader_raw_read(buffered *self, char *start, Py_ssize_t len);

/*
 * Helpers
 */

/* Returns the address of the `written` member if a BlockingIOError was
   raised, NULL otherwise. The error is always re-raised. */
static Py_ssize_t *
_buffered_check_blocking_error(void)
{
    PyObject *t, *v, *tb;
    PyBlockingIOErrorObject *err;

    PyErr_Fetch(&t, &v, &tb);
    if (v == NULL || !PyErr_GivenExceptionMatches(v, PyExc_BlockingIOError)) {
        PyErr_Restore(t, v, tb);
        return NULL;
    }
    err = (PyBlockingIOErrorObject *) v;
    /* TODO: sanity check (err->written >= 0) */
    PyErr_Restore(t, v, tb);
    return &err->written;
}

static Py_off_t
_buffered_raw_tell(buffered *self)
{
    Py_off_t n;
    PyObject *res;
    res = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_tell, NULL);
    if (res == NULL)
        return -1;
    n = PyNumber_AsOff_t(res, PyExc_ValueError);
    Py_DECREF(res);
    if (n < 0) {
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_IOError,
                         "Raw stream returned invalid position %" PY_PRIdOFF,
                         (PY_OFF_T_COMPAT)n);
        return -1;
    }
    self->abs_pos = n;
    return n;
}

static Py_off_t
_buffered_raw_seek(buffered *self, Py_off_t target, int whence)
{
    PyObject *res, *posobj, *whenceobj;
    Py_off_t n;

    posobj = PyLong_FromOff_t(target);
    if (posobj == NULL)
        return -1;
    whenceobj = PyLong_FromLong(whence);
    if (whenceobj == NULL) {
        Py_DECREF(posobj);
        return -1;
    }
    res = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_seek,
                                     posobj, whenceobj, NULL);
    Py_DECREF(posobj);
    Py_DECREF(whenceobj);
    if (res == NULL)
        return -1;
    n = PyNumber_AsOff_t(res, PyExc_ValueError);
    Py_DECREF(res);
    if (n < 0) {
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_IOError,
                         "Raw stream returned invalid position %" PY_PRIdOFF,
                         (PY_OFF_T_COMPAT)n);
        return -1;
    }
    self->abs_pos = n;
    return n;
}

static int
_buffered_init(buffered *self)
{
    Py_ssize_t n;
    if (self->buffer_size <= 0) {
        PyErr_SetString(PyExc_ValueError,
            "buffer size must be strictly positive");
        return -1;
    }
    if (self->buffer)
        PyMem_Free(self->buffer);
    self->buffer = PyMem_Malloc(self->buffer_size);
    if (self->buffer == NULL) {
        PyErr_NoMemory();
        return -1;
    }
#ifdef WITH_THREAD
    if (self->lock)
        PyThread_free_lock(self->lock);
    self->lock = PyThread_allocate_lock();
    if (self->lock == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "can't allocate read lock");
        return -1;
    }
    self->owner = 0;
#endif
    /* Find out whether buffer_size is a power of 2 */
    /* XXX is this optimization useful? */
    for (n = self->buffer_size - 1; n & 1; n >>= 1)
        ;
    //prophet generated patch
    {
    int __choose0 = __choose("__SWITCH0");
    {
    int __temp0=(n == 0)
    ;
    if (__choose0 == 0)
    {}
    #ifdef __COMPILE_0
    else if (__choose0 == 1)
    {
    __temp0= (__is_neg("0-1", "L710", 24, &(n), sizeof (n), &(self), sizeof (self), &(self->buffer_size), sizeof (self->buffer_size), &(self->buffer_mask), sizeof (self->buffer_mask), &(self->owner), sizeof (self->owner), &(PyExc_RuntimeError), sizeof (PyExc_RuntimeError), &(self->lock), sizeof (self->lock), &(self->buffer), sizeof (self->buffer), &(PyExc_ValueError), sizeof (PyExc_ValueError), &(self->raw), sizeof (self->raw), &(self->ok), sizeof (self->ok), &(self->detached), sizeof (self->detached), &(self->readable), sizeof (self->readable), &(self->writable), sizeof (self->writable), &(self->deallocating), sizeof (self->deallocating), &(self->fast_closed_checks), sizeof (self->fast_closed_checks), &(self->abs_pos), sizeof (self->abs_pos), &(self->pos), sizeof (self->pos), &(self->raw_pos), sizeof (self->raw_pos), &(self->read_end), sizeof (self->read_end), &(self->write_pos), sizeof (self->write_pos), &(self->write_end), sizeof (self->write_end), &(self->dict), sizeof (self->dict), &(self->weakreflist), sizeof (self->weakreflist)));
    }
    #endif
    #ifdef __COMPILE_1
    else if (__choose0 == 2)
    {
    __temp0= ((n == 0) || __is_neg("0-2", "L710", 24, &(n), sizeof (n), &(self), sizeof (self), &(self->buffer_size), sizeof (self->buffer_size), &(self->buffer_mask), sizeof (self->buffer_mask), &(self->owner), sizeof (self->owner), &(PyExc_RuntimeError), sizeof (PyExc_RuntimeError), &(self->lock), sizeof (self->lock), &(self->buffer), sizeof (self->buffer), &(PyExc_ValueError), sizeof (PyExc_ValueError), &(self->raw), sizeof (self->raw), &(self->ok), sizeof (self->ok), &(self->detached), sizeof (self->detached), &(self->readable), sizeof (self->readable), &(self->writable), sizeof (self->writable), &(self->deallocating), sizeof (self->deallocating), &(self->fast_closed_checks), sizeof (self->fast_closed_checks), &(self->abs_pos), sizeof (self->abs_pos), &(self->pos), sizeof (self->pos), &(self->raw_pos), sizeof (self->raw_pos), &(self->read_end), sizeof (self->read_end), &(self->write_pos), sizeof (self->write_pos), &(self->write_end), sizeof (self->write_end), &(self->dict), sizeof (self->dict), &(self->weakreflist), sizeof (self->weakreflist)));
    }
    #endif
    if (__temp0)
            self->buffer_mask = self->buffer_size - 1;
        else
            {
    int __choose1 = __choose("__SWITCH1");
    if (__choose1 == 0)
    {}
    #ifdef __COMPILE_2
    else if (__choose1 == 1)
    {
    //AddInitKind
    memset(&self->abs_pos, 0, sizeof (*(&self->abs_pos)));
    }
    #endif
    #ifdef __COMPILE_3
    else if (__choose1 == 2)
    {
    //AddInitKind
    memset(&self->buffer, 0, sizeof (*(&self->buffer)));
    }
    #endif
    #ifdef __COMPILE_4
    else if (__choose1 == 3)
    {
    //AddInitKind
    memset(&self->buffer_mask, 0, sizeof (*(&self->buffer_mask)));
    }
    #endif
    #ifdef __COMPILE_5
    else if (__choose1 == 4)
    {
    //AddInitKind
    memset(&self->buffer_size, 0, sizeof (*(&self->buffer_size)));
    }
    #endif
    #ifdef __COMPILE_6
    else if (__choose1 == 5)
    {
    //AddInitKind
    memset(&self->deallocating, 0, sizeof (*(&self->deallocating)));
    }
    #endif
    #ifdef __COMPILE_7
    else if (__choose1 == 6)
    {
    //AddInitKind
    memset(&self->detached, 0, sizeof (*(&self->detached)));
    }
    #endif
    #ifdef __COMPILE_8
    else if (__choose1 == 7)
    {
    //AddInitKind
    memset(&self->dict, 0, sizeof (*(&self->dict)));
    }
    #endif
    #ifdef __COMPILE_9
    else if (__choose1 == 8)
    {
    //AddInitKind
    memset(&self->fast_closed_checks, 0, sizeof (*(&self->fast_closed_checks)));
    }
    #endif
    #ifdef __COMPILE_10
    else if (__choose1 == 9)
    {
    //AddInitKind
    memset(&self->lock, 0, sizeof (*(&self->lock)));
    }
    #endif
    #ifdef __COMPILE_11
    else if (__choose1 == 10)
    {
    //AddInitKind
    memset(&self->ob_base, 0, sizeof (*(&self->ob_base)));
    }
    #endif
    #ifdef __COMPILE_12
    else if (__choose1 == 11)
    {
    //AddInitKind
    memset(&self->ok, 0, sizeof (*(&self->ok)));
    }
    #endif
    #ifdef __COMPILE_13
    else if (__choose1 == 12)
    {
    //AddInitKind
    memset(&self->owner, 0, sizeof (*(&self->owner)));
    }
    #endif
    #ifdef __COMPILE_14
    else if (__choose1 == 13)
    {
    //AddInitKind
    memset(&self->pos, 0, sizeof (*(&self->pos)));
    }
    #endif
    #ifdef __COMPILE_15
    else if (__choose1 == 14)
    {
    //AddInitKind
    memset(&self->raw, 0, sizeof (*(&self->raw)));
    }
    #endif
    #ifdef __COMPILE_16
    else if (__choose1 == 15)
    {
    //AddInitKind
    memset(&self->raw_pos, 0, sizeof (*(&self->raw_pos)));
    }
    #endif
    #ifdef __COMPILE_17
    else if (__choose1 == 16)
    {
    //AddInitKind
    memset(&self->read_end, 0, sizeof (*(&self->read_end)));
    }
    #endif
    #ifdef __COMPILE_18
    else if (__choose1 == 17)
    {
    //AddInitKind
    memset(&self->readable, 0, sizeof (*(&self->readable)));
    }
    #endif
    #ifdef __COMPILE_19
    else if (__choose1 == 18)
    {
    //AddInitKind
    memset(&self->weakreflist, 0, sizeof (*(&self->weakreflist)));
    }
    #endif
    #ifdef __COMPILE_20
    else if (__choose1 == 19)
    {
    //AddInitKind
    memset(&self->writable, 0, sizeof (*(&self->writable)));
    }
    #endif
    #ifdef __COMPILE_21
    else if (__choose1 == 20)
    {
    //AddInitKind
    memset(&self->write_end, 0, sizeof (*(&self->write_end)));
    }
    #endif
    #ifdef __COMPILE_22
    else if (__choose1 == 21)
    {
    //AddInitKind
    memset(&self->write_pos, 0, sizeof (*(&self->write_pos)));
    }
    #endif
    #ifdef __COMPILE_23
    else if (__choose1 == 22)
    {
    //AddInitKind
    memset(self, 0, sizeof (*(self)));
    }
    #endif
    #ifdef __COMPILE_24
    else if (__choose1 == 23)
    {
    //AddInitKind
    memset(self->buffer, 0, sizeof (*(self->buffer)));
    }
    #endif
    #ifdef __COMPILE_25
    else if (__choose1 == 24)
    {
    //AddInitKind
    memset(self->dict, 0, sizeof (*(self->dict)));
    }
    #endif
    #ifdef __COMPILE_26
    else if (__choose1 == 25)
    {
    //AddInitKind
    memset(self->lock, 0, sizeof (*(self->lock)));
    }
    #endif
    #ifdef __COMPILE_27
    else if (__choose1 == 26)
    {
    //AddInitKind
    memset(self->raw, 0, sizeof (*(self->raw)));
    }
    #endif
    #ifdef __COMPILE_28
    else if (__choose1 == 27)
    {
    //AddInitKind
    memset(self->weakreflist, 0, sizeof (*(self->weakreflist)));
    }
    #endif
    #ifdef __COMPILE_29
    else if (__choose1 == 28)
    {
    //AddStmtAndReplaceAtomKind
    PyErr_Format(PyExc_RuntimeError, "reentrant call inside %R", (self));
    }
    #endif
    #ifdef __COMPILE_30
    else if (__choose1 == 29)
    {
    //AddStmtAndReplaceAtomKind
    PyMem_Free((self)->buffer);
    }
    #endif
    #ifdef __COMPILE_31
    else if (__choose1 == 30)
    {
    //AddStmtAndReplaceAtomKind
    PyThread_acquire_lock((self)->lock, 1);
    }
    #endif
    #ifdef __COMPILE_32
    else if (__choose1 == 31)
    {
    //AddStmtAndReplaceAtomKind
    PyThread_free_lock((self)->lock);
    }
    #endif
    #ifdef __COMPILE_33
    else if (__choose1 == 32)
    {
    //AddStmtAndReplaceAtomKind
    _bufferedreader_reset_buf((self));
    }
    #endif
    #ifdef __COMPILE_34
    else if (__choose1 == 33)
    {
    //AddStmtAndReplaceAtomKind
    _bufferedwriter_reset_buf((self));
    }
    #endif
    #ifdef __COMPILE_35
    else if (__choose1 == 34)
    {
    //AddStmtAndReplaceAtomKind
    self->buffer = PyMem_Malloc((self)->buffer_size);
    }
    #endif
    #ifdef __COMPILE_36
    else if (__choose1 == 35)
    {
    //AddStmtAndReplaceAtomKind
    self->buffer_mask = (-1);
    }
    #endif
    #ifdef __COMPILE_37
    else if (__choose1 == 36)
    {
    //AddStmtAndReplaceAtomKind
    self->buffer_mask = (0);
    }
    #endif
    #ifdef __COMPILE_38
    else if (__choose1 == 37)
    {
    //AddStmtAndReplaceAtomKind
    self->buffer_mask = (1);
    }
    #endif
    #ifdef __COMPILE_39
    else if (__choose1 == 38)
    {
    //AddStmtAndReplaceAtomKind
    self->buffer_mask = (n);
    }
    #endif
    #ifdef __COMPILE_40
    else if (__choose1 == 39)
    {
    //AddStmtAndReplaceAtomKind
    self->buffer_mask = (self)->buffer_size - 1;
    }
    #endif
    #ifdef __COMPILE_41
    else if (__choose1 == 40)
    {
    //AddStmtAndReplaceAtomKind
    self->owner = (-1);
    }
    #endif
    #ifdef __COMPILE_42
    else if (__choose1 == 41)
    {
    //AddStmtAndReplaceAtomKind
    self->owner = (0);
    }
    #endif
    #ifdef __COMPILE_43
    else if (__choose1 == 42)
    {
    //AddStmtAndReplaceAtomKind
    self->owner = (1);
    }
    #endif
    #ifdef __COMPILE_44
    else if (__choose1 == 43)
    {
    //AddStmtAndReplaceAtomKind
    self->owner = (n);
    }
    #endif
    #ifdef __COMPILE_45
    else if (__choose1 == 44)
    {
    //AddStmtKind
    (_Py_RefTotal++ , ((PyObject *)((&_Py_NoneStruct)))->ob_refcnt++);
    }
    #endif
    #ifdef __COMPILE_46
    else if (__choose1 == 45)
    {
    //AddStmtKind
    PyErr_Clear();
    }
    #endif
    #ifdef __COMPILE_47
    else if (__choose1 == 46)
    {
    //AddStmtKind
    PyErr_NoMemory();
    }
    #endif
    #ifdef __COMPILE_48
    else if (__choose1 == 47)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_RuntimeError, "can't allocate read lock");
    }
    #endif
    #ifdef __COMPILE_49
    else if (__choose1 == 48)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_TypeError, "read() should return bytes");
    }
    #endif
    #ifdef __COMPILE_50
    else if (__choose1 == 49)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "I/O operation on uninitialized object");
    }
    #endif
    #ifdef __COMPILE_51
    else if (__choose1 == 50)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "buffer size must be strictly positive");
    }
    #endif
    #ifdef __COMPILE_52
    else if (__choose1 == 51)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "flush of closed file");
    }
    #endif
    #ifdef __COMPILE_53
    else if (__choose1 == 52)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "raw stream has been detached");
    }
    #endif
    #ifdef __COMPILE_54
    else if (__choose1 == 53)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "read length must be positive or -1");
    }
    #endif
    #ifdef __COMPILE_55
    else if (__choose1 == 54)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "read length must be positive");
    }
    #endif
    #ifdef __COMPILE_56
    else if (__choose1 == 55)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "read of closed file");
    }
    #endif
    #ifdef __COMPILE_57
    else if (__choose1 == 56)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "readline of closed file");
    }
    #endif
    #ifdef __COMPILE_58
    else if (__choose1 == 57)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "seek of closed file");
    }
    #endif
    #ifdef __COMPILE_59
    else if (__choose1 == 58)
    {
    //AddStmtKind
    PyErr_SetString(PyExc_ValueError, "write to closed file");
    }
    #endif
    #ifdef __COMPILE_60
    else if (__choose1 == 59)
    {
    //AddStmtKind
    PyMem_Free(self->buffer);
    }
    #endif
    #ifdef __COMPILE_61
    else if (__choose1 == 60)
    {
    //AddStmtKind
    PyThread_free_lock(self->lock);
    }
    #endif
    #ifdef __COMPILE_62
    else if (__choose1 == 61)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1004, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_63
    else if (__choose1 == 62)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1418, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_64
    else if (__choose1 == 63)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1484, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_65
    else if (__choose1 == 64)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1505, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_66
    else if (__choose1 == 65)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1594, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_67
    else if (__choose1 == 66)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 884, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_68
    else if (__choose1 == 67)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 926, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_69
    else if (__choose1 == 68)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(n) == (n)", "Modules/_io/bufferedio.c", 1839, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_70
    else if (__choose1 == 69)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(self->buffer_size - self->pos) == (self->buffer_size - self->pos)", "Modules/_io/bufferedio.c", 1895, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_71
    else if (__choose1 == 70)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(self->buffer_size - self->write_end) == (self->buffer_size - self->write_end)", "Modules/_io/bufferedio.c", 1926, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_72
    else if (__choose1 == 71)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(self->read_end) == (self->read_end)", "Modules/_io/bufferedio.c", 1395, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_73
    else if (__choose1 == 72)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(self->write_end - self->write_pos) == (self->write_end - self->write_pos)", "Modules/_io/bufferedio.c", 1825, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_74
    else if (__choose1 == 73)
    {
    //AddStmtKind
    __assert_fail("(Py_off_t)(Py_ssize_t)(self->write_end - self->write_pos) == (self->write_end - self->write_pos)", "Modules/_io/bufferedio.c", 1920, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_75
    else if (__choose1 == 74)
    {
    //AddStmtKind
    __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 1459, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_76
    else if (__choose1 == 75)
    {
    //AddStmtKind
    __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 1471, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_77
    else if (__choose1 == 76)
    {
    //AddStmtKind
    __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 1473, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_78
    else if (__choose1 == 77)
    {
    //AddStmtKind
    __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 58, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_79
    else if (__choose1 == 78)
    {
    //AddStmtKind
    __assert_fail("PyBytes_Check(line)", "Modules/_io/bufferedio.c", 1271, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_80
    else if (__choose1 == 79)
    {
    //AddStmtKind
    __assert_fail("PyBytes_Check(res)", "Modules/_io/bufferedio.c", 1512, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_81
    else if (__choose1 == 80)
    {
    //AddStmtKind
    __assert_fail("VALID_WRITE_BUFFER(self)", "Modules/_io/bufferedio.c", 1917, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_82
    else if (__choose1 == 81)
    {
    //AddStmtKind
    __assert_fail("eintr_int != NULL", "Modules/_io/bufferedio.c", 732, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_83
    else if (__choose1 == 82)
    {
    //AddStmtKind
    __assert_fail("env_err != NULL", "Modules/_io/bufferedio.c", 739, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_84
    else if (__choose1 == 83)
    {
    //AddStmtKind
    __assert_fail("remaining <= self->buffer_size", "Modules/_io/bufferedio.c", 1544, __extension__ __PRETTY_FUNCTION__);
    }
    #endif
    #ifdef __COMPILE_85
    else if (__choose1 == 84)
    {
    //AddStmtKind
    self->buffer = PyMem_Malloc(self->buffer_size);
    }
    #endif
    #ifdef __COMPILE_86
    else if (__choose1 == 85)
    {
    //AddStmtKind
    self->buffer_mask = 0;
    }
    #endif
    #ifdef __COMPILE_87
    else if (__choose1 == 86)
    {
    //AddStmtKind
    self->buffer_mask = self->buffer_size - 1;
    }
    #endif
    #ifdef __COMPILE_88
    else if (__choose1 == 87)
    {
    //AddStmtKind
    self->lock = PyThread_allocate_lock();
    }
    #endif
    #ifdef __COMPILE_89
    else if (__choose1 == 88)
    {
    //AddStmtKind
    self->owner = 0;
    }
    #endif
    #ifdef __COMPILE_90
    else if (__choose1 == 89)
    {
    //IfExitKind
    if (__is_neg("1-89", "L713", 24, &(self), sizeof (self), &(self->buffer_mask),
    			 sizeof (self->buffer_mask), &(self->buffer_size), sizeof (self->buffer_size), &(n), sizeof (n), &(self->owner),
    			 sizeof (self->owner), &(PyExc_RuntimeError), sizeof (PyExc_RuntimeError), &(self->lock), sizeof (self->lock), &(self->buffer),
    			 sizeof (self->buffer), &(PyExc_ValueError), sizeof (PyExc_ValueError), &(self->raw), sizeof (self->raw), &(self->ok),
    			 sizeof (self->ok), &(self->detached), sizeof (self->detached), &(self->readable), sizeof (self->readable), &(self->writable),
    			 sizeof (self->writable), &(self->deallocating), sizeof (self->deallocating), &(self->fast_closed_checks), sizeof (self->fast_closed_checks), &(self->abs_pos),
    			 sizeof (self->abs_pos), &(self->pos), sizeof (self->pos), &(self->raw_pos), sizeof (self->raw_pos), &(self->read_end),
    			 sizeof (self->read_end), &(self->write_pos), sizeof (self->write_pos), &(self->write_end), sizeof (self->write_end), &(self->dict),
    			 sizeof (self->dict), &(self->weakreflist), sizeof (self->weakreflist)))
        return -1;
    }
    #endif
    #ifdef __COMPILE_91
    else if (__choose1 == 90)
    {
    //IfExitKind
    if (__is_neg("1-90", "L713", 24, &(self), sizeof (self), &(self->buffer_mask),
    			 sizeof (self->buffer_mask), &(self->buffer_size), sizeof (self->buffer_size), &(n), sizeof (n), &(self->owner),
    			 sizeof (self->owner), &(PyExc_RuntimeError), sizeof (PyExc_RuntimeError), &(self->lock), sizeof (self->lock), &(self->buffer),
    			 sizeof (self->buffer), &(PyExc_ValueError), sizeof (PyExc_ValueError), &(self->raw), sizeof (self->raw), &(self->ok),
    			 sizeof (self->ok), &(self->detached), sizeof (self->detached), &(self->readable), sizeof (self->readable), &(self->writable),
    			 sizeof (self->writable), &(self->deallocating), sizeof (self->deallocating), &(self->fast_closed_checks), sizeof (self->fast_closed_checks), &(self->abs_pos),
    			 sizeof (self->abs_pos), &(self->pos), sizeof (self->pos), &(self->raw_pos), sizeof (self->raw_pos), &(self->read_end),
    			 sizeof (self->read_end), &(self->write_pos), sizeof (self->write_pos), &(self->write_end), sizeof (self->write_end), &(self->dict),
    			 sizeof (self->dict), &(self->weakreflist), sizeof (self->weakreflist)))
        return 0;
    }
    #endif
    #ifdef __COMPILE_92
    else if (__choose1 == 91)
    {
    //IfExitKind
    if (__is_neg("1-91", "L713", 24, &(self), sizeof (self), &(self->buffer_mask),
    			 sizeof (self->buffer_mask), &(self->buffer_size), sizeof (self->buffer_size), &(n), sizeof (n), &(self->owner),
    			 sizeof (self->owner), &(PyExc_RuntimeError), sizeof (PyExc_RuntimeError), &(self->lock), sizeof (self->lock), &(self->buffer),
    			 sizeof (self->buffer), &(PyExc_ValueError), sizeof (PyExc_ValueError), &(self->raw), sizeof (self->raw), &(self->ok),
    			 sizeof (self->ok), &(self->detached), sizeof (self->detached), &(self->readable), sizeof (self->readable), &(self->writable),
    			 sizeof (self->writable), &(self->deallocating), sizeof (self->deallocating), &(self->fast_closed_checks), sizeof (self->fast_closed_checks), &(self->abs_pos),
    			 sizeof (self->abs_pos), &(self->pos), sizeof (self->pos), &(self->raw_pos), sizeof (self->raw_pos), &(self->read_end),
    			 sizeof (self->read_end), &(self->write_pos), sizeof (self->write_pos), &(self->write_end), sizeof (self->write_end), &(self->dict),
    			 sizeof (self->dict), &(self->weakreflist), sizeof (self->weakreflist)))
        return 1;
    }
    #endif
    int __choose2 = __choose("__SWITCH2");
    if (__choose2 == 0)
    {
    self->buffer_mask = 0;
    
    }
    #ifdef __COMPILE_93
    else if (__choose2 == 1)
    {
    //GuardKind
    if (!__is_neg("2-1", "L713", 24, &(self->buffer_mask), sizeof (self->buffer_mask), &(self), sizeof (self), &(self->buffer_size), sizeof (self->buffer_size), &(n), sizeof (n), &(self->owner), sizeof (self->owner), &(PyExc_RuntimeError), sizeof (PyExc_RuntimeError), &(self->lock), sizeof (self->lock), &(self->buffer), sizeof (self->buffer), &(PyExc_ValueError), sizeof (PyExc_ValueError), &(self->raw), sizeof (self->raw), &(self->ok), sizeof (self->ok), &(self->detached), sizeof (self->detached), &(self->readable), sizeof (self->readable), &(self->writable), sizeof (self->writable), &(self->deallocating), sizeof (self->deallocating), &(self->fast_closed_checks), sizeof (self->fast_closed_checks), &(self->abs_pos), sizeof (self->abs_pos), &(self->pos), sizeof (self->pos), &(self->raw_pos), sizeof (self->raw_pos), &(self->read_end), sizeof (self->read_end), &(self->write_pos), sizeof (self->write_pos), &(self->write_end), sizeof (self->write_end), &(self->dict), sizeof (self->dict), &(self->weakreflist), sizeof (self->weakreflist)))
        self->buffer_mask = 0;
    
    }
    #endif
    #ifdef __COMPILE_94
    else if (__choose2 == 2)
    {
    //MSVExtRemoveStmtKind
    {
    }
    
    }
    #endif
    #ifdef __COMPILE_95
    else if (__choose2 == 3)
    {
    //ReplaceKind
    self->buffer_mask = (-1);
    
    }
    #endif
    #ifdef __COMPILE_96
    else if (__choose2 == 4)
    {
    //ReplaceKind
    self->buffer_mask = (0 * n);
    
    }
    #endif
    #ifdef __COMPILE_97
    else if (__choose2 == 5)
    {
    //ReplaceKind
    self->buffer_mask = (0);
    
    }
    #endif
    #ifdef __COMPILE_98
    else if (__choose2 == 6)
    {
    //ReplaceKind
    self->buffer_mask = (1);
    
    }
    #endif
    #ifdef __COMPILE_99
    else if (__choose2 == 7)
    {
    //ReplaceKind
    self->buffer_mask = (n != 0);
    
    }
    #endif
    #ifdef __COMPILE_100
    else if (__choose2 == 8)
    {
    //ReplaceKind
    self->buffer_mask = (n + 0);
    
    }
    #endif
    #ifdef __COMPILE_101
    else if (__choose2 == 9)
    {
    //ReplaceKind
    self->buffer_mask = (n - 0);
    
    }
    #endif
    #ifdef __COMPILE_102
    else if (__choose2 == 10)
    {
    //ReplaceKind
    self->buffer_mask = (n == 0);
    
    }
    #endif
    #ifdef __COMPILE_103
    else if (__choose2 == 11)
    {
    //ReplaceKind
    self->buffer_mask = (n);
    
    }
    #endif
    #ifdef __COMPILE_104
    else if (__choose2 == 12)
    {
    //ReplaceKind
    self->buffer_mask = (self != 0);
    
    }
    #endif
    #ifdef __COMPILE_105
    else if (__choose2 == 13)
    {
    //ReplaceKind
    self->buffer_mask = (self == 0);
    
    }
    #endif
    }
    }
    }
    if (_buffered_raw_tell(self) == -1)
        PyErr_Clear();
    return 0;
}

/* Return 1 if an EnvironmentError with errno == EINTR is set (and then
   clears the error indicator), 0 otherwise.
   Should only be called when PyErr_Occurred() is true.
*/
static int
_trap_eintr(void)
{
    static PyObject *eintr_int = NULL;
    PyObject *typ, *val, *tb;
    PyEnvironmentErrorObject *env_err;

    if (eintr_int == NULL) {
        eintr_int = PyLong_FromLong(EINTR);
        assert(eintr_int != NULL);
    }
    if (!PyErr_ExceptionMatches(PyExc_EnvironmentError))
        return 0;
    PyErr_Fetch(&typ, &val, &tb);
    PyErr_NormalizeException(&typ, &val, &tb);
    env_err = (PyEnvironmentErrorObject *) val;
    assert(env_err != NULL);
    if (env_err->myerrno != NULL &&
        PyObject_RichCompareBool(env_err->myerrno, eintr_int, Py_EQ) > 0) {
        Py_DECREF(typ);
        Py_DECREF(val);
        Py_XDECREF(tb);
        return 1;
    }
    /* This silences any error set by PyObject_RichCompareBool() */
    PyErr_Restore(typ, val, tb);
    return 0;
}

/*
 * Shared methods and wrappers
 */

static PyObject *
buffered_flush(buffered *self, PyObject *args)
{
    PyObject *res;

    CHECK_INITIALIZED(self)
    CHECK_CLOSED(self, "flush of closed file")

    if (!ENTER_BUFFERED(self))
        return NULL;
    res = _bufferedwriter_flush_unlocked(self, 0);
    if (res != NULL && self->readable) {
        /* Rewind the raw stream so that its position corresponds to
           the current logical position. */
        Py_off_t n;
        n = _buffered_raw_seek(self, -RAW_OFFSET(self), 1);
        if (n == -1)
            Py_CLEAR(res);
        _bufferedreader_reset_buf(self);
    }
    LEAVE_BUFFERED(self)

    return res;
}

static PyObject *
buffered_peek(buffered *self, PyObject *args)
{
    Py_ssize_t n = 0;
    PyObject *res = NULL;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "|n:peek", &n)) {
        return NULL;
    }

    if (!ENTER_BUFFERED(self))
        return NULL;

    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 1);
        if (res == NULL)
            goto end;
        Py_CLEAR(res);
    }
    res = _bufferedreader_peek_unlocked(self, n);

end:
    LEAVE_BUFFERED(self)
    return res;
}

static PyObject *
buffered_read(buffered *self, PyObject *args)
{
    Py_ssize_t n = -1;
    PyObject *res;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "|O&:read", &_PyIO_ConvertSsize_t, &n)) {
        return NULL;
    }
    if (n < -1) {
        PyErr_SetString(PyExc_ValueError,
                        "read length must be positive or -1");
        return NULL;
    }

    CHECK_CLOSED(self, "read of closed file")

    if (n == -1) {
        /* The number of bytes is unspecified, read until the end of stream */
        if (!ENTER_BUFFERED(self))
            return NULL;
        res = _bufferedreader_read_all(self);
        LEAVE_BUFFERED(self)
    }
    else {
        res = _bufferedreader_read_fast(self, n);
        if (res == Py_None) {
            Py_DECREF(res);
            if (!ENTER_BUFFERED(self))
                return NULL;
            res = _bufferedreader_read_generic(self, n);
            LEAVE_BUFFERED(self)
        }
    }

    return res;
}

static PyObject *
buffered_read1(buffered *self, PyObject *args)
{
    Py_ssize_t n, have, r;
    PyObject *res = NULL;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "n:read1", &n)) {
        return NULL;
    }

    if (n < 0) {
        PyErr_SetString(PyExc_ValueError,
                        "read length must be positive");
        return NULL;
    }
    if (n == 0)
        return PyBytes_FromStringAndSize(NULL, 0);

    if (!ENTER_BUFFERED(self))
        return NULL;

    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 1);
        if (res == NULL)
            goto end;
        Py_CLEAR(res);
    }

    /* Return up to n bytes.  If at least one byte is buffered, we
       only return buffered bytes.  Otherwise, we do one raw read. */

    /* XXX: this mimicks the io.py implementation but is probably wrong.
       If we need to read from the raw stream, then we could actually read
       all `n` bytes asked by the caller (and possibly more, so as to fill
       our buffer for the next reads). */

    have = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    if (have > 0) {
        if (n > have)
            n = have;
        res = PyBytes_FromStringAndSize(self->buffer + self->pos, n);
        if (res == NULL)
            goto end;
        self->pos += n;
        goto end;
    }

    /* Fill the buffer from the raw stream, and copy it to the result. */
    _bufferedreader_reset_buf(self);
    r = _bufferedreader_fill_buffer(self);
    if (r == -1)
        goto end;
    if (r == -2)
        r = 0;
    if (n > r)
        n = r;
    res = PyBytes_FromStringAndSize(self->buffer, n);
    if (res == NULL)
        goto end;
    self->pos = n;

end:
    LEAVE_BUFFERED(self)
    return res;
}

static PyObject *
buffered_readinto(buffered *self, PyObject *args)
{
    Py_buffer buf;
    Py_ssize_t n, written = 0, remaining;
    PyObject *res = NULL;

    CHECK_INITIALIZED(self)

    if (!PyArg_ParseTuple(args, "w*:readinto", &buf))
        return NULL;

    n = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    if (n > 0) {
        if (n >= buf.len) {
            memcpy(buf.buf, self->buffer + self->pos, buf.len);
            self->pos += buf.len;
            res = PyLong_FromSsize_t(buf.len);
            goto end_unlocked;
        }
        memcpy(buf.buf, self->buffer + self->pos, n);
        self->pos += n;
        written = n;
    }

    if (!ENTER_BUFFERED(self))
        goto end_unlocked;

    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 0);
        if (res == NULL)
            goto end;
        //prophet generated patch
        {
        int __choose3 = __choose("__SWITCH3");
        if (__choose3 == 0)
        {}
        #ifdef __COMPILE_106
        else if (__choose3 == 1)
        {
        //AddInitKind
        memset(&buf.buf, 0, sizeof (*(&buf.buf)));
        }
        #endif
        #ifdef __COMPILE_107
        else if (__choose3 == 2)
        {
        //AddInitKind
        memset(&buf.format, 0, sizeof (*(&buf.format)));
        }
        #endif
        #ifdef __COMPILE_108
        else if (__choose3 == 3)
        {
        //AddInitKind
        memset(&buf.internal, 0, sizeof (*(&buf.internal)));
        }
        #endif
        #ifdef __COMPILE_109
        else if (__choose3 == 4)
        {
        //AddInitKind
        memset(&buf.itemsize, 0, sizeof (*(&buf.itemsize)));
        }
        #endif
        #ifdef __COMPILE_110
        else if (__choose3 == 5)
        {
        //AddInitKind
        memset(&buf.len, 0, sizeof (*(&buf.len)));
        }
        #endif
        #ifdef __COMPILE_111
        else if (__choose3 == 6)
        {
        //AddInitKind
        memset(&buf.ndim, 0, sizeof (*(&buf.ndim)));
        }
        #endif
        #ifdef __COMPILE_112
        else if (__choose3 == 7)
        {
        //AddInitKind
        memset(&buf.obj, 0, sizeof (*(&buf.obj)));
        }
        #endif
        #ifdef __COMPILE_113
        else if (__choose3 == 8)
        {
        //AddInitKind
        memset(&buf.readonly, 0, sizeof (*(&buf.readonly)));
        }
        #endif
        #ifdef __COMPILE_114
        else if (__choose3 == 9)
        {
        //AddInitKind
        memset(&buf.shape, 0, sizeof (*(&buf.shape)));
        }
        #endif
        #ifdef __COMPILE_115
        else if (__choose3 == 10)
        {
        //AddInitKind
        memset(&buf.smalltable, 0, sizeof (*(&buf.smalltable)));
        }
        #endif
        #ifdef __COMPILE_116
        else if (__choose3 == 11)
        {
        //AddInitKind
        memset(&buf.strides, 0, sizeof (*(&buf.strides)));
        }
        #endif
        #ifdef __COMPILE_117
        else if (__choose3 == 12)
        {
        //AddInitKind
        memset(&buf.suboffsets, 0, sizeof (*(&buf.suboffsets)));
        }
        #endif
        #ifdef __COMPILE_118
        else if (__choose3 == 13)
        {
        //AddInitKind
        memset(&self->abs_pos, 0, sizeof (*(&self->abs_pos)));
        }
        #endif
        #ifdef __COMPILE_119
        else if (__choose3 == 14)
        {
        //AddInitKind
        memset(&self->buffer, 0, sizeof (*(&self->buffer)));
        }
        #endif
        #ifdef __COMPILE_120
        else if (__choose3 == 15)
        {
        //AddInitKind
        memset(&self->buffer_mask, 0, sizeof (*(&self->buffer_mask)));
        }
        #endif
        #ifdef __COMPILE_121
        else if (__choose3 == 16)
        {
        //AddInitKind
        memset(&self->buffer_size, 0, sizeof (*(&self->buffer_size)));
        }
        #endif
        #ifdef __COMPILE_122
        else if (__choose3 == 17)
        {
        //AddInitKind
        memset(&self->deallocating, 0, sizeof (*(&self->deallocating)));
        }
        #endif
        #ifdef __COMPILE_123
        else if (__choose3 == 18)
        {
        //AddInitKind
        memset(&self->detached, 0, sizeof (*(&self->detached)));
        }
        #endif
        #ifdef __COMPILE_124
        else if (__choose3 == 19)
        {
        //AddInitKind
        memset(&self->dict, 0, sizeof (*(&self->dict)));
        }
        #endif
        #ifdef __COMPILE_125
        else if (__choose3 == 20)
        {
        //AddInitKind
        memset(&self->fast_closed_checks, 0, sizeof (*(&self->fast_closed_checks)));
        }
        #endif
        #ifdef __COMPILE_126
        else if (__choose3 == 21)
        {
        //AddInitKind
        memset(&self->lock, 0, sizeof (*(&self->lock)));
        }
        #endif
        #ifdef __COMPILE_127
        else if (__choose3 == 22)
        {
        //AddInitKind
        memset(&self->ob_base, 0, sizeof (*(&self->ob_base)));
        }
        #endif
        #ifdef __COMPILE_128
        else if (__choose3 == 23)
        {
        //AddInitKind
        memset(&self->ok, 0, sizeof (*(&self->ok)));
        }
        #endif
        #ifdef __COMPILE_129
        else if (__choose3 == 24)
        {
        //AddInitKind
        memset(&self->owner, 0, sizeof (*(&self->owner)));
        }
        #endif
        #ifdef __COMPILE_130
        else if (__choose3 == 25)
        {
        //AddInitKind
        memset(&self->pos, 0, sizeof (*(&self->pos)));
        }
        #endif
        #ifdef __COMPILE_131
        else if (__choose3 == 26)
        {
        //AddInitKind
        memset(&self->raw, 0, sizeof (*(&self->raw)));
        }
        #endif
        #ifdef __COMPILE_132
        else if (__choose3 == 27)
        {
        //AddInitKind
        memset(&self->raw_pos, 0, sizeof (*(&self->raw_pos)));
        }
        #endif
        #ifdef __COMPILE_133
        else if (__choose3 == 28)
        {
        //AddInitKind
        memset(&self->read_end, 0, sizeof (*(&self->read_end)));
        }
        #endif
        #ifdef __COMPILE_134
        else if (__choose3 == 29)
        {
        //AddInitKind
        memset(&self->readable, 0, sizeof (*(&self->readable)));
        }
        #endif
        #ifdef __COMPILE_135
        else if (__choose3 == 30)
        {
        //AddInitKind
        memset(&self->weakreflist, 0, sizeof (*(&self->weakreflist)));
        }
        #endif
        #ifdef __COMPILE_136
        else if (__choose3 == 31)
        {
        //AddInitKind
        memset(&self->writable, 0, sizeof (*(&self->writable)));
        }
        #endif
        #ifdef __COMPILE_137
        else if (__choose3 == 32)
        {
        //AddInitKind
        memset(&self->write_end, 0, sizeof (*(&self->write_end)));
        }
        #endif
        #ifdef __COMPILE_138
        else if (__choose3 == 33)
        {
        //AddInitKind
        memset(&self->write_pos, 0, sizeof (*(&self->write_pos)));
        }
        #endif
        #ifdef __COMPILE_139
        else if (__choose3 == 34)
        {
        //AddInitKind
        memset(buf.buf, 0, sizeof (*(buf.buf)));
        }
        #endif
        #ifdef __COMPILE_140
        else if (__choose3 == 35)
        {
        //AddInitKind
        memset(buf.format, 0, sizeof (*(buf.format)));
        }
        #endif
        #ifdef __COMPILE_141
        else if (__choose3 == 36)
        {
        //AddInitKind
        memset(buf.internal, 0, sizeof (*(buf.internal)));
        }
        #endif
        #ifdef __COMPILE_142
        else if (__choose3 == 37)
        {
        //AddInitKind
        memset(buf.obj, 0, sizeof (*(buf.obj)));
        }
        #endif
        #ifdef __COMPILE_143
        else if (__choose3 == 38)
        {
        //AddInitKind
        memset(buf.shape, 0, sizeof (*(buf.shape)));
        }
        #endif
        #ifdef __COMPILE_144
        else if (__choose3 == 39)
        {
        //AddInitKind
        memset(buf.strides, 0, sizeof (*(buf.strides)));
        }
        #endif
        #ifdef __COMPILE_145
        else if (__choose3 == 40)
        {
        //AddInitKind
        memset(buf.suboffsets, 0, sizeof (*(buf.suboffsets)));
        }
        #endif
        #ifdef __COMPILE_146
        else if (__choose3 == 41)
        {
        //AddInitKind
        memset(self->buffer, 0, sizeof (*(self->buffer)));
        }
        #endif
        #ifdef __COMPILE_147
        else if (__choose3 == 42)
        {
        //AddInitKind
        memset(self->dict, 0, sizeof (*(self->dict)));
        }
        #endif
        #ifdef __COMPILE_148
        else if (__choose3 == 43)
        {
        //AddInitKind
        memset(self->lock, 0, sizeof (*(self->lock)));
        }
        #endif
        #ifdef __COMPILE_149
        else if (__choose3 == 44)
        {
        //AddInitKind
        memset(self->raw, 0, sizeof (*(self->raw)));
        }
        #endif
        #ifdef __COMPILE_150
        else if (__choose3 == 45)
        {
        //AddInitKind
        memset(self->weakreflist, 0, sizeof (*(self->weakreflist)));
        }
        #endif
        #ifdef __COMPILE_151
        else if (__choose3 == 46)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_Format(PyExc_RuntimeError, "reentrant call inside %R", (self));
        }
        #endif
        #ifdef __COMPILE_152
        else if (__choose3 == 47)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "I/O operation on uninitialized object");
        }
        #endif
        #ifdef __COMPILE_153
        else if (__choose3 == 48)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "buffer size must be strictly positive");
        }
        #endif
        #ifdef __COMPILE_154
        else if (__choose3 == 49)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "can't allocate read lock");
        }
        #endif
        #ifdef __COMPILE_155
        else if (__choose3 == 50)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "flush of closed file");
        }
        #endif
        #ifdef __COMPILE_156
        else if (__choose3 == 51)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "raw stream has been detached");
        }
        #endif
        #ifdef __COMPILE_157
        else if (__choose3 == 52)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "read length must be positive or -1");
        }
        #endif
        #ifdef __COMPILE_158
        else if (__choose3 == 53)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "read length must be positive");
        }
        #endif
        #ifdef __COMPILE_159
        else if (__choose3 == 54)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "read of closed file");
        }
        #endif
        #ifdef __COMPILE_160
        else if (__choose3 == 55)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "read() should return bytes");
        }
        #endif
        #ifdef __COMPILE_161
        else if (__choose3 == 56)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "readline of closed file");
        }
        #endif
        #ifdef __COMPILE_162
        else if (__choose3 == 57)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "seek of closed file");
        }
        #endif
        #ifdef __COMPILE_163
        else if (__choose3 == 58)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((args), "write to closed file");
        }
        #endif
        #ifdef __COMPILE_164
        else if (__choose3 == 59)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "I/O operation on uninitialized object");
        }
        #endif
        #ifdef __COMPILE_165
        else if (__choose3 == 60)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "buffer size must be strictly positive");
        }
        #endif
        #ifdef __COMPILE_166
        else if (__choose3 == 61)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "can't allocate read lock");
        }
        #endif
        #ifdef __COMPILE_167
        else if (__choose3 == 62)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "flush of closed file");
        }
        #endif
        #ifdef __COMPILE_168
        else if (__choose3 == 63)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "raw stream has been detached");
        }
        #endif
        #ifdef __COMPILE_169
        else if (__choose3 == 64)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "read length must be positive or -1");
        }
        #endif
        #ifdef __COMPILE_170
        else if (__choose3 == 65)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "read length must be positive");
        }
        #endif
        #ifdef __COMPILE_171
        else if (__choose3 == 66)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "read of closed file");
        }
        #endif
        #ifdef __COMPILE_172
        else if (__choose3 == 67)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "read() should return bytes");
        }
        #endif
        #ifdef __COMPILE_173
        else if (__choose3 == 68)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "readline of closed file");
        }
        #endif
        #ifdef __COMPILE_174
        else if (__choose3 == 69)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "seek of closed file");
        }
        #endif
        #ifdef __COMPILE_175
        else if (__choose3 == 70)
        {
        //AddStmtAndReplaceAtomKind
        PyErr_SetString((res), "write to closed file");
        }
        #endif
        #ifdef __COMPILE_176
        else if (__choose3 == 71)
        {
        //AddStmtAndReplaceAtomKind
        PyMem_Free((self)->buffer);
        }
        #endif
        #ifdef __COMPILE_177
        else if (__choose3 == 72)
        {
        //AddStmtAndReplaceAtomKind
        PyThread_acquire_lock((self)->lock, 1);
        }
        #endif
        #ifdef __COMPILE_178
        else if (__choose3 == 73)
        {
        //AddStmtAndReplaceAtomKind
        PyThread_free_lock((self)->lock);
        }
        #endif
        #ifdef __COMPILE_179
        else if (__choose3 == 74)
        {
        //AddStmtAndReplaceAtomKind
        _bufferedreader_reset_buf((self));
        }
        #endif
        #ifdef __COMPILE_180
        else if (__choose3 == 75)
        {
        //AddStmtAndReplaceAtomKind
        _bufferedwriter_reset_buf((self));
        }
        #endif
        #ifdef __COMPILE_181
        else if (__choose3 == 76)
        {
        //AddStmtAndReplaceAtomKind
        memcpy((char *)buf.buf + written, (self)->buffer + self->pos, n);
        }
        #endif
        #ifdef __COMPILE_182
        else if (__choose3 == 77)
        {
        //AddStmtAndReplaceAtomKind
        memcpy((char *)buf.buf + written, self->buffer + (self)->pos, n);
        }
        #endif
        #ifdef __COMPILE_183
        else if (__choose3 == 78)
        {
        //AddStmtAndReplaceAtomKind
        memcpy(buf.buf, (self)->buffer + self->pos, buf.len);
        }
        #endif
        #ifdef __COMPILE_184
        else if (__choose3 == 79)
        {
        //AddStmtAndReplaceAtomKind
        memcpy(buf.buf, (self)->buffer + self->pos, n);
        }
        #endif
        #ifdef __COMPILE_185
        else if (__choose3 == 80)
        {
        //AddStmtAndReplaceAtomKind
        memcpy(buf.buf, self->buffer + (self)->pos, buf.len);
        }
        #endif
        #ifdef __COMPILE_186
        else if (__choose3 == 81)
        {
        //AddStmtAndReplaceAtomKind
        memcpy(buf.buf, self->buffer + (self)->pos, n);
        }
        #endif
        #ifdef __COMPILE_187
        else if (__choose3 == 82)
        {
        //AddStmtAndReplaceAtomKind
        n = (-1);
        }
        #endif
        #ifdef __COMPILE_188
        else if (__choose3 == 83)
        {
        //AddStmtAndReplaceAtomKind
        n = (-2);
        }
        #endif
        #ifdef __COMPILE_189
        else if (__choose3 == 84)
        {
        //AddStmtAndReplaceAtomKind
        n = (0);
        }
        #endif
        #ifdef __COMPILE_190
        else if (__choose3 == 85)
        {
        //AddStmtAndReplaceAtomKind
        n = (1);
        }
        #endif
        #ifdef __COMPILE_191
        else if (__choose3 == 86)
        {
        //AddStmtAndReplaceAtomKind
        n = (2);
        }
        #endif
        #ifdef __COMPILE_192
        else if (__choose3 == 87)
        {
        //AddStmtAndReplaceAtomKind
        n = (926);
        }
        #endif
        #ifdef __COMPILE_193
        else if (__choose3 == 88)
        {
        //AddStmtAndReplaceAtomKind
        n = (946);
        }
        #endif
        #ifdef __COMPILE_194
        else if (__choose3 == 89)
        {
        //AddStmtAndReplaceAtomKind
        n = (n);
        }
        #endif
        #ifdef __COMPILE_195
        else if (__choose3 == 90)
        {
        //AddStmtAndReplaceAtomKind
        n = (remaining);
        }
        #endif
        #ifdef __COMPILE_196
        else if (__choose3 == 91)
        {
        //AddStmtAndReplaceAtomKind
        n = (written);
        }
        #endif
        #ifdef __COMPILE_197
        else if (__choose3 == 92)
        {
        //AddStmtAndReplaceAtomKind
        n = _bufferedreader_fill_buffer((self));
        }
        #endif
        #ifdef __COMPILE_198
        else if (__choose3 == 93)
        {
        //AddStmtAndReplaceAtomKind
        n = _bufferedreader_raw_read((self), (char *)buf.buf + written, remaining);
        }
        #endif
        #ifdef __COMPILE_199
        else if (__choose3 == 94)
        {
        //AddStmtAndReplaceAtomKind
        res = (args);
        }
        #endif
        #ifdef __COMPILE_200
        else if (__choose3 == 95)
        {
        //AddStmtAndReplaceAtomKind
        res = (res);
        }
        #endif
        #ifdef __COMPILE_201
        else if (__choose3 == 96)
        {
        //AddStmtAndReplaceAtomKind
        res = _bufferedwriter_flush_unlocked((self), 0);
        }
        #endif
        #ifdef __COMPILE_202
        else if (__choose3 == 97)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (-1);
        }
        #endif
        #ifdef __COMPILE_203
        else if (__choose3 == 98)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (-2);
        }
        #endif
        #ifdef __COMPILE_204
        else if (__choose3 == 99)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (0);
        }
        #endif
        #ifdef __COMPILE_205
        else if (__choose3 == 100)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (1);
        }
        #endif
        #ifdef __COMPILE_206
        else if (__choose3 == 101)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (2);
        }
        #endif
        #ifdef __COMPILE_207
        else if (__choose3 == 102)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (926);
        }
        #endif
        #ifdef __COMPILE_208
        else if (__choose3 == 103)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (946);
        }
        #endif
        #ifdef __COMPILE_209
        else if (__choose3 == 104)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (n);
        }
        #endif
        #ifdef __COMPILE_210
        else if (__choose3 == 105)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (remaining);
        }
        #endif
        #ifdef __COMPILE_211
        else if (__choose3 == 106)
        {
        //AddStmtAndReplaceAtomKind
        self->pos = (written);
        }
        #endif
        #ifdef __COMPILE_212
        else if (__choose3 == 107)
        {
        //AddStmtAndReplaceAtomKind
        written = (-1);
        }
        #endif
        #ifdef __COMPILE_213
        else if (__choose3 == 108)
        {
        //AddStmtAndReplaceAtomKind
        written = (-2);
        }
        #endif
        #ifdef __COMPILE_214
        else if (__choose3 == 109)
        {
        //AddStmtAndReplaceAtomKind
        written = (0);
        }
        #endif
        #ifdef __COMPILE_215
        else if (__choose3 == 110)
        {
        //AddStmtAndReplaceAtomKind
        written = (1);
        }
        #endif
        #ifdef __COMPILE_216
        else if (__choose3 == 111)
        {
        //AddStmtAndReplaceAtomKind
        written = (2);
        }
        #endif
        #ifdef __COMPILE_217
        else if (__choose3 == 112)
        {
        //AddStmtAndReplaceAtomKind
        written = (926);
        }
        #endif
        #ifdef __COMPILE_218
        else if (__choose3 == 113)
        {
        //AddStmtAndReplaceAtomKind
        written = (946);
        }
        #endif
        #ifdef __COMPILE_219
        else if (__choose3 == 114)
        {
        //AddStmtAndReplaceAtomKind
        written = (n);
        }
        #endif
        #ifdef __COMPILE_220
        else if (__choose3 == 115)
        {
        //AddStmtAndReplaceAtomKind
        written = (remaining);
        }
        #endif
        #ifdef __COMPILE_221
        else if (__choose3 == 116)
        {
        //AddStmtAndReplaceAtomKind
        written = (written);
        }
        #endif
        #ifdef __COMPILE_222
        else if (__choose3 == 117)
        {
        //AddStmtKind
        (_Py_RefTotal++ , ((PyObject *)((&_Py_NoneStruct)))->ob_refcnt++);
        }
        #endif
        #ifdef __COMPILE_223
        else if (__choose3 == 118)
        {
        //AddStmtKind
        PyErr_Clear();
        }
        #endif
        #ifdef __COMPILE_224
        else if (__choose3 == 119)
        {
        //AddStmtKind
        PyErr_NoMemory();
        }
        #endif
        #ifdef __COMPILE_225
        else if (__choose3 == 120)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_RuntimeError, "can't allocate read lock");
        }
        #endif
        #ifdef __COMPILE_226
        else if (__choose3 == 121)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_TypeError, "read() should return bytes");
        }
        #endif
        #ifdef __COMPILE_227
        else if (__choose3 == 122)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "I/O operation on uninitialized object");
        }
        #endif
        #ifdef __COMPILE_228
        else if (__choose3 == 123)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "buffer size must be strictly positive");
        }
        #endif
        #ifdef __COMPILE_229
        else if (__choose3 == 124)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "flush of closed file");
        }
        #endif
        #ifdef __COMPILE_230
        else if (__choose3 == 125)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "raw stream has been detached");
        }
        #endif
        #ifdef __COMPILE_231
        else if (__choose3 == 126)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "read length must be positive or -1");
        }
        #endif
        #ifdef __COMPILE_232
        else if (__choose3 == 127)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "read length must be positive");
        }
        #endif
        #ifdef __COMPILE_233
        else if (__choose3 == 128)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "read of closed file");
        }
        #endif
        #ifdef __COMPILE_234
        else if (__choose3 == 129)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "readline of closed file");
        }
        #endif
        #ifdef __COMPILE_235
        else if (__choose3 == 130)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "seek of closed file");
        }
        #endif
        #ifdef __COMPILE_236
        else if (__choose3 == 131)
        {
        //AddStmtKind
        PyErr_SetString(PyExc_ValueError, "write to closed file");
        }
        #endif
        #ifdef __COMPILE_237
        else if (__choose3 == 132)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1004, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_238
        else if (__choose3 == 133)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1418, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_239
        else if (__choose3 == 134)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1484, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_240
        else if (__choose3 == 135)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1505, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_241
        else if (__choose3 == 136)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 1594, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_242
        else if (__choose3 == 137)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 884, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_243
        else if (__choose3 == 138)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 926, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_244
        else if (__choose3 == 139)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(n) == (n)", "Modules/_io/bufferedio.c", 1839, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_245
        else if (__choose3 == 140)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(self->buffer_size - self->pos) == (self->buffer_size - self->pos)", "Modules/_io/bufferedio.c", 1895, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_246
        else if (__choose3 == 141)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(self->buffer_size - self->write_end) == (self->buffer_size - self->write_end)", "Modules/_io/bufferedio.c", 1926, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_247
        else if (__choose3 == 142)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(self->read_end) == (self->read_end)", "Modules/_io/bufferedio.c", 1395, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_248
        else if (__choose3 == 143)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(self->write_end - self->write_pos) == (self->write_end - self->write_pos)", "Modules/_io/bufferedio.c", 1825, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_249
        else if (__choose3 == 144)
        {
        //AddStmtKind
        __assert_fail("(Py_off_t)(Py_ssize_t)(self->write_end - self->write_pos) == (self->write_end - self->write_pos)", "Modules/_io/bufferedio.c", 1920, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_250
        else if (__choose3 == 145)
        {
        //AddStmtKind
        __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 1459, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_251
        else if (__choose3 == 146)
        {
        //AddStmtKind
        __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 1471, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_252
        else if (__choose3 == 147)
        {
        //AddStmtKind
        __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 1473, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_253
        else if (__choose3 == 148)
        {
        //AddStmtKind
        __assert_fail("PyBytes_Check(data)", "Modules/_io/bufferedio.c", 58, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_254
        else if (__choose3 == 149)
        {
        //AddStmtKind
        __assert_fail("PyBytes_Check(line)", "Modules/_io/bufferedio.c", 1271, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_255
        else if (__choose3 == 150)
        {
        //AddStmtKind
        __assert_fail("PyBytes_Check(res)", "Modules/_io/bufferedio.c", 1512, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_256
        else if (__choose3 == 151)
        {
        //AddStmtKind
        __assert_fail("VALID_WRITE_BUFFER(self)", "Modules/_io/bufferedio.c", 1917, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_257
        else if (__choose3 == 152)
        {
        //AddStmtKind
        __assert_fail("eintr_int != NULL", "Modules/_io/bufferedio.c", 732, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_258
        else if (__choose3 == 153)
        {
        //AddStmtKind
        __assert_fail("env_err != NULL", "Modules/_io/bufferedio.c", 739, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_259
        else if (__choose3 == 154)
        {
        //AddStmtKind
        __assert_fail("remaining <= self->buffer_size", "Modules/_io/bufferedio.c", 1544, __extension__ __PRETTY_FUNCTION__);
        }
        #endif
        #ifdef __COMPILE_260
        else if (__choose3 == 155)
        {
        //AddStmtKind
        _bufferedreader_reset_buf(self);
        }
        #endif
        #ifdef __COMPILE_261
        else if (__choose3 == 156)
        {
        //AddStmtKind
        memcpy((char *)buf.buf + written, self->buffer + self->pos, n);
        }
        #endif
        #ifdef __COMPILE_262
        else if (__choose3 == 157)
        {
        //AddStmtKind
        memcpy(buf.buf, self->buffer + self->pos, buf.len);
        }
        #endif
        #ifdef __COMPILE_263
        else if (__choose3 == 158)
        {
        //AddStmtKind
        memcpy(buf.buf, self->buffer + self->pos, n);
        }
        #endif
        #ifdef __COMPILE_264
        else if (__choose3 == 159)
        {
        //AddStmtKind
        n = (((void)sizeof (((Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))) ? 1 : 0) , __extension__ ({
            if ((Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)))
                ;
            else
                __assert_fail("(Py_off_t)(Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)) == (((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0))", "Modules/_io/bufferedio.c", 926, __extension__ __PRETTY_FUNCTION__);
        })) , (Py_ssize_t)(((self->readable && (self->readable && self->read_end != -1)) ? (self->read_end - self->pos) : 0)));
        }
        #endif
        #ifdef __COMPILE_265
        else if (__choose3 == 160)
        {
        //AddStmtKind
        n = _bufferedreader_fill_buffer(self);
        }
        #endif
        #ifdef __COMPILE_266
        else if (__choose3 == 161)
        {
        //AddStmtKind
        n = _bufferedreader_raw_read(self, (char *)buf.buf + written, remaining);
        }
        #endif
        #ifdef __COMPILE_267
        else if (__choose3 == 162)
        {
        //AddStmtKind
        n = remaining;
        }
        #endif
        #ifdef __COMPILE_268
        else if (__choose3 == 163)
        {
        //AddStmtKind
        res = (&_Py_NoneStruct);
        }
        #endif
        #ifdef __COMPILE_269
        else if (__choose3 == 164)
        {
        //AddStmtKind
        res = PyLong_FromSsize_t(buf.len);
        }
        #endif
        #ifdef __COMPILE_270
        else if (__choose3 == 165)
        {
        //AddStmtKind
        res = PyLong_FromSsize_t(written);
        }
        #endif
        #ifdef __COMPILE_271
        else if (__choose3 == 166)
        {
        //AddStmtKind
        res = _bufferedwriter_flush_unlocked(self, 0);
        }
        #endif
        #ifdef __COMPILE_272
        else if (__choose3 == 167)
        {
        //AddStmtKind
        self->pos = 0;
        }
        #endif
        #ifdef __COMPILE_273
        else if (__choose3 == 168)
        {
        //AddStmtKind
        written = n;
        }
        #endif
        #ifdef __COMPILE_274
        else if (__choose3 == 169)
        {
        //IfExitKind
        if (__is_neg("3-169", "L946", 8, &(res), sizeof (res), &(_Py_RefTotal),
        			 sizeof (_Py_RefTotal), &(self), sizeof (self), &(written), sizeof (written), &(remaining),
        			 sizeof (remaining), &(n), sizeof (n), &(args), sizeof (args), &(PyExc_ValueError),
        			 sizeof (PyExc_ValueError)))
            goto end;
        }
        #endif
        #ifdef __COMPILE_275
        else if (__choose3 == 170)
        {
        //IfExitKind
        if (__is_neg("3-170", "L946", 8, &(res), sizeof (res), &(_Py_RefTotal),
        			 sizeof (_Py_RefTotal), &(self), sizeof (self), &(written), sizeof (written), &(remaining),
        			 sizeof (remaining), &(n), sizeof (n), &(args), sizeof (args), &(PyExc_ValueError),
        			 sizeof (PyExc_ValueError)))
            goto end_unlocked;
        }
        #endif
        #ifdef __COMPILE_276
        else if (__choose3 == 171)
        {
        //IfExitKind
        if (__is_neg("3-171", "L946", 8, &(res), sizeof (res), &(_Py_RefTotal),
        			 sizeof (_Py_RefTotal), &(self), sizeof (self), &(written), sizeof (written), &(remaining),
        			 sizeof (remaining), &(n), sizeof (n), &(args), sizeof (args), &(PyExc_ValueError),
        			 sizeof (PyExc_ValueError)))
            return 0;
        }
        #endif
        int __choose4 = __choose("__SWITCH4");
        if (__choose4 == 0)
        {
        Py_CLEAR(res);
        
        }
        #ifdef __COMPILE_277
        else if (__choose4 == 1)
        {
        //GuardKind
        if (!__is_neg("4-1", "L946", 8, &(res), sizeof (res), &(_Py_RefTotal), sizeof (_Py_RefTotal), &(self), sizeof (self), &(written), sizeof (written), &(remaining), sizeof (remaining), &(n), sizeof (n), &(args), sizeof (args), &(PyExc_ValueError), sizeof (PyExc_ValueError)))
            do {
                if (res) {
                    PyObject *_py_tmp = (PyObject *)(res);
                    (res) = ((void *)0);
                    do {
                        if (_Py_RefTotal-- , --((PyObject *)(_py_tmp))->ob_refcnt != 0) {
                            if (((PyObject *)_py_tmp)->ob_refcnt < 0)
                                _Py_NegativeRefcount("Modules/_io/bufferedio.c", 946, (PyObject *)(_py_tmp));
                        } else
                            _Py_Dealloc((PyObject *)(_py_tmp));
                    } while (0);
                }
            } while (0);
        
        }
        #endif
        }
    }

    _bufferedreader_reset_buf(self);
    self->pos = 0;

    for (remaining = buf.len - written;
         remaining > 0;
         written += n, remaining -= n) {
        /* If remaining bytes is larger than internal buffer size, copy
         * directly into caller's buffer. */
        if (remaining > self->buffer_size) {
            n = _bufferedreader_raw_read(self, (char *) buf.buf + written,
                                         remaining);
        }
        else {
            n = _bufferedreader_fill_buffer(self);
            if (n > 0) {
                if (n > remaining)
                    n = remaining;
                memcpy((char *) buf.buf + written,
                       self->buffer + self->pos, n);
                self->pos += n;
                continue; /* short circuit */
            }
        }
        if (n == 0 || (n == -2 && written > 0))
            break;
        if (n < 0) {
            if (n == -2) {
                Py_INCREF(Py_None);
                res = Py_None;
            }
            goto end;
        }
    }
    res = PyLong_FromSsize_t(written);

end:
    LEAVE_BUFFERED(self);
end_unlocked:
    PyBuffer_Release(&buf);
    return res;
}

static PyObject *
_buffered_readline(buffered *self, Py_ssize_t limit)
{
    PyObject *res = NULL;
    PyObject *chunks = NULL;
    Py_ssize_t n, written = 0;
    const char *start, *s, *end;

    CHECK_CLOSED(self, "readline of closed file")

    /* First, try to find a line in the buffer. This can run unlocked because
       the calls to the C API are simple enough that they can't trigger
       any thread switch. */
    n = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    if (limit >= 0 && n > limit)
        n = limit;
    start = self->buffer + self->pos;
    s = memchr(start, '\n', n);
    if (s != NULL) {
        res = PyBytes_FromStringAndSize(start, s - start + 1);
        if (res != NULL)
            self->pos += s - start + 1;
        goto end_unlocked;
    }
    if (n == limit) {
        res = PyBytes_FromStringAndSize(start, n);
        if (res != NULL)
            self->pos += n;
        goto end_unlocked;
    }

    if (!ENTER_BUFFERED(self))
        goto end_unlocked;

    /* Now we try to get some more from the raw stream */
    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 1);
        if (res == NULL)
            goto end;
        Py_CLEAR(res);
    }
    chunks = PyList_New(0);
    if (chunks == NULL)
        goto end;
    if (n > 0) {
        res = PyBytes_FromStringAndSize(start, n);
        if (res == NULL)
            goto end;
        if (PyList_Append(chunks, res) < 0) {
            Py_CLEAR(res);
            goto end;
        }
        Py_CLEAR(res);
        written += n;
        if (limit >= 0)
            limit -= n;
    }

    for (;;) {
        _bufferedreader_reset_buf(self);
        n = _bufferedreader_fill_buffer(self);
        if (n == -1)
            goto end;
        if (n <= 0)
            break;
        if (limit >= 0 && n > limit)
            n = limit;
        start = self->buffer;
        end = start + n;
        s = start;
        while (s < end) {
            if (*s++ == '\n') {
                res = PyBytes_FromStringAndSize(start, s - start);
                if (res == NULL)
                    goto end;
                self->pos = s - start;
                goto found;
            }
        }
        res = PyBytes_FromStringAndSize(start, n);
        if (res == NULL)
            goto end;
        if (n == limit) {
            self->pos = n;
            break;
        }
        if (PyList_Append(chunks, res) < 0) {
            Py_CLEAR(res);
            goto end;
        }
        Py_CLEAR(res);
        written += n;
        if (limit >= 0)
            limit -= n;
    }
found:
    if (res != NULL && PyList_Append(chunks, res) < 0) {
        Py_CLEAR(res);
        goto end;
    }
    Py_CLEAR(res);
    res = _PyBytes_Join(_PyIO_empty_bytes, chunks);

end:
    LEAVE_BUFFERED(self)
end_unlocked:
    Py_XDECREF(chunks);
    return res;
}

static PyObject *
buffered_readline(buffered *self, PyObject *args)
{
    Py_ssize_t limit = -1;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "|O&:readline", &_PyIO_ConvertSsize_t, &limit))
        return NULL;
    return _buffered_readline(self, limit);
}


static PyObject *
buffered_tell(buffered *self, PyObject *args)
{
    Py_off_t pos;

    CHECK_INITIALIZED(self)
    pos = _buffered_raw_tell(self);
    if (pos == -1)
        return NULL;
    pos -= RAW_OFFSET(self);
    /* TODO: sanity check (pos >= 0) */
    return PyLong_FromOff_t(pos);
}

static PyObject *
buffered_seek(buffered *self, PyObject *args)
{
    Py_off_t target, n;
    int whence = 0;
    PyObject *targetobj, *res = NULL;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "O|i:seek", &targetobj, &whence)) {
        return NULL;
    }
    if (whence < 0 || whence > 2) {
        PyErr_Format(PyExc_ValueError,
                     "whence must be between 0 and 2, not %d", whence);
        return NULL;
    }

    CHECK_CLOSED(self, "seek of closed file")

    target = PyNumber_AsOff_t(targetobj, PyExc_ValueError);
    if (target == -1 && PyErr_Occurred())
        return NULL;

    if (whence != 2 && self->readable) {
        Py_off_t current, avail;
        /* Check if seeking leaves us inside the current buffer,
           so as to return quickly if possible. Also, we needn't take the
           lock in this fast path.
           Don't know how to do that when whence == 2, though. */
        /* NOTE: RAW_TELL() can release the GIL but the object is in a stable
           state at this point. */
        current = RAW_TELL(self);
        avail = READAHEAD(self);
        if (avail > 0) {
            Py_off_t offset;
            if (whence == 0)
                offset = target - (current - RAW_OFFSET(self));
            else
                offset = target;
            if (offset >= -self->pos && offset <= avail) {
                self->pos += offset;
                return PyLong_FromOff_t(current - avail + offset);
            }
        }
    }

    if (!ENTER_BUFFERED(self))
        return NULL;

    /* Fallback: invoke raw seek() method and clear buffer */
    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 0);
        if (res == NULL)
            goto end;
        Py_CLEAR(res);
        _bufferedwriter_reset_buf(self);
    }

    /* TODO: align on block boundary and read buffer if needed? */
    if (whence == 1)
        target -= RAW_OFFSET(self);
    n = _buffered_raw_seek(self, target, whence);
    if (n == -1)
        goto end;
    self->raw_pos = -1;
    res = PyLong_FromOff_t(n);
    if (res != NULL && self->readable)
        _bufferedreader_reset_buf(self);

end:
    LEAVE_BUFFERED(self)
    return res;
}

static PyObject *
buffered_truncate(buffered *self, PyObject *args)
{
    PyObject *pos = Py_None;
    PyObject *res = NULL;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "|O:truncate", &pos)) {
        return NULL;
    }

    if (!ENTER_BUFFERED(self))
        return NULL;

    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 0);
        if (res == NULL)
            goto end;
        Py_CLEAR(res);
    }
    if (self->readable) {
        if (pos == Py_None) {
            /* Rewind the raw stream so that its position corresponds to
               the current logical position. */
            if (_buffered_raw_seek(self, -RAW_OFFSET(self), 1) == -1)
                goto end;
        }
        _bufferedreader_reset_buf(self);
    }
    res = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_truncate, pos, NULL);
    if (res == NULL)
        goto end;
    /* Reset cached position */
    if (_buffered_raw_tell(self) == -1)
        PyErr_Clear();

end:
    LEAVE_BUFFERED(self)
    return res;
}

static PyObject *
buffered_iternext(buffered *self)
{
    PyObject *line;
    PyTypeObject *tp;

    CHECK_INITIALIZED(self);

    tp = Py_TYPE(self);
    if (tp == &PyBufferedReader_Type ||
        tp == &PyBufferedRandom_Type) {
        /* Skip method call overhead for speed */
        line = _buffered_readline(self, -1);
    }
    else {
        line = PyObject_CallMethodObjArgs((PyObject *)self,
                                           _PyIO_str_readline, NULL);
        if (line && !PyBytes_Check(line)) {
            PyErr_Format(PyExc_IOError,
                         "readline() should have returned a bytes object, "
                         "not '%.200s'", Py_TYPE(line)->tp_name);
            Py_DECREF(line);
            return NULL;
        }
    }

    if (line == NULL)
        return NULL;

    if (PyBytes_GET_SIZE(line) == 0) {
        /* Reached EOF or would have blocked */
        Py_DECREF(line);
        return NULL;
    }

    return line;
}

static PyObject *
buffered_repr(buffered *self)
{
    PyObject *nameobj, *res;

    nameobj = PyObject_GetAttrString((PyObject *) self, "name");
    if (nameobj == NULL) {
        if (PyErr_ExceptionMatches(PyExc_AttributeError))
            PyErr_Clear();
        else
            return NULL;
        res = PyUnicode_FromFormat("<%s>", Py_TYPE(self)->tp_name);
    }
    else {
        res = PyUnicode_FromFormat("<%s name=%R>",
                                   Py_TYPE(self)->tp_name, nameobj);
        Py_DECREF(nameobj);
    }
    return res;
}

/*
 * class BufferedReader
 */

PyDoc_STRVAR(bufferedreader_doc,
             "Create a new buffered reader using the given readable raw IO object.");

static void _bufferedreader_reset_buf(buffered *self)
{
    self->read_end = -1;
}

static int
bufferedreader_init(buffered *self, PyObject *args, PyObject *kwds)
{
    char *kwlist[] = {"raw", "buffer_size", NULL};
    Py_ssize_t buffer_size = DEFAULT_BUFFER_SIZE;
    PyObject *raw;

    self->ok = 0;
    self->detached = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|n:BufferedReader", kwlist,
                                     &raw, &buffer_size)) {
        return -1;
    }

    if (_PyIOBase_check_readable(raw, Py_True) == NULL)
        return -1;

    Py_CLEAR(self->raw);
    Py_INCREF(raw);
    self->raw = raw;
    self->buffer_size = buffer_size;
    self->readable = 1;
    self->writable = 0;

    if (_buffered_init(self) < 0)
        return -1;
    _bufferedreader_reset_buf(self);

    self->fast_closed_checks = (Py_TYPE(self) == &PyBufferedReader_Type &&
                                Py_TYPE(raw) == &PyFileIO_Type);

    self->ok = 1;
    return 0;
}

static Py_ssize_t
_bufferedreader_raw_read(buffered *self, char *start, Py_ssize_t len)
{
    Py_buffer buf;
    PyObject *memobj, *res;
    Py_ssize_t n;
    /* NOTE: the buffer needn't be released as its object is NULL. */
    if (PyBuffer_FillInfo(&buf, NULL, start, len, 0, PyBUF_CONTIG) == -1)
        return -1;
    memobj = PyMemoryView_FromBuffer(&buf);
    if (memobj == NULL)
        return -1;
    /* NOTE: PyErr_SetFromErrno() calls PyErr_CheckSignals() when EINTR
       occurs so we needn't do it ourselves.
       We then retry reading, ignoring the signal if no handler has
       raised (see issue #10956).
    */
    do {
        res = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_readinto, memobj, NULL);
    } while (res == NULL && _trap_eintr());
    Py_DECREF(memobj);
    if (res == NULL)
        return -1;
    if (res == Py_None) {
        /* Non-blocking stream would have blocked. Special return code! */
        Py_DECREF(res);
        return -2;
    }
    n = PyNumber_AsSsize_t(res, PyExc_ValueError);
    Py_DECREF(res);
    if (n < 0 || n > len) {
        PyErr_Format(PyExc_IOError,
                     "raw readinto() returned invalid length %zd "
                     "(should have been between 0 and %zd)", n, len);
        return -1;
    }
    if (n > 0 && self->abs_pos != -1)
        self->abs_pos += n;
    return n;
}

static Py_ssize_t
_bufferedreader_fill_buffer(buffered *self)
{
    Py_ssize_t start, len, n;
    if (VALID_READ_BUFFER(self))
        start = Py_SAFE_DOWNCAST(self->read_end, Py_off_t, Py_ssize_t);
    else
        start = 0;
    len = self->buffer_size - start;
    n = _bufferedreader_raw_read(self, self->buffer + start, len);
    if (n <= 0)
        return n;
    self->read_end = start + n;
    self->raw_pos = start + n;
    return n;
}

static PyObject *
_bufferedreader_read_all(buffered *self)
{
    Py_ssize_t current_size;
    PyObject *res, *data = NULL;
    PyObject *chunks = PyList_New(0);

    if (chunks == NULL)
        return NULL;

    /* First copy what we have in the current buffer. */
    current_size = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    if (current_size) {
        data = PyBytes_FromStringAndSize(
            self->buffer + self->pos, current_size);
        if (data == NULL) {
            Py_DECREF(chunks);
            return NULL;
        }
    }
    _bufferedreader_reset_buf(self);
    /* We're going past the buffer's bounds, flush it */
    if (self->writable) {
        res = _bufferedwriter_flush_unlocked(self, 1);
        if (res == NULL) {
            Py_DECREF(chunks);
            return NULL;
        }
        Py_CLEAR(res);
    }
    while (1) {
        if (data) {
            if (PyList_Append(chunks, data) < 0) {
                Py_DECREF(data);
                Py_DECREF(chunks);
                return NULL;
            }
            Py_DECREF(data);
        }

        /* Read until EOF or until read() would block. */
        data = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_read, NULL);
        if (data == NULL) {
            Py_DECREF(chunks);
            return NULL;
        }
        if (data != Py_None && !PyBytes_Check(data)) {
            Py_DECREF(data);
            Py_DECREF(chunks);
            PyErr_SetString(PyExc_TypeError, "read() should return bytes");
            return NULL;
        }
        if (data == Py_None || PyBytes_GET_SIZE(data) == 0) {
            if (current_size == 0) {
                Py_DECREF(chunks);
                return data;
            }
            else {
                res = _PyBytes_Join(_PyIO_empty_bytes, chunks);
                Py_DECREF(data);
                Py_DECREF(chunks);
                return res;
            }
        }
        current_size += PyBytes_GET_SIZE(data);
        if (self->abs_pos != -1)
            self->abs_pos += PyBytes_GET_SIZE(data);
    }
}

/* Read n bytes from the buffer if it can, otherwise return None.
   This function is simple enough that it can run unlocked. */
static PyObject *
_bufferedreader_read_fast(buffered *self, Py_ssize_t n)
{
    Py_ssize_t current_size;

    current_size = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    if (n <= current_size) {
        /* Fast path: the data to read is fully buffered. */
        PyObject *res = PyBytes_FromStringAndSize(self->buffer + self->pos, n);
        if (res != NULL)
            self->pos += n;
        return res;
    }
    Py_RETURN_NONE;
}

/* Generic read function: read from the stream until enough bytes are read,
 * or until an EOF occurs or until read() would block.
 */
static PyObject *
_bufferedreader_read_generic(buffered *self, Py_ssize_t n)
{
    PyObject *res = NULL;
    Py_ssize_t current_size, remaining, written;
    char *out;

    current_size = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    if (n <= current_size)
        return _bufferedreader_read_fast(self, n);

    res = PyBytes_FromStringAndSize(NULL, n);
    if (res == NULL)
        goto error;
    out = PyBytes_AS_STRING(res);
    remaining = n;
    written = 0;
    if (current_size > 0) {
        memcpy(out, self->buffer + self->pos, current_size);
        remaining -= current_size;
        written += current_size;
    }
    _bufferedreader_reset_buf(self);
    while (remaining > 0) {
        /* We want to read a whole block at the end into buffer.
           If we had readv() we could do this in one pass. */
        Py_ssize_t r = MINUS_LAST_BLOCK(self, remaining);
        if (r == 0)
            break;
        r = _bufferedreader_raw_read(self, out + written, r);
        if (r == -1)
            goto error;
        if (r == 0 || r == -2) {
            /* EOF occurred or read() would block. */
            if (r == 0 || written > 0) {
                if (_PyBytes_Resize(&res, written))
                    goto error;
                return res;
            }
            Py_DECREF(res);
            Py_INCREF(Py_None);
            return Py_None;
        }
        remaining -= r;
        written += r;
    }
    assert(remaining <= self->buffer_size);
    self->pos = 0;
    self->raw_pos = 0;
    self->read_end = 0;
    /* NOTE: when the read is satisfied, we avoid issuing any additional
       reads, which could block indefinitely (e.g. on a socket).
       See issue #9550. */
    while (remaining > 0 && self->read_end < self->buffer_size) {
        Py_ssize_t r = _bufferedreader_fill_buffer(self);
        if (r == -1)
            goto error;
        if (r == 0 || r == -2) {
            /* EOF occurred or read() would block. */
            if (r == 0 || written > 0) {
                if (_PyBytes_Resize(&res, written))
                    goto error;
                return res;
            }
            Py_DECREF(res);
            Py_INCREF(Py_None);
            return Py_None;
        }
        if (remaining > r) {
            memcpy(out + written, self->buffer + self->pos, r);
            written += r;
            self->pos += r;
            remaining -= r;
        }
        else if (remaining > 0) {
            memcpy(out + written, self->buffer + self->pos, remaining);
            written += remaining;
            self->pos += remaining;
            remaining = 0;
        }
        if (remaining == 0)
            break;
    }

    return res;

error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
_bufferedreader_peek_unlocked(buffered *self, Py_ssize_t n)
{
    Py_ssize_t have, r;

    have = Py_SAFE_DOWNCAST(READAHEAD(self), Py_off_t, Py_ssize_t);
    /* Constraints:
       1. we don't want to advance the file position.
       2. we don't want to lose block alignment, so we can't shift the buffer
          to make some place.
       Therefore, we either return `have` bytes (if > 0), or a full buffer.
    */
    if (have > 0) {
        return PyBytes_FromStringAndSize(self->buffer + self->pos, have);
    }

    /* Fill the buffer from the raw stream, and copy it to the result. */
    _bufferedreader_reset_buf(self);
    r = _bufferedreader_fill_buffer(self);
    if (r == -1)
        return NULL;
    if (r == -2)
        r = 0;
    self->pos = 0;
    return PyBytes_FromStringAndSize(self->buffer, r);
}

static PyMethodDef bufferedreader_methods[] = {
    /* BufferedIOMixin methods */
    {"detach", (PyCFunction)buffered_detach, METH_NOARGS},
    {"flush", (PyCFunction)buffered_simple_flush, METH_NOARGS},
    {"close", (PyCFunction)buffered_close, METH_NOARGS},
    {"seekable", (PyCFunction)buffered_seekable, METH_NOARGS},
    {"readable", (PyCFunction)buffered_readable, METH_NOARGS},
    {"writable", (PyCFunction)buffered_writable, METH_NOARGS},
    {"fileno", (PyCFunction)buffered_fileno, METH_NOARGS},
    {"isatty", (PyCFunction)buffered_isatty, METH_NOARGS},
    {"_dealloc_warn", (PyCFunction)buffered_dealloc_warn, METH_O},
    {"__getstate__", (PyCFunction)buffered_getstate, METH_NOARGS},

    {"read", (PyCFunction)buffered_read, METH_VARARGS},
    {"peek", (PyCFunction)buffered_peek, METH_VARARGS},
    {"read1", (PyCFunction)buffered_read1, METH_VARARGS},
    {"readinto", (PyCFunction)buffered_readinto, METH_VARARGS},
    {"readline", (PyCFunction)buffered_readline, METH_VARARGS},
    {"seek", (PyCFunction)buffered_seek, METH_VARARGS},
    {"tell", (PyCFunction)buffered_tell, METH_NOARGS},
    {"truncate", (PyCFunction)buffered_truncate, METH_VARARGS},
    {NULL, NULL}
};

static PyMemberDef bufferedreader_members[] = {
    {"raw", T_OBJECT, offsetof(buffered, raw), READONLY},
    {NULL}
};

static PyGetSetDef bufferedreader_getset[] = {
    {"closed", (getter)buffered_closed_get, NULL, NULL},
    {"name", (getter)buffered_name_get, NULL, NULL},
    {"mode", (getter)buffered_mode_get, NULL, NULL},
    {NULL}
};


PyTypeObject PyBufferedReader_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "_io.BufferedReader",       /*tp_name*/
    sizeof(buffered),           /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    (destructor)buffered_dealloc,     /*tp_dealloc*/
    0,                          /*tp_print*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_compare */
    (reprfunc)buffered_repr,    /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash */
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
            | Py_TPFLAGS_HAVE_GC, /*tp_flags*/
    bufferedreader_doc,         /* tp_doc */
    (traverseproc)buffered_traverse, /* tp_traverse */
    (inquiry)buffered_clear,    /* tp_clear */
    0,                          /* tp_richcompare */
    offsetof(buffered, weakreflist), /*tp_weaklistoffset*/
    0,                          /* tp_iter */
    (iternextfunc)buffered_iternext, /* tp_iternext */
    bufferedreader_methods,     /* tp_methods */
    bufferedreader_members,     /* tp_members */
    bufferedreader_getset,      /* tp_getset */
    0,                          /* tp_base */
    0,                          /* tp_dict */
    0,                          /* tp_descr_get */
    0,                          /* tp_descr_set */
    offsetof(buffered, dict), /* tp_dictoffset */
    (initproc)bufferedreader_init, /* tp_init */
    0,                          /* tp_alloc */
    PyType_GenericNew,          /* tp_new */
};



static int
complain_about_max_buffer_size(void)
{
    if (PyErr_WarnEx(PyExc_DeprecationWarning,
                     "max_buffer_size is deprecated", 1) < 0)
        return 0;
    return 1;
}

/*
 * class BufferedWriter
 */
PyDoc_STRVAR(bufferedwriter_doc,
    "A buffer for a writeable sequential RawIO object.\n"
    "\n"
    "The constructor creates a BufferedWriter for the given writeable raw\n"
    "stream. If the buffer_size is not given, it defaults to\n"
    "DEFAULT_BUFFER_SIZE. max_buffer_size isn't used anymore.\n"
    );

static void
_bufferedwriter_reset_buf(buffered *self)
{
    self->write_pos = 0;
    self->write_end = -1;
}

static int
bufferedwriter_init(buffered *self, PyObject *args, PyObject *kwds)
{
    /* TODO: properly deprecate max_buffer_size */
    char *kwlist[] = {"raw", "buffer_size", "max_buffer_size", NULL};
    Py_ssize_t buffer_size = DEFAULT_BUFFER_SIZE;
    Py_ssize_t max_buffer_size = -234;
    PyObject *raw;

    self->ok = 0;
    self->detached = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|nn:BufferedReader", kwlist,
                                     &raw, &buffer_size, &max_buffer_size)) {
        return -1;
    }

    if (max_buffer_size != -234 && !complain_about_max_buffer_size())
        return -1;

    if (_PyIOBase_check_writable(raw, Py_True) == NULL)
        return -1;

    Py_CLEAR(self->raw);
    Py_INCREF(raw);
    self->raw = raw;
    self->readable = 0;
    self->writable = 1;

    self->buffer_size = buffer_size;
    if (_buffered_init(self) < 0)
        return -1;
    _bufferedwriter_reset_buf(self);
    self->pos = 0;

    self->fast_closed_checks = (Py_TYPE(self) == &PyBufferedWriter_Type &&
                                Py_TYPE(raw) == &PyFileIO_Type);

    self->ok = 1;
    return 0;
}

static Py_ssize_t
_bufferedwriter_raw_write(buffered *self, char *start, Py_ssize_t len)
{
    Py_buffer buf;
    PyObject *memobj, *res;
    Py_ssize_t n;
    /* NOTE: the buffer needn't be released as its object is NULL. */
    if (PyBuffer_FillInfo(&buf, NULL, start, len, 1, PyBUF_CONTIG_RO) == -1)
        return -1;
    memobj = PyMemoryView_FromBuffer(&buf);
    if (memobj == NULL)
        return -1;
    /* NOTE: PyErr_SetFromErrno() calls PyErr_CheckSignals() when EINTR
       occurs so we needn't do it ourselves.
       We then retry writing, ignoring the signal if no handler has
       raised (see issue #10956).
    */
    do {
        res = PyObject_CallMethodObjArgs(self->raw, _PyIO_str_write, memobj, NULL);
    } while (res == NULL && _trap_eintr());
    Py_DECREF(memobj);
    if (res == NULL)
        return -1;
    n = PyNumber_AsSsize_t(res, PyExc_ValueError);
    Py_DECREF(res);
    if (n < 0 || n > len) {
        PyErr_Format(PyExc_IOError,
                     "raw write() returned invalid length %zd "
                     "(should have been between 0 and %zd)", n, len);
        return -1;
    }
    if (n > 0 && self->abs_pos != -1)
        self->abs_pos += n;
    return n;
}

/* `restore_pos` is 1 if we need to restore the raw stream position at
   the end, 0 otherwise. */
static PyObject *
_bufferedwriter_flush_unlocked(buffered *self, int restore_pos)
{
    Py_ssize_t written = 0;
    Py_off_t n, rewind;

    if (!VALID_WRITE_BUFFER(self) || self->write_pos == self->write_end)
        goto end;
    /* First, rewind */
    rewind = RAW_OFFSET(self) + (self->pos - self->write_pos);
    if (rewind != 0) {
        n = _buffered_raw_seek(self, -rewind, 1);
        if (n < 0) {
            goto error;
        }
        self->raw_pos -= rewind;
    }
    while (self->write_pos < self->write_end) {
        n = _bufferedwriter_raw_write(self,
            self->buffer + self->write_pos,
            Py_SAFE_DOWNCAST(self->write_end - self->write_pos,
                             Py_off_t, Py_ssize_t));
        if (n == -1) {
            Py_ssize_t *w = _buffered_check_blocking_error();
            if (w == NULL)
                goto error;
            self->write_pos += *w;
            self->raw_pos = self->write_pos;
            written += *w;
            *w = written;
            /* Already re-raised */
            goto error;
        }
        self->write_pos += n;
        self->raw_pos = self->write_pos;
        written += Py_SAFE_DOWNCAST(n, Py_off_t, Py_ssize_t);
        /* Partial writes can return successfully when interrupted by a
           signal (see write(2)).  We must run signal handlers before
           blocking another time, possibly indefinitely. */
        if (PyErr_CheckSignals() < 0)
            goto error;
    }

    if (restore_pos) {
        Py_off_t forward = rewind - written;
        if (forward != 0) {
            n = _buffered_raw_seek(self, forward, 1);
            if (n < 0) {
                goto error;
            }
            self->raw_pos += forward;
        }
    }
    _bufferedwriter_reset_buf(self);

end:
    Py_RETURN_NONE;

error:
    return NULL;
}

static PyObject *
bufferedwriter_write(buffered *self, PyObject *args)
{
    PyObject *res = NULL;
    Py_buffer buf;
    Py_ssize_t written, avail, remaining;
    Py_off_t offset;

    CHECK_INITIALIZED(self)
    if (!PyArg_ParseTuple(args, "y*:write", &buf)) {
        return NULL;
    }

    if (IS_CLOSED(self)) {
        PyErr_SetString(PyExc_ValueError, "write to closed file");
        PyBuffer_Release(&buf);
        return NULL;
    }

    if (!ENTER_BUFFERED(self)) {
        PyBuffer_Release(&buf);
        return NULL;
    }

    /* Fast path: the data to write can be fully buffered. */
    if (!VALID_READ_BUFFER(self) && !VALID_WRITE_BUFFER(self)) {
        self->pos = 0;
        self->raw_pos = 0;
    }
    avail = Py_SAFE_DOWNCAST(self->buffer_size - self->pos, Py_off_t, Py_ssize_t);
    if (buf.len <= avail) {
        memcpy(self->buffer + self->pos, buf.buf, buf.len);
        if (!VALID_WRITE_BUFFER(self)) {
            self->write_pos = self->pos;
        }
        ADJUST_POSITION(self, self->pos + buf.len);
        if (self->pos > self->write_end)
            self->write_end = self->pos;
        written = buf.len;
        goto end;
    }

    /* First write the current buffer */
    res = _bufferedwriter_flush_unlocked(self, 0);
    if (res == NULL) {
        Py_ssize_t *w = _buffered_check_blocking_error();
        if (w == NULL)
            goto error;
        if (self->readable)
            _bufferedreader_reset_buf(self);
        /* Make some place by shifting the buffer. */
        assert(VALID_WRITE_BUFFER(self));
        memmove(self->buffer, self->buffer + self->write_pos,
                Py_SAFE_DOWNCAST(self->write_end - self->write_pos,
                                 Py_off_t, Py_ssize_t));
        self->write_end -= self->write_pos;
        self->raw_pos -= self->write_pos;
        self->pos -= self->write_pos;
        self->write_pos = 0;
        avail = Py_SAFE_DOWNCAST(self->buffer_size - self->write_end,
                                 Py_off_t, Py_ssize_t);
        if (buf.len <= avail) {
            /* Everything can be buffered */
            PyErr_Clear();
            memcpy(self->buffer + self->write_end, buf.buf, buf.len);
            self->write_end += buf.len;
            written = buf.len;
            goto end;
        }
        /* Buffer as much as possible. */
        memcpy(self->buffer + self->write_end, buf.buf, avail);
        self->write_end += avail;
        /* Already re-raised */
        *w = avail;
        goto error;
    }
    Py_CLEAR(res);

    /* Adjust the raw stream position if it is away from the logical stream
       position. This happens if the read buffer has been filled but not
       modified (and therefore _bufferedwriter_flush_unlocked() didn't rewind
       the raw stream by itself).
       Fixes issue #6629.
    */
    offset = RAW_OFFSET(self);
    if (offset != 0) {
        if (_buffered_raw_seek(self, -offset, 1) < 0)
            goto error;
        self->raw_pos -= offset;
    }

    /* Then write buf itself. At this point the buffer has been emptied. */
    remaining = buf.len;
    written = 0;
    while (remaining > self->buffer_size) {
        Py_ssize_t n = _bufferedwriter_raw_write(
            self, (char *) buf.buf + written, buf.len - written);
        if (n == -1) {
            Py_ssize_t *w = _buffered_check_blocking_error();
            if (w == NULL)
                goto error;
            written += *w;
            remaining -= *w;
            if (remaining > self->buffer_size) {
                /* Can't buffer everything, still buffer as much as possible */
                memcpy(self->buffer,
                       (char *) buf.buf + written, self->buffer_size);
                self->raw_pos = 0;
                ADJUST_POSITION(self, self->buffer_size);
                self->write_end = self->buffer_size;
                *w = written + self->buffer_size;
                /* Already re-raised */
                goto error;
            }
            PyErr_Clear();
            break;
        }
        written += n;
        remaining -= n;
        /* Partial writes can return successfully when interrupted by a
           signal (see write(2)).  We must run signal handlers before
           blocking another time, possibly indefinitely. */
        if (PyErr_CheckSignals() < 0)
            goto error;
    }
    if (self->readable)
        _bufferedreader_reset_buf(self);
    if (remaining > 0) {
        memcpy(self->buffer, (char *) buf.buf + written, remaining);
        written += remaining;
    }
    self->write_pos = 0;
    /* TODO: sanity check (remaining >= 0) */
    self->write_end = remaining;
    ADJUST_POSITION(self, remaining);
    self->raw_pos = 0;

end:
    res = PyLong_FromSsize_t(written);

error:
    LEAVE_BUFFERED(self)
    PyBuffer_Release(&buf);
    return res;
}

static PyMethodDef bufferedwriter_methods[] = {
    /* BufferedIOMixin methods */
    {"close", (PyCFunction)buffered_close, METH_NOARGS},
    {"detach", (PyCFunction)buffered_detach, METH_NOARGS},
    {"seekable", (PyCFunction)buffered_seekable, METH_NOARGS},
    {"readable", (PyCFunction)buffered_readable, METH_NOARGS},
    {"writable", (PyCFunction)buffered_writable, METH_NOARGS},
    {"fileno", (PyCFunction)buffered_fileno, METH_NOARGS},
    {"isatty", (PyCFunction)buffered_isatty, METH_NOARGS},
    {"_dealloc_warn", (PyCFunction)buffered_dealloc_warn, METH_O},
    {"__getstate__", (PyCFunction)buffered_getstate, METH_NOARGS},

    {"write", (PyCFunction)bufferedwriter_write, METH_VARARGS},
    {"truncate", (PyCFunction)buffered_truncate, METH_VARARGS},
    {"flush", (PyCFunction)buffered_flush, METH_NOARGS},
    {"seek", (PyCFunction)buffered_seek, METH_VARARGS},
    {"tell", (PyCFunction)buffered_tell, METH_NOARGS},
    {NULL, NULL}
};

static PyMemberDef bufferedwriter_members[] = {
    {"raw", T_OBJECT, offsetof(buffered, raw), READONLY},
    {NULL}
};

static PyGetSetDef bufferedwriter_getset[] = {
    {"closed", (getter)buffered_closed_get, NULL, NULL},
    {"name", (getter)buffered_name_get, NULL, NULL},
    {"mode", (getter)buffered_mode_get, NULL, NULL},
    {NULL}
};


PyTypeObject PyBufferedWriter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "_io.BufferedWriter",       /*tp_name*/
    sizeof(buffered),           /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    (destructor)buffered_dealloc,     /*tp_dealloc*/
    0,                          /*tp_print*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_compare */
    (reprfunc)buffered_repr,    /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash */
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        | Py_TPFLAGS_HAVE_GC,   /*tp_flags*/
    bufferedwriter_doc,         /* tp_doc */
    (traverseproc)buffered_traverse, /* tp_traverse */
    (inquiry)buffered_clear,    /* tp_clear */
    0,                          /* tp_richcompare */
    offsetof(buffered, weakreflist), /*tp_weaklistoffset*/
    0,                          /* tp_iter */
    0,                          /* tp_iternext */
    bufferedwriter_methods,     /* tp_methods */
    bufferedwriter_members,     /* tp_members */
    bufferedwriter_getset,      /* tp_getset */
    0,                          /* tp_base */
    0,                          /* tp_dict */
    0,                          /* tp_descr_get */
    0,                          /* tp_descr_set */
    offsetof(buffered, dict),   /* tp_dictoffset */
    (initproc)bufferedwriter_init, /* tp_init */
    0,                          /* tp_alloc */
    PyType_GenericNew,          /* tp_new */
};



/*
 * BufferedRWPair
 */

PyDoc_STRVAR(bufferedrwpair_doc,
    "A buffered reader and writer object together.\n"
    "\n"
    "A buffered reader object and buffered writer object put together to\n"
    "form a sequential IO object that can read and write. This is typically\n"
    "used with a socket or two-way pipe.\n"
    "\n"
    "reader and writer are RawIOBase objects that are readable and\n"
    "writeable respectively. If the buffer_size is omitted it defaults to\n"
    "DEFAULT_BUFFER_SIZE.\n"
    );

/* XXX The usefulness of this (compared to having two separate IO objects) is
 * questionable.
 */

typedef struct {
    PyObject_HEAD
    buffered *reader;
    buffered *writer;
    PyObject *dict;
    PyObject *weakreflist;
} rwpair;

static int
bufferedrwpair_init(rwpair *self, PyObject *args, PyObject *kwds)
{
    PyObject *reader, *writer;
    Py_ssize_t buffer_size = DEFAULT_BUFFER_SIZE;
    Py_ssize_t max_buffer_size = -234;

    if (!PyArg_ParseTuple(args, "OO|nn:BufferedRWPair", &reader, &writer,
                          &buffer_size, &max_buffer_size)) {
        return -1;
    }

    if (max_buffer_size != -234 && !complain_about_max_buffer_size())
        return -1;

    if (_PyIOBase_check_readable(reader, Py_True) == NULL)
        return -1;
    if (_PyIOBase_check_writable(writer, Py_True) == NULL)
        return -1;

    self->reader = (buffered *) PyObject_CallFunction(
            (PyObject *) &PyBufferedReader_Type, "On", reader, buffer_size);
    if (self->reader == NULL)
        return -1;

    self->writer = (buffered *) PyObject_CallFunction(
            (PyObject *) &PyBufferedWriter_Type, "On", writer, buffer_size);
    if (self->writer == NULL) {
        Py_CLEAR(self->reader);
        return -1;
    }

    return 0;
}

static int
bufferedrwpair_traverse(rwpair *self, visitproc visit, void *arg)
{
    Py_VISIT(self->dict);
    return 0;
}

static int
bufferedrwpair_clear(rwpair *self)
{
    Py_CLEAR(self->reader);
    Py_CLEAR(self->writer);
    Py_CLEAR(self->dict);
    return 0;
}

static void
bufferedrwpair_dealloc(rwpair *self)
{
    _PyObject_GC_UNTRACK(self);
    Py_CLEAR(self->reader);
    Py_CLEAR(self->writer);
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free((PyObject *) self);
}

static PyObject *
_forward_call(buffered *self, const char *name, PyObject *args)
{
    PyObject *func = PyObject_GetAttrString((PyObject *)self, name);
    PyObject *ret;

    if (func == NULL) {
        PyErr_SetString(PyExc_AttributeError, name);
        return NULL;
    }

    ret = PyObject_CallObject(func, args);
    Py_DECREF(func);
    return ret;
}

static PyObject *
bufferedrwpair_read(rwpair *self, PyObject *args)
{
    return _forward_call(self->reader, "read", args);
}

static PyObject *
bufferedrwpair_peek(rwpair *self, PyObject *args)
{
    return _forward_call(self->reader, "peek", args);
}

static PyObject *
bufferedrwpair_read1(rwpair *self, PyObject *args)
{
    return _forward_call(self->reader, "read1", args);
}

static PyObject *
bufferedrwpair_readinto(rwpair *self, PyObject *args)
{
    return _forward_call(self->reader, "readinto", args);
}

static PyObject *
bufferedrwpair_write(rwpair *self, PyObject *args)
{
    return _forward_call(self->writer, "write", args);
}

static PyObject *
bufferedrwpair_flush(rwpair *self, PyObject *args)
{
    return _forward_call(self->writer, "flush", args);
}

static PyObject *
bufferedrwpair_readable(rwpair *self, PyObject *args)
{
    return _forward_call(self->reader, "readable", args);
}

static PyObject *
bufferedrwpair_writable(rwpair *self, PyObject *args)
{
    return _forward_call(self->writer, "writable", args);
}

static PyObject *
bufferedrwpair_close(rwpair *self, PyObject *args)
{
    PyObject *ret = _forward_call(self->writer, "close", args);
    if (ret == NULL)
        return NULL;
    Py_DECREF(ret);

    return _forward_call(self->reader, "close", args);
}

static PyObject *
bufferedrwpair_isatty(rwpair *self, PyObject *args)
{
    PyObject *ret = _forward_call(self->writer, "isatty", args);

    if (ret != Py_False) {
        /* either True or exception */
        return ret;
    }
    Py_DECREF(ret);

    return _forward_call(self->reader, "isatty", args);
}

static PyObject *
bufferedrwpair_closed_get(rwpair *self, void *context)
{
    return PyObject_GetAttr((PyObject *) self->writer, _PyIO_str_closed);
}

static PyMethodDef bufferedrwpair_methods[] = {
    {"read", (PyCFunction)bufferedrwpair_read, METH_VARARGS},
    {"peek", (PyCFunction)bufferedrwpair_peek, METH_VARARGS},
    {"read1", (PyCFunction)bufferedrwpair_read1, METH_VARARGS},
    {"readinto", (PyCFunction)bufferedrwpair_readinto, METH_VARARGS},

    {"write", (PyCFunction)bufferedrwpair_write, METH_VARARGS},
    {"flush", (PyCFunction)bufferedrwpair_flush, METH_NOARGS},

    {"readable", (PyCFunction)bufferedrwpair_readable, METH_NOARGS},
    {"writable", (PyCFunction)bufferedrwpair_writable, METH_NOARGS},

    {"close", (PyCFunction)bufferedrwpair_close, METH_NOARGS},
    {"isatty", (PyCFunction)bufferedrwpair_isatty, METH_NOARGS},

    {"__getstate__", (PyCFunction)buffered_getstate, METH_NOARGS},

    {NULL, NULL}
};

static PyGetSetDef bufferedrwpair_getset[] = {
    {"closed", (getter)bufferedrwpair_closed_get, NULL, NULL},
    {NULL}
};

PyTypeObject PyBufferedRWPair_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "_io.BufferedRWPair",       /*tp_name*/
    sizeof(rwpair),            /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    (destructor)bufferedrwpair_dealloc,     /*tp_dealloc*/
    0,                          /*tp_print*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_compare */
    0,                          /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash */
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        | Py_TPFLAGS_HAVE_GC,   /* tp_flags */
    bufferedrwpair_doc,         /* tp_doc */
    (traverseproc)bufferedrwpair_traverse, /* tp_traverse */
    (inquiry)bufferedrwpair_clear, /* tp_clear */
    0,                          /* tp_richcompare */
    offsetof(rwpair, weakreflist), /*tp_weaklistoffset*/
    0,                          /* tp_iter */
    0,                          /* tp_iternext */
    bufferedrwpair_methods,     /* tp_methods */
    0,                          /* tp_members */
    bufferedrwpair_getset,      /* tp_getset */
    0,                          /* tp_base */
    0,                          /* tp_dict */
    0,                          /* tp_descr_get */
    0,                          /* tp_descr_set */
    offsetof(rwpair, dict),     /* tp_dictoffset */
    (initproc)bufferedrwpair_init, /* tp_init */
    0,                          /* tp_alloc */
    PyType_GenericNew,          /* tp_new */
};



/*
 * BufferedRandom
 */

PyDoc_STRVAR(bufferedrandom_doc,
    "A buffered interface to random access streams.\n"
    "\n"
    "The constructor creates a reader and writer for a seekable stream,\n"
    "raw, given in the first argument. If the buffer_size is omitted it\n"
    "defaults to DEFAULT_BUFFER_SIZE. max_buffer_size isn't used anymore.\n"
    );

static int
bufferedrandom_init(buffered *self, PyObject *args, PyObject *kwds)
{
    char *kwlist[] = {"raw", "buffer_size", "max_buffer_size", NULL};
    Py_ssize_t buffer_size = DEFAULT_BUFFER_SIZE;
    Py_ssize_t max_buffer_size = -234;
    PyObject *raw;

    self->ok = 0;
    self->detached = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|nn:BufferedReader", kwlist,
                                     &raw, &buffer_size, &max_buffer_size)) {
        return -1;
    }

    if (max_buffer_size != -234 && !complain_about_max_buffer_size())
        return -1;

    if (_PyIOBase_check_seekable(raw, Py_True) == NULL)
        return -1;
    if (_PyIOBase_check_readable(raw, Py_True) == NULL)
        return -1;
    if (_PyIOBase_check_writable(raw, Py_True) == NULL)
        return -1;

    Py_CLEAR(self->raw);
    Py_INCREF(raw);
    self->raw = raw;
    self->buffer_size = buffer_size;
    self->readable = 1;
    self->writable = 1;

    if (_buffered_init(self) < 0)
        return -1;
    _bufferedreader_reset_buf(self);
    _bufferedwriter_reset_buf(self);
    self->pos = 0;

    self->fast_closed_checks = (Py_TYPE(self) == &PyBufferedRandom_Type &&
                                Py_TYPE(raw) == &PyFileIO_Type);

    self->ok = 1;
    return 0;
}

static PyMethodDef bufferedrandom_methods[] = {
    /* BufferedIOMixin methods */
    {"close", (PyCFunction)buffered_close, METH_NOARGS},
    {"detach", (PyCFunction)buffered_detach, METH_NOARGS},
    {"seekable", (PyCFunction)buffered_seekable, METH_NOARGS},
    {"readable", (PyCFunction)buffered_readable, METH_NOARGS},
    {"writable", (PyCFunction)buffered_writable, METH_NOARGS},
    {"fileno", (PyCFunction)buffered_fileno, METH_NOARGS},
    {"isatty", (PyCFunction)buffered_isatty, METH_NOARGS},
    {"_dealloc_warn", (PyCFunction)buffered_dealloc_warn, METH_O},
    {"__getstate__", (PyCFunction)buffered_getstate, METH_NOARGS},

    {"flush", (PyCFunction)buffered_flush, METH_NOARGS},

    {"seek", (PyCFunction)buffered_seek, METH_VARARGS},
    {"tell", (PyCFunction)buffered_tell, METH_NOARGS},
    {"truncate", (PyCFunction)buffered_truncate, METH_VARARGS},
    {"read", (PyCFunction)buffered_read, METH_VARARGS},
    {"read1", (PyCFunction)buffered_read1, METH_VARARGS},
    {"readinto", (PyCFunction)buffered_readinto, METH_VARARGS},
    {"readline", (PyCFunction)buffered_readline, METH_VARARGS},
    {"peek", (PyCFunction)buffered_peek, METH_VARARGS},
    {"write", (PyCFunction)bufferedwriter_write, METH_VARARGS},
    {NULL, NULL}
};

static PyMemberDef bufferedrandom_members[] = {
    {"raw", T_OBJECT, offsetof(buffered, raw), READONLY},
    {NULL}
};

static PyGetSetDef bufferedrandom_getset[] = {
    {"closed", (getter)buffered_closed_get, NULL, NULL},
    {"name", (getter)buffered_name_get, NULL, NULL},
    {"mode", (getter)buffered_mode_get, NULL, NULL},
    {NULL}
};


PyTypeObject PyBufferedRandom_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "_io.BufferedRandom",       /*tp_name*/
    sizeof(buffered),           /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    (destructor)buffered_dealloc,     /*tp_dealloc*/
    0,                          /*tp_print*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_compare */
    (reprfunc)buffered_repr,    /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash */
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        | Py_TPFLAGS_HAVE_GC,   /*tp_flags*/
    bufferedrandom_doc,         /* tp_doc */
    (traverseproc)buffered_traverse, /* tp_traverse */
    (inquiry)buffered_clear,    /* tp_clear */
    0,                          /* tp_richcompare */
    offsetof(buffered, weakreflist), /*tp_weaklistoffset*/
    0,                          /* tp_iter */
    (iternextfunc)buffered_iternext, /* tp_iternext */
    bufferedrandom_methods,     /* tp_methods */
    bufferedrandom_members,     /* tp_members */
    bufferedrandom_getset,      /* tp_getset */
    0,                          /* tp_base */
    0,                          /*tp_dict*/
    0,                          /* tp_descr_get */
    0,                          /* tp_descr_set */
    offsetof(buffered, dict), /*tp_dictoffset*/
    (initproc)bufferedrandom_init, /* tp_init */
    0,                          /* tp_alloc */
    PyType_GenericNew,          /* tp_new */
};
