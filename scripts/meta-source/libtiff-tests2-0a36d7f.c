#define __COMPILE_0
#define __COMPILE_1
#define __COMPILE_2
#define __COMPILE_3
#define __COMPILE_4
#define __COMPILE_5
#define __COMPILE_6
#define __COMPILE_7
#define __COMPILE_8
#define __COMPILE_9
#define __COMPILE_10
#define __COMPILE_11
#define __COMPILE_12
#define __COMPILE_13
#define __COMPILE_14
#define __COMPILE_15
#define __COMPILE_16
#define __COMPILE_17
#define __COMPILE_18
#define __COMPILE_19
#define __COMPILE_20
#define __COMPILE_21
#define __COMPILE_22
#define __COMPILE_23
#define __COMPILE_24
#define __COMPILE_25
#define __COMPILE_26
#define __COMPILE_27
#define __COMPILE_28
#define __COMPILE_29
#define __COMPILE_30
#define __COMPILE_31
#define __COMPILE_32
#define __COMPILE_33
#define __COMPILE_34
#define __COMPILE_35
#define __COMPILE_36
#define __COMPILE_37
#define __COMPILE_38
#define __COMPILE_39
#define __COMPILE_40
#define __COMPILE_41
#define __COMPILE_42
#define __COMPILE_43
#define __COMPILE_44
#define __COMPILE_45
#define __COMPILE_46
#define __COMPILE_47
#define __COMPILE_48
#define __COMPILE_49
#define __COMPILE_50
#define __COMPILE_51
#define __COMPILE_52
#define __COMPILE_53
#define __COMPILE_54
#define __COMPILE_55
#define __COMPILE_56
#define __COMPILE_57
#define __COMPILE_58
#define __COMPILE_59
#define __COMPILE_60
#define __COMPILE_61
#define __COMPILE_62
#define __COMPILE_63
#define __COMPILE_64
#define __COMPILE_65
#define __COMPILE_66
#define __COMPILE_67
#define __COMPILE_68
#define __COMPILE_69
#define __COMPILE_70
#define __COMPILE_71
#define __COMPILE_72
#define __COMPILE_73
#define __COMPILE_74
#define __COMPILE_75
#define __COMPILE_76
#define __COMPILE_77
#define __COMPILE_78
#define __COMPILE_79
#define __COMPILE_80
#define __COMPILE_81
#define __COMPILE_82
#define __COMPILE_83
#define __COMPILE_84
#define __COMPILE_85
#define __COMPILE_86
#define __COMPILE_87
#define __COMPILE_88
#define __COMPILE_89
#define __COMPILE_90
#define __COMPILE_91
#define __COMPILE_92
#define __COMPILE_93
#define __COMPILE_94
#define __COMPILE_95
#define __COMPILE_96
#define __COMPILE_97
#define __COMPILE_98
#define __COMPILE_99
#define __COMPILE_100
#define __COMPILE_101
#define __COMPILE_102
#define __COMPILE_103
#define __COMPILE_104
#define __COMPILE_105
#define __COMPILE_106
#define __COMPILE_107
#define __COMPILE_108
#define __COMPILE_109
#define __COMPILE_110
#define __COMPILE_111
#define __COMPILE_112
#define __COMPILE_113
#define __COMPILE_114
#define __COMPILE_115
#define __COMPILE_116
#define __COMPILE_117
#define __COMPILE_118
#define __COMPILE_119
#define __COMPILE_120
#define __COMPILE_121
#define __COMPILE_122
#define __COMPILE_123
#define __COMPILE_124
#define __COMPILE_125
#define __COMPILE_126
#define __COMPILE_127
#define __COMPILE_128
#define __COMPILE_129
#define __COMPILE_130
#define __COMPILE_131
#define __COMPILE_132
#define __COMPILE_133
#define __COMPILE_134
#define __COMPILE_135
#define __COMPILE_136
#define __COMPILE_137
#define __COMPILE_138
#define __COMPILE_139
#define __COMPILE_140
#define __COMPILE_141
#define __COMPILE_142
#define __COMPILE_143
#define __COMPILE_144
#define __COMPILE_145
#define __COMPILE_146
#define __COMPILE_147
#define __COMPILE_148
#define __COMPILE_149
#define __COMPILE_150
#define __COMPILE_151
#define __COMPILE_152
#define __COMPILE_153
#define __COMPILE_154
#define __COMPILE_155
#define __COMPILE_156
#define __COMPILE_157
#define __COMPILE_158
#define __COMPILE_159
#define __COMPILE_160
#define __COMPILE_161
#define __COMPILE_162
#define __COMPILE_163
#define __COMPILE_164
#define __COMPILE_165
#define __COMPILE_166
#define __COMPILE_167
#define __COMPILE_168
#define __COMPILE_169
#define __COMPILE_170
#define __COMPILE_171
#define __COMPILE_172
#define __COMPILE_173
#define __COMPILE_174
#define __COMPILE_175
#define __COMPILE_176
#define __COMPILE_177
#define __COMPILE_178
#define __COMPILE_179
#define __COMPILE_180
#define __COMPILE_181
#define __COMPILE_182
#define __COMPILE_183
#define __COMPILE_184
#define __COMPILE_185
#define __COMPILE_186
#define __COMPILE_187
#define __COMPILE_188
#define __COMPILE_189
#define __COMPILE_190
#define __COMPILE_191
#define __COMPILE_192
#define __COMPILE_193
#define __COMPILE_194
#define __COMPILE_195
#define __COMPILE_196
#define __COMPILE_197
#define __COMPILE_198
#define __COMPILE_199
#define __COMPILE_200
#define __COMPILE_201
#define __COMPILE_202
#define __COMPILE_203
#define __COMPILE_204
#define __COMPILE_205
#define __COMPILE_206
#define __COMPILE_207
#define __COMPILE_208
#define __COMPILE_209
#define __COMPILE_210
#define __COMPILE_211
#define __COMPILE_212
#define __COMPILE_213
#define __COMPILE_214
#define __COMPILE_215
#define __COMPILE_216
#define __COMPILE_217
#define __COMPILE_218
#define __COMPILE_219
#define __COMPILE_220
#define __COMPILE_221
#define __COMPILE_222
#define __COMPILE_223
#define __COMPILE_224
#define __COMPILE_225
#define __COMPILE_226
#define __COMPILE_227
#define __COMPILE_228
#define __COMPILE_229
#define __COMPILE_230
#define __COMPILE_232
#define __COMPILE_234
#define __COMPILE_235
#define __COMPILE_236
#define __COMPILE_237
#define __COMPILE_238
#define __COMPILE_239
#define __COMPILE_240
#define __COMPILE_241
#define __COMPILE_242
#define __COMPILE_243
#define __COMPILE_244
#define __COMPILE_245
#define __COMPILE_246
#define __COMPILE_247
#define __COMPILE_248
// compile_fin
int __get_mutant(); int __is_neg(const char *location,char *lid,int count, ...); int __abst_hole(); char *__stat_write_init(const char *func_name);void __write_stat(char *str,const char *var_name,void *var_addr,int size); void __stat_file_close(const char *func_name,char *str);long long __mutate(const long long,const char *,const char *); int __trident_choice(char* lid, char* typestr,int* rvals, char** rvals_ids, int rvals_size,int** lvals, char** lvals_ids, int lvals_size);int __trident_output(char* id, char* typestr, int value);float fabs_trident(float a);int __choose(const char *);void *__var_select(unsigned int var_count,void *vars[]);void *__var_select_2(unsigned int var_count,void *vars[]);long long __const_select(unsigned int const_count, ...);void* memset(void*, int, unsigned long); 
/* $Id$ */

/*
 * Copyright (c) 1988-1997 Sam Leffler
 * Copyright (c) 1991-1997 Silicon Graphics, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and 
 * its documentation for any purpose is hereby granted without fee, provided
 * that (i) the above copyright notices and this permission notice appear in
 * all copies of the software and related documentation, and (ii) the names of
 * Sam Leffler and Silicon Graphics may not be used in any advertising or
 * publicity relating to the software without the specific, prior written
 * permission of Sam Leffler and Silicon Graphics.
 * 
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
 * 
 * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
 * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
 * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
 * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
 * OF THIS SOFTWARE.
 */

/*
 * TIFF Library.
 *
 * Directory Read Support Routines.
 */
#include "tiffiop.h"

#define	IGNORE	0		/* tag placeholder used below */

#ifdef HAVE_IEEEFP
# define	TIFFCvtIEEEFloatToNative(tif, n, fp)
# define	TIFFCvtIEEEDoubleToNative(tif, n, dp)
#else
extern	void TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);
extern	void TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);
#endif

static	int EstimateStripByteCounts(TIFF*, TIFFDirEntry*, uint16);
static	void MissingRequired(TIFF*, const char*);
static	int CheckDirCount(TIFF*, TIFFDirEntry*, uint32);
static	tsize_t TIFFFetchData(TIFF*, TIFFDirEntry*, char*);
static	tsize_t TIFFFetchString(TIFF*, TIFFDirEntry*, char*);
static	float TIFFFetchRational(TIFF*, TIFFDirEntry*);
static	int TIFFFetchNormalTag(TIFF*, TIFFDirEntry*);
static	int TIFFFetchPerSampleShorts(TIFF*, TIFFDirEntry*, uint16*);
static	int TIFFFetchPerSampleLongs(TIFF*, TIFFDirEntry*, uint32*);
static	int TIFFFetchPerSampleAnys(TIFF*, TIFFDirEntry*, double*);
static	int TIFFFetchShortArray(TIFF*, TIFFDirEntry*, uint16*);
static	int TIFFFetchStripThing(TIFF*, TIFFDirEntry*, long, uint32**);
static	int TIFFFetchRefBlackWhite(TIFF*, TIFFDirEntry*);
static	float TIFFFetchFloat(TIFF*, TIFFDirEntry*);
static	int TIFFFetchFloatArray(TIFF*, TIFFDirEntry*, float*);
static	int TIFFFetchDoubleArray(TIFF*, TIFFDirEntry*, double*);
static	int TIFFFetchAnyArray(TIFF*, TIFFDirEntry*, double*);
static	int TIFFFetchShortPair(TIFF*, TIFFDirEntry*);
static	void ChopUpSingleUncompressedStrip(TIFF*);

/*
 * Read the next TIFF directory from a file
 * and convert it to the internal format.
 * We read directories sequentially.
 */
int
TIFFReadDirectory(TIFF* tif)
{
	static const char module[] = "TIFFReadDirectory";

	int n;
	TIFFDirectory* td;
	TIFFDirEntry *dp, *dir = NULL;
	uint16 iv;
	uint32 v;
	const TIFFFieldInfo* fip;
	size_t fix;
	uint16 dircount;
	toff_t nextdiroff;
	int diroutoforderwarning = 0;
	toff_t* new_dirlist;

	tif->tif_diroff = tif->tif_nextdiroff;
	if (tif->tif_diroff == 0)		/* no more directories */
		return (0);

	/*
	 * XXX: Trick to prevent IFD looping. The one can create TIFF file
	 * with looped directory pointers. We will maintain a list of already
	 * seen directories and check every IFD offset against this list.
	 */
	for (n = 0; n < tif->tif_dirnumber; n++) {
		if (tif->tif_dirlist[n] == tif->tif_diroff)
			return (0);
	}
	tif->tif_dirnumber++;
	new_dirlist = (toff_t *)_TIFFrealloc(tif->tif_dirlist,
					tif->tif_dirnumber * sizeof(toff_t));
	if (!new_dirlist) {
		TIFFErrorExt(tif->tif_clientdata, module,
			  "%s: Failed to allocate space for IFD list",
			  tif->tif_name);
		return (0);
	}
	tif->tif_dirlist = new_dirlist;
	tif->tif_dirlist[tif->tif_dirnumber - 1] = tif->tif_diroff;

	/*
	 * Cleanup any previous compression state.
	 */
	(*tif->tif_cleanup)(tif);
	tif->tif_curdir++;
	nextdiroff = 0;
	if (!isMapped(tif)) {
		if (!SeekOK(tif, tif->tif_diroff)) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "%s: Seek error accessing TIFF directory",
                            tif->tif_name);
			return (0);
		}
		if (!ReadOK(tif, &dircount, sizeof (uint16))) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "%s: Can not read TIFF directory count",
                            tif->tif_name);
			return (0);
		}
		if (tif->tif_flags & TIFF_SWAB)
			TIFFSwabShort(&dircount);
		dir = (TIFFDirEntry *)_TIFFCheckMalloc(tif,
						  dircount,
						  sizeof (TIFFDirEntry),
						  "to read TIFF directory");
		if (dir == NULL)
			return (0);
		if (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {
			TIFFErrorExt(tif->tif_clientdata, module,
                                  "%.100s: Can not read TIFF directory",
                                  tif->tif_name);
			goto bad;
		}
		/*
		 * Read offset to next directory for sequential scans.
		 */
		(void) ReadOK(tif, &nextdiroff, sizeof (uint32));
	} else {
		toff_t off = tif->tif_diroff;

		if (off + sizeof (uint16) > tif->tif_size) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "%s: Can not read TIFF directory count",
                            tif->tif_name);
			return (0);
		} else
			_TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16));
		off += sizeof (uint16);
		if (tif->tif_flags & TIFF_SWAB)
			TIFFSwabShort(&dircount);
		dir = (TIFFDirEntry *)_TIFFCheckMalloc(tif,
		    dircount, sizeof (TIFFDirEntry), "to read TIFF directory");
		if (dir == NULL)
			return (0);
		if (off + dircount*sizeof (TIFFDirEntry) > tif->tif_size) {
			TIFFErrorExt(tif->tif_clientdata, module,
                                  "%s: Can not read TIFF directory",
                                  tif->tif_name);
			goto bad;
		} else {
			_TIFFmemcpy(dir, tif->tif_base + off,
				    dircount*sizeof (TIFFDirEntry));
		}
		off += dircount* sizeof (TIFFDirEntry);
		if (off + sizeof (uint32) <= tif->tif_size)
			_TIFFmemcpy(&nextdiroff, tif->tif_base+off, sizeof (uint32));
	}
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabLong(&nextdiroff);
	tif->tif_nextdiroff = nextdiroff;

	tif->tif_flags &= ~TIFF_BEENWRITING;	/* reset before new dir */
	/*
	 * Setup default value and then make a pass over
	 * the fields to check type and tag information,
	 * and to extract info required to size data
	 * structures.  A second pass is made afterwards
	 * to read in everthing not taken in the first pass.
	 */
	td = &tif->tif_dir;
	/* free any old stuff and reinit */
	TIFFFreeDirectory(tif);
	TIFFDefaultDirectory(tif);
	/*
	 * Electronic Arts writes gray-scale TIFF files
	 * without a PlanarConfiguration directory entry.
	 * Thus we setup a default value here, even though
	 * the TIFF spec says there is no default value.
	 */
	TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);

	/*
	 * Sigh, we must make a separate pass through the
	 * directory for the following reason:
	 *
	 * We must process the Compression tag in the first pass
	 * in order to merge in codec-private tag definitions (otherwise
	 * we may get complaints about unknown tags).  However, the
	 * Compression tag may be dependent on the SamplesPerPixel
	 * tag value because older TIFF specs permited Compression
	 * to be written as a SamplesPerPixel-count tag entry.
	 * Thus if we don't first figure out the correct SamplesPerPixel
	 * tag value then we may end up ignoring the Compression tag
	 * value because it has an incorrect count value (if the
	 * true value of SamplesPerPixel is not 1).
	 *
	 * It sure would have been nice if Aldus had really thought
	 * this stuff through carefully.
	 */ 
	for (dp = dir, n = dircount; n > 0; n--, dp++) {
		if (tif->tif_flags & TIFF_SWAB) {
			TIFFSwabArrayOfShort(&dp->tdir_tag, 2);
			TIFFSwabArrayOfLong(&dp->tdir_count, 2);
		}
		if (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {
			if (!TIFFFetchNormalTag(tif, dp))
				goto bad;
			dp->tdir_tag = IGNORE;
		}
	}
	/*
	 * First real pass over the directory.
	 */
	fix = 0;
	for (dp = dir, n = dircount; n > 0; n--, dp++) {

		if (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)
			continue;
               
		/*
		 * Silicon Beach (at least) writes unordered
		 * directory tags (violating the spec).  Handle
		 * it here, but be obnoxious (maybe they'll fix it?).
		 */
		if (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) {
			if (!diroutoforderwarning) {
				TIFFWarningExt(tif->tif_clientdata, module,
"%s: invalid TIFF directory; tags are not sorted in ascending order",
                                            tif->tif_name);
				diroutoforderwarning = 1;
			}
			fix = 0;			/* O(n^2) */
		}
		while (fix < tif->tif_nfields &&
		       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
			fix++;
		if (fix >= tif->tif_nfields ||
		    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {

					TIFFWarningExt(tif->tif_clientdata, module,
                        "%s: unknown field with tag %d (0x%x) encountered",
                                tif->tif_name, dp->tdir_tag, dp->tdir_tag,
                                dp->tdir_type);

                    TIFFMergeFieldInfo( tif,
                                        _TIFFCreateAnonFieldInfo( tif,
                                              dp->tdir_tag,
					      (TIFFDataType) dp->tdir_type ),
                                        1 );
                    fix = 0;
                    while (fix < tif->tif_nfields &&
                           tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
			fix++;
		}
		/*
		 * Null out old tags that we ignore.
		 */
		if (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {
	ignore:
			dp->tdir_tag = IGNORE;
			continue;
		}
		/*
		 * Check data type.
		 */
		fip = tif->tif_fieldinfo[fix];
		while (dp->tdir_type != (unsigned short) fip->field_type
                       && fix < tif->tif_nfields) {
			if (fip->field_type == TIFF_ANY)	/* wildcard */
				break;
                        fip = tif->tif_fieldinfo[++fix];
			if (fix >= tif->tif_nfields ||
			    fip->field_tag != dp->tdir_tag) {
				TIFFWarningExt(tif->tif_clientdata, module,
			"%s: wrong data type %d for \"%s\"; tag ignored",
					    tif->tif_name, dp->tdir_type,
					    tif->tif_fieldinfo[fix-1]->field_name);
				goto ignore;
			}
		}
		/*
		 * Check count if known in advance.
		 */
		if (fip->field_readcount != TIFF_VARIABLE
		    && fip->field_readcount != TIFF_VARIABLE2) {
			uint32 expected = (fip->field_readcount == TIFF_SPP) ?
			    (uint32) td->td_samplesperpixel :
			    (uint32) fip->field_readcount;
			if (!CheckDirCount(tif, dp, expected))
				goto ignore;
		}

		switch (dp->tdir_tag) {
		case TIFFTAG_COMPRESSION:
			/*
			 * The 5.0 spec says the Compression tag has
			 * one value, while earlier specs say it has
			 * one value per sample.  Because of this, we
			 * accept the tag if one value is supplied.
			 */
			if (dp->tdir_count == 1) {
				v = TIFFExtractData(tif,
				    dp->tdir_type, dp->tdir_offset);
				if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
					goto bad;
				break;
			/* XXX: workaround for broken TIFFs */
			} else if (dp->tdir_type == TIFF_LONG) {
				if (!TIFFFetchPerSampleLongs(tif, dp, &v) ||
				    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))
					goto bad;
			} else {
				if (!TIFFFetchPerSampleShorts(tif, dp, &iv)
				    || !TIFFSetField(tif, dp->tdir_tag, iv))
					goto bad;
			}
			dp->tdir_tag = IGNORE;
			break;
		case TIFFTAG_STRIPOFFSETS:
		case TIFFTAG_STRIPBYTECOUNTS:
		case TIFFTAG_TILEOFFSETS:
		case TIFFTAG_TILEBYTECOUNTS:
			TIFFSetFieldBit(tif, fip->field_bit);
			break;
		case TIFFTAG_IMAGEWIDTH:
		case TIFFTAG_IMAGELENGTH:
		case TIFFTAG_IMAGEDEPTH:
		case TIFFTAG_TILELENGTH:
		case TIFFTAG_TILEWIDTH:
		case TIFFTAG_TILEDEPTH:
		case TIFFTAG_PLANARCONFIG:
		case TIFFTAG_ROWSPERSTRIP:
		case TIFFTAG_EXTRASAMPLES:
			if (!TIFFFetchNormalTag(tif, dp))
				goto bad;
			dp->tdir_tag = IGNORE;
			break;
		}
	}

	/*
	 * Allocate directory structure and setup defaults.
	 */
	if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {
		MissingRequired(tif, "ImageLength");
		goto bad;
	}
	if (!TIFFFieldSet(tif, FIELD_PLANARCONFIG)) {
		MissingRequired(tif, "PlanarConfiguration");
		goto bad;
	}
	/* 
 	 * Setup appropriate structures (by strip or by tile)
	 */
	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
		td->td_nstrips = TIFFNumberOfStrips(tif);
		td->td_tilewidth = td->td_imagewidth;
		td->td_tilelength = td->td_rowsperstrip;
		td->td_tiledepth = td->td_imagedepth;
		tif->tif_flags &= ~TIFF_ISTILED;
	} else {
		td->td_nstrips = TIFFNumberOfTiles(tif);
		tif->tif_flags |= TIFF_ISTILED;
	}
	if (!td->td_nstrips) {
		TIFFErrorExt(tif->tif_clientdata, module, "%s: cannot handle zero number of %s",
			  tif->tif_name, isTiled(tif) ? "tiles" : "strips");
		goto bad;
	}
	td->td_stripsperimage = td->td_nstrips;
	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
		td->td_stripsperimage /= td->td_samplesperpixel;
	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
		MissingRequired(tif,
		    isTiled(tif) ? "TileOffsets" : "StripOffsets");
		goto bad;
	}

	/*
	 * Second pass: extract other information.
	 */
	for (dp = dir, n = dircount; n > 0; n--, dp++) {
		if (dp->tdir_tag == IGNORE)
			continue;
		switch (dp->tdir_tag) {
		case TIFFTAG_MINSAMPLEVALUE:
		case TIFFTAG_MAXSAMPLEVALUE:
		case TIFFTAG_BITSPERSAMPLE:
		case TIFFTAG_DATATYPE:
		case TIFFTAG_SAMPLEFORMAT:
			/*
			 * The 5.0 spec says the Compression tag has
			 * one value, while earlier specs say it has
			 * one value per sample.  Because of this, we
			 * accept the tag if one value is supplied.
			 *
                         * The MinSampleValue, MaxSampleValue, BitsPerSample
                         * DataType and SampleFormat tags are supposed to be
                         * written as one value/sample, but some vendors
                         * incorrectly write one value only -- so we accept
                         * that as well (yech). Other vendors write correct
			 * value for NumberOfSamples, but incorrect one for
			 * BitsPerSample and friends, and we will read this
			 * too.
			 */
			if (dp->tdir_count == 1) {
				v = TIFFExtractData(tif,
				    dp->tdir_type, dp->tdir_offset);
				if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
					goto bad;
			/* XXX: workaround for broken TIFFs */
			} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE
				   && dp->tdir_type == TIFF_LONG) {
				if (!TIFFFetchPerSampleLongs(tif, dp, &v) ||
				    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))
					goto bad;
			} else {
				if (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||
				    !TIFFSetField(tif, dp->tdir_tag, iv))
					goto bad;
			}
			break;
		case TIFFTAG_SMINSAMPLEVALUE:
		case TIFFTAG_SMAXSAMPLEVALUE:
			{
				double dv = 0.0;
				if (!TIFFFetchPerSampleAnys(tif, dp, &dv) ||
				    !TIFFSetField(tif, dp->tdir_tag, dv))
					goto bad;
			}
			break;
		case TIFFTAG_STRIPOFFSETS:
		case TIFFTAG_TILEOFFSETS:
			if (!TIFFFetchStripThing(tif, dp,
			    td->td_nstrips, &td->td_stripoffset))
				goto bad;
			break;
		case TIFFTAG_STRIPBYTECOUNTS:
		case TIFFTAG_TILEBYTECOUNTS:
			if (!TIFFFetchStripThing(tif, dp,
			    td->td_nstrips, &td->td_stripbytecount))
				goto bad;
			break;
		case TIFFTAG_COLORMAP:
		case TIFFTAG_TRANSFERFUNCTION:
			{
				char* cp;
				/*
				 * TransferFunction can have either 1x or 3x
				 * data values; Colormap can have only 3x
				 * items.
				 */
				v = 1L<<td->td_bitspersample;
				if (dp->tdir_tag == TIFFTAG_COLORMAP ||
				    dp->tdir_count != v) {
					if (!CheckDirCount(tif, dp, 3 * v))
						break;
				}
				v *= sizeof(uint16);
				cp = (char *)_TIFFCheckMalloc(tif,
							      dp->tdir_count,
							      sizeof (uint16),
					"to read \"TransferFunction\" tag");
				if (cp != NULL) {
					if (TIFFFetchData(tif, dp, cp)) {
						/*
						 * This deals with there being
						 * only one array to apply to
						 * all samples.
						 */
						uint32 c = 1L << td->td_bitspersample;
						if (dp->tdir_count == c)
							v = 0L;
						TIFFSetField(tif, dp->tdir_tag,
						    cp, cp+v, cp+2*v);
					}
					_TIFFfree(cp);
				}
				break;
			}
		case TIFFTAG_PAGENUMBER:
		case TIFFTAG_HALFTONEHINTS:
		case TIFFTAG_YCBCRSUBSAMPLING:
		case TIFFTAG_DOTRANGE:
			(void) TIFFFetchShortPair(tif, dp);
			break;
		case TIFFTAG_REFERENCEBLACKWHITE:
			(void) TIFFFetchRefBlackWhite(tif, dp);
			break;
/* BEGIN REV 4.0 COMPATIBILITY */
		case TIFFTAG_OSUBFILETYPE:
			v = 0L;
			switch (TIFFExtractData(tif, dp->tdir_type,
			    dp->tdir_offset)) {
			case OFILETYPE_REDUCEDIMAGE:
				v = FILETYPE_REDUCEDIMAGE;
				break;
			case OFILETYPE_PAGE:
				v = FILETYPE_PAGE;
				break;
			}
			if (v)
				TIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);
			break;
/* END REV 4.0 COMPATIBILITY */
		default:
			(void) TIFFFetchNormalTag(tif, dp);
			break;
		}
	}
	/*
	 * Verify Palette image has a Colormap.
	 */
	if (td->td_photometric == PHOTOMETRIC_PALETTE &&
	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {
		MissingRequired(tif, "Colormap");
		goto bad;
	}
	/*
	 * Attempt to deal with a missing StripByteCounts tag.
	 */
	if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
		/*
		 * Some manufacturers violate the spec by not giving
		 * the size of the strips.  In this case, assume there
		 * is one uncompressed strip of data.
		 */
		if ((td->td_planarconfig == PLANARCONFIG_CONTIG &&
		    td->td_nstrips > 1) ||
		    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&
		     td->td_nstrips != td->td_samplesperpixel)) {
		    MissingRequired(tif, "StripByteCounts");
		    goto bad;
		}
		TIFFWarningExt(tif->tif_clientdata, module,
			"%s: TIFF directory is missing required "
			"\"%s\" field, calculating from imagelength",
			tif->tif_name,
		        _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
		if (EstimateStripByteCounts(tif, dir, dircount) < 0)
		    goto bad;
/* 
 * Assume we have wrong StripByteCount value (in case of single strip) in
 * following cases:
 *   - it is equal to zero along with StripOffset;
 *   - it is larger than file itself (in case of uncompressed image);
 *   - it is smaller than the size of the bytes per row multiplied on the
 *     number of rows.  The last case should not be checked in the case of
 *     writing new image, because we may do not know the exact strip size
 *     until the whole image will be written and directory dumped out.
 */
#define	BYTECOUNTLOOKSBAD \
    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \
      (td->td_compression == COMPRESSION_NONE && \
       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \
      (tif->tif_mode == O_RDONLY && \
       td->td_compression == COMPRESSION_NONE && \
       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )

	} else if (td->td_nstrips == 1 
                   && td->td_stripoffset[0] != 0 
                   && BYTECOUNTLOOKSBAD) {
		/*
		 * XXX: Plexus (and others) sometimes give a value of zero for
		 * a tag when they don't know what the correct value is!  Try
		 * and handle the simple case of estimating the size of a one
		 * strip image.
		 */
		TIFFWarningExt(tif->tif_clientdata, module,
	"%s: Bogus \"%s\" field, ignoring and calculating from imagelength",
                            tif->tif_name,
		            _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
		if(EstimateStripByteCounts(tif, dir, dircount) < 0)
		    goto bad;
	} else if (td->td_planarconfig == PLANARCONFIG_CONTIG
		   && td->td_nstrips > 2
		   && td->td_compression == COMPRESSION_NONE
		   && td->td_stripbytecount[0] != td->td_stripbytecount[1]) {
		/*
		 * XXX: Some vendors fill StripByteCount array with absolutely
		 * wrong values (it can be equal to StripOffset array, for
		 * example). Catch this case here.
		 */
		TIFFWarningExt(tif->tif_clientdata, module,
	"%s: Wrong \"%s\" field, ignoring and calculating from imagelength",
                            tif->tif_name,
		            _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
		if (EstimateStripByteCounts(tif, dir, dircount) < 0)
		    goto bad;
	}
	if (dir) {
		_TIFFfree((char *)dir);
		dir = NULL;
	}
	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
		td->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);
	/*
	 * Setup default compression scheme.
	 */

	/*
	 * XXX: We can optimize checking for the strip bounds using the sorted
	 * bytecounts array. See also comments for TIFFAppendToStrip()
	 * function in tif_write.c.
	 */
	if (td->td_nstrips > 1) {
		tstrip_t strip;

		td->td_stripbytecountsorted = 1;
		for (strip = 1; strip < td->td_nstrips; strip++) {
			if (td->td_stripoffset[strip - 1] >
			    td->td_stripoffset[strip]) {
				td->td_stripbytecountsorted = 0;
				break;
			}
		}
	}

	if (!TIFFFieldSet(tif, FIELD_COMPRESSION))
		TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
        /*
         * Some manufacturers make life difficult by writing
	 * large amounts of uncompressed data as a single strip.
	 * This is contrary to the recommendations of the spec.
         * The following makes an attempt at breaking such images
	 * into strips closer to the recommended 8k bytes.  A
	 * side effect, however, is that the RowsPerStrip tag
	 * value may be changed.
         */
	if (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&
	    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)
		ChopUpSingleUncompressedStrip(tif);

	/*
	 * Reinitialize i/o since we are starting on a new directory.
	 */
	tif->tif_row = (uint32) -1;
	tif->tif_curstrip = (tstrip_t) -1;
	tif->tif_col = (uint32) -1;
	tif->tif_curtile = (ttile_t) -1;
	tif->tif_tilesize = (tsize_t) -1;

	tif->tif_scanlinesize = TIFFScanlineSize(tif);
	if (!tif->tif_scanlinesize) {
		TIFFErrorExt(tif->tif_clientdata, module, "%s: cannot handle zero scanline size",
			  tif->tif_name);
		return (0);
	}

	if (isTiled(tif)) {
		tif->tif_tilesize = TIFFTileSize(tif);
		if (!tif->tif_tilesize) {
			TIFFErrorExt(tif->tif_clientdata, module, "%s: cannot handle zero tile size",
				  tif->tif_name);
			return (0);
		}
	} else {
		if (!TIFFStripSize(tif)) {
			TIFFErrorExt(tif->tif_clientdata, module, "%s: cannot handle zero strip size",
				  tif->tif_name);
			return (0);
		}
	}
	return (1);
bad:
	if (dir)
		_TIFFfree(dir);
	return (0);
}

/* 
 * Read custom directory from the arbitarry offset.
 * The code is very similar to TIFFReadDirectory().
 */
int
TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
			const TIFFFieldInfo info[], size_t n)
{
	static const char module[] = "TIFFReadCustomDirectory";

	TIFFDirectory* td = &tif->tif_dir;
	TIFFDirEntry *dp, *dir = NULL;
	const TIFFFieldInfo* fip;
	size_t fix;
	uint16 i, dircount;

	_TIFFSetupFieldInfo(tif, info, n);

	tif->tif_diroff = diroff;

	if (!isMapped(tif)) {
		if (!SeekOK(tif, diroff)) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "%s: Seek error accessing TIFF directory",
                            tif->tif_name);
			return (0);
		}
		if (!ReadOK(tif, &dircount, sizeof (uint16))) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "%s: Can not read TIFF directory count",
                            tif->tif_name);
			return (0);
		}
		if (tif->tif_flags & TIFF_SWAB)
			TIFFSwabShort(&dircount);
		dir = (TIFFDirEntry *)_TIFFCheckMalloc(tif,
						  dircount,
						  sizeof (TIFFDirEntry),
						  "to read TIFF directory");
		if (dir == NULL)
			return (0);
		if (!ReadOK(tif, dir, dircount * sizeof (TIFFDirEntry))) {
			TIFFErrorExt(tif->tif_clientdata, module,
                                  "%.100s: Can not read TIFF directory",
                                  tif->tif_name);
			goto bad;
		}
	} else {
		toff_t off = diroff;

		if (off + sizeof (uint16) > tif->tif_size) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "%s: Can not read TIFF directory count",
                            tif->tif_name);
			return (0);
		} else
			_TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16));
		off += sizeof (uint16);
		if (tif->tif_flags & TIFF_SWAB)
			TIFFSwabShort(&dircount);
		dir = (TIFFDirEntry *)_TIFFCheckMalloc(tif,
		    dircount, sizeof (TIFFDirEntry), "to read TIFF directory");
		if (dir == NULL)
			return (0);
		if (off + dircount * sizeof (TIFFDirEntry) > tif->tif_size) {
			TIFFErrorExt(tif->tif_clientdata, module,
                                  "%s: Can not read TIFF directory",
                                  tif->tif_name);
			goto bad;
		} else {
			_TIFFmemcpy(dir, tif->tif_base + off,
				    dircount * sizeof (TIFFDirEntry));
		}
	}

	TIFFFreeDirectory(tif);

	fix = 0;
	for (dp = dir, i = dircount; i > 0; i--, dp++) {
		if (tif->tif_flags & TIFF_SWAB) {
			TIFFSwabArrayOfShort(&dp->tdir_tag, 2);
			TIFFSwabArrayOfLong(&dp->tdir_count, 2);
		}

		if (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)
			continue;

		while (fix < tif->tif_nfields &&
		       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
			fix++;

		if (fix >= tif->tif_nfields ||
		    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {

			TIFFWarningExt(tif->tif_clientdata, module,
                        "%s: unknown field with tag %d (0x%x) encountered",
				    tif->tif_name, dp->tdir_tag, dp->tdir_tag,
				    dp->tdir_type);

			TIFFMergeFieldInfo(tif,
					   _TIFFCreateAnonFieldInfo(tif,
						dp->tdir_tag,
						(TIFFDataType)dp->tdir_type),
					   1);

			fix = 0;
			while (fix < tif->tif_nfields &&
			       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
				fix++;
		}
		/*
		 * Null out old tags that we ignore.
		 */
		if (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {
	ignore:
			dp->tdir_tag = IGNORE;
			continue;
		}
		/*
		 * Check data type.
		 */
		fip = tif->tif_fieldinfo[fix];
		while (dp->tdir_type != (unsigned short) fip->field_type
                       && fix < tif->tif_nfields) {
			if (fip->field_type == TIFF_ANY)	/* wildcard */
				break;
                        fip = tif->tif_fieldinfo[++fix];
			if (fix >= tif->tif_nfields ||
			    fip->field_tag != dp->tdir_tag) {
				TIFFWarningExt(tif->tif_clientdata, module,
			"%s: wrong data type %d for \"%s\"; tag ignored",
					    tif->tif_name, dp->tdir_type,
					    tif->tif_fieldinfo[fix-1]->field_name);
				goto ignore;
			}
		}
		/*
		 * Check count if known in advance.
		 */
		if (fip->field_readcount != TIFF_VARIABLE
		    && fip->field_readcount != TIFF_VARIABLE2) {
			uint32 expected = (fip->field_readcount == TIFF_SPP) ?
			    (uint32) td->td_samplesperpixel :
			    (uint32) fip->field_readcount;
			if (!CheckDirCount(tif, dp, expected))
				goto ignore;
		}

		(void) TIFFFetchNormalTag(tif, dp);
	}
	
	if (dir)
		_TIFFfree(dir);
	return 1;

bad:
	if (dir)
		_TIFFfree(dir);
	return 0;
}

/*
 * EXIF is important special case of custom IFD, so we have a special
 * function to read it.
 */
int
TIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)
{
	size_t exifFieldInfoCount;
	const TIFFFieldInfo *exifFieldInfo =
		_TIFFGetExifFieldInfo(&exifFieldInfoCount);
	return TIFFReadCustomDirectory(tif, diroff, exifFieldInfo,
				       exifFieldInfoCount);
}

static int
EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
{
	static const char module[] = "EstimateStripByteCounts";

	register TIFFDirEntry *dp;
	register TIFFDirectory *td = &tif->tif_dir;
	uint16 i;

	if (td->td_stripbytecount)
		_TIFFfree(td->td_stripbytecount);
	td->td_stripbytecount = (uint32*)
	    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint32),
		"for \"StripByteCounts\" array");
	if (td->td_compression != COMPRESSION_NONE) {
		uint32 space = (uint32)(sizeof (TIFFHeader)
		    + sizeof (uint16)
		    + (dircount * sizeof (TIFFDirEntry))
		    + sizeof (uint32));
		toff_t filesize = TIFFGetFileSize(tif);
		uint16 n;

		/* calculate amount of space used by indirect values */
		for (dp = dir, n = dircount; n > 0; n--, dp++)
		{
			uint32 cc = TIFFDataWidth((TIFFDataType) dp->tdir_type);
			if (cc == 0) {
				TIFFErrorExt(tif->tif_clientdata, module,
			"%s: Cannot determine size of unknown tag type %d",
					  tif->tif_name, dp->tdir_type);
				return -1;
			}
			cc = cc * dp->tdir_count;
			if (cc > sizeof (uint32))
				space += cc;
		}
		space = filesize - space;
		if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
			space /= td->td_samplesperpixel;
		for (i = 0; i < td->td_nstrips; i++)
			td->td_stripbytecount[i] = space;
		/*
		 * This gross hack handles the case were the offset to
		 * the last strip is past the place where we think the strip
		 * should begin.  Since a strip of data must be contiguous,
		 * it's safe to assume that we've overestimated the amount
		 * of data in the strip and trim this number back accordingly.
		 */ 
		i--;
		if (((toff_t)(td->td_stripoffset[i]+td->td_stripbytecount[i]))
                                                               > filesize)
			td->td_stripbytecount[i] =
			    filesize - td->td_stripoffset[i];
	} else {
		uint32 rowbytes = TIFFScanlineSize(tif);
		uint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;
		for (i = 0; i < td->td_nstrips; i++)
			td->td_stripbytecount[i] = rowbytes*rowsperstrip;
	}
	TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
	if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))
		td->td_rowsperstrip = td->td_imagelength;
	return 1;
}

static void
MissingRequired(TIFF* tif, const char* tagname)
{
	static const char module[] = "MissingRequired";

	TIFFErrorExt(tif->tif_clientdata, module,
		  "%s: TIFF directory is missing required \"%s\" field",
		  tif->tif_name, tagname);
}

/*
 * Check the count field of a directory
 * entry against a known value.  The caller
 * is expected to skip/ignore the tag if
 * there is a mismatch.
 */
static int
CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)
{
	if (count > dir->tdir_count) {
		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
	"incorrect count for field \"%s\" (%lu, expecting %lu); tag ignored",
		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
		    dir->tdir_count, count);
		return (0);
	} else if (count < dir->tdir_count) {
		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
	"incorrect count for field \"%s\" (%lu, expecting %lu); tag trimmed",
		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
		    dir->tdir_count, count);
		return (1);
	}
	return (1);
}

/*
 * Fetch a contiguous directory item.
 */
static tsize_t
TIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)
{
	int w = TIFFDataWidth((TIFFDataType) dir->tdir_type);
	tsize_t cc = dir->tdir_count * w;

	/* Check for overflow. */
	//prophet generated patch
	{
	int __choose0 = __choose("__SWITCH0");
	if (__choose0 == 0)
	{}
	#ifdef __COMPILE_0
	else if (__choose0 == 1)
	{
	//AddInitKind
	memset(&(tif)->tif_base, 0, sizeof (*(&(tif)->tif_base)));
	}
	#endif
	#ifdef __COMPILE_1
	else if (__choose0 == 2)
	{
	//AddInitKind
	memset(&(tif)->tif_cleanup, 0, sizeof (*(&(tif)->tif_cleanup)));
	}
	#endif
	#ifdef __COMPILE_2
	else if (__choose0 == 3)
	{
	//AddInitKind
	memset(&(tif)->tif_clientdata, 0, sizeof (*(&(tif)->tif_clientdata)));
	}
	#endif
	#ifdef __COMPILE_3
	else if (__choose0 == 4)
	{
	//AddInitKind
	memset(&(tif)->tif_clientinfo, 0, sizeof (*(&(tif)->tif_clientinfo)));
	}
	#endif
	#ifdef __COMPILE_4
	else if (__choose0 == 5)
	{
	//AddInitKind
	memset(&(tif)->tif_close, 0, sizeof (*(&(tif)->tif_close)));
	}
	#endif
	#ifdef __COMPILE_5
	else if (__choose0 == 6)
	{
	//AddInitKind
	memset(&(tif)->tif_closeproc, 0, sizeof (*(&(tif)->tif_closeproc)));
	}
	#endif
	#ifdef __COMPILE_6
	else if (__choose0 == 7)
	{
	//AddInitKind
	memset(&(tif)->tif_col, 0, sizeof (*(&(tif)->tif_col)));
	}
	#endif
	#ifdef __COMPILE_7
	else if (__choose0 == 8)
	{
	//AddInitKind
	memset(&(tif)->tif_curdir, 0, sizeof (*(&(tif)->tif_curdir)));
	}
	#endif
	#ifdef __COMPILE_8
	else if (__choose0 == 9)
	{
	//AddInitKind
	memset(&(tif)->tif_curoff, 0, sizeof (*(&(tif)->tif_curoff)));
	}
	#endif
	#ifdef __COMPILE_9
	else if (__choose0 == 10)
	{
	//AddInitKind
	memset(&(tif)->tif_curstrip, 0, sizeof (*(&(tif)->tif_curstrip)));
	}
	#endif
	#ifdef __COMPILE_10
	else if (__choose0 == 11)
	{
	//AddInitKind
	memset(&(tif)->tif_curtile, 0, sizeof (*(&(tif)->tif_curtile)));
	}
	#endif
	#ifdef __COMPILE_11
	else if (__choose0 == 12)
	{
	//AddInitKind
	memset(&(tif)->tif_data, 0, sizeof (*(&(tif)->tif_data)));
	}
	#endif
	#ifdef __COMPILE_12
	else if (__choose0 == 13)
	{
	//AddInitKind
	memset(&(tif)->tif_dataoff, 0, sizeof (*(&(tif)->tif_dataoff)));
	}
	#endif
	#ifdef __COMPILE_13
	else if (__choose0 == 14)
	{
	//AddInitKind
	memset(&(tif)->tif_decoderow, 0, sizeof (*(&(tif)->tif_decoderow)));
	}
	#endif
	#ifdef __COMPILE_14
	else if (__choose0 == 15)
	{
	//AddInitKind
	memset(&(tif)->tif_decodestatus, 0, sizeof (*(&(tif)->tif_decodestatus)));
	}
	#endif
	#ifdef __COMPILE_15
	else if (__choose0 == 16)
	{
	//AddInitKind
	memset(&(tif)->tif_decodestrip, 0, sizeof (*(&(tif)->tif_decodestrip)));
	}
	#endif
	#ifdef __COMPILE_16
	else if (__choose0 == 17)
	{
	//AddInitKind
	memset(&(tif)->tif_decodetile, 0, sizeof (*(&(tif)->tif_decodetile)));
	}
	#endif
	#ifdef __COMPILE_17
	else if (__choose0 == 18)
	{
	//AddInitKind
	memset(&(tif)->tif_defstripsize, 0, sizeof (*(&(tif)->tif_defstripsize)));
	}
	#endif
	#ifdef __COMPILE_18
	else if (__choose0 == 19)
	{
	//AddInitKind
	memset(&(tif)->tif_deftilesize, 0, sizeof (*(&(tif)->tif_deftilesize)));
	}
	#endif
	#ifdef __COMPILE_19
	else if (__choose0 == 20)
	{
	//AddInitKind
	memset(&(tif)->tif_dir, 0, sizeof (*(&(tif)->tif_dir)));
	}
	#endif
	#ifdef __COMPILE_20
	else if (__choose0 == 21)
	{
	//AddInitKind
	memset(&(tif)->tif_dirlist, 0, sizeof (*(&(tif)->tif_dirlist)));
	}
	#endif
	#ifdef __COMPILE_21
	else if (__choose0 == 22)
	{
	//AddInitKind
	memset(&(tif)->tif_dirnumber, 0, sizeof (*(&(tif)->tif_dirnumber)));
	}
	#endif
	#ifdef __COMPILE_22
	else if (__choose0 == 23)
	{
	//AddInitKind
	memset(&(tif)->tif_diroff, 0, sizeof (*(&(tif)->tif_diroff)));
	}
	#endif
	#ifdef __COMPILE_23
	else if (__choose0 == 24)
	{
	//AddInitKind
	memset(&(tif)->tif_encoderow, 0, sizeof (*(&(tif)->tif_encoderow)));
	}
	#endif
	#ifdef __COMPILE_24
	else if (__choose0 == 25)
	{
	//AddInitKind
	memset(&(tif)->tif_encodestatus, 0, sizeof (*(&(tif)->tif_encodestatus)));
	}
	#endif
	#ifdef __COMPILE_25
	else if (__choose0 == 26)
	{
	//AddInitKind
	memset(&(tif)->tif_encodestrip, 0, sizeof (*(&(tif)->tif_encodestrip)));
	}
	#endif
	#ifdef __COMPILE_26
	else if (__choose0 == 27)
	{
	//AddInitKind
	memset(&(tif)->tif_encodetile, 0, sizeof (*(&(tif)->tif_encodetile)));
	}
	#endif
	#ifdef __COMPILE_27
	else if (__choose0 == 28)
	{
	//AddInitKind
	memset(&(tif)->tif_fd, 0, sizeof (*(&(tif)->tif_fd)));
	}
	#endif
	#ifdef __COMPILE_28
	else if (__choose0 == 29)
	{
	//AddInitKind
	memset(&(tif)->tif_fieldinfo, 0, sizeof (*(&(tif)->tif_fieldinfo)));
	}
	#endif
	#ifdef __COMPILE_29
	else if (__choose0 == 30)
	{
	//AddInitKind
	memset(&(tif)->tif_flags, 0, sizeof (*(&(tif)->tif_flags)));
	}
	#endif
	#ifdef __COMPILE_30
	else if (__choose0 == 31)
	{
	//AddInitKind
	memset(&(tif)->tif_foundfield, 0, sizeof (*(&(tif)->tif_foundfield)));
	}
	#endif
	#ifdef __COMPILE_31
	else if (__choose0 == 32)
	{
	//AddInitKind
	memset(&(tif)->tif_header, 0, sizeof (*(&(tif)->tif_header)));
	}
	#endif
	#ifdef __COMPILE_32
	else if (__choose0 == 33)
	{
	//AddInitKind
	memset(&(tif)->tif_mapproc, 0, sizeof (*(&(tif)->tif_mapproc)));
	}
	#endif
	#ifdef __COMPILE_33
	else if (__choose0 == 34)
	{
	//AddInitKind
	memset(&(tif)->tif_mode, 0, sizeof (*(&(tif)->tif_mode)));
	}
	#endif
	#ifdef __COMPILE_34
	else if (__choose0 == 35)
	{
	//AddInitKind
	memset(&(tif)->tif_name, 0, sizeof (*(&(tif)->tif_name)));
	}
	#endif
	#ifdef __COMPILE_35
	else if (__choose0 == 36)
	{
	//AddInitKind
	memset(&(tif)->tif_nextdiroff, 0, sizeof (*(&(tif)->tif_nextdiroff)));
	}
	#endif
	#ifdef __COMPILE_36
	else if (__choose0 == 37)
	{
	//AddInitKind
	memset(&(tif)->tif_nfields, 0, sizeof (*(&(tif)->tif_nfields)));
	}
	#endif
	#ifdef __COMPILE_37
	else if (__choose0 == 38)
	{
	//AddInitKind
	memset(&(tif)->tif_nsubifd, 0, sizeof (*(&(tif)->tif_nsubifd)));
	}
	#endif
	#ifdef __COMPILE_38
	else if (__choose0 == 39)
	{
	//AddInitKind
	memset(&(tif)->tif_postdecode, 0, sizeof (*(&(tif)->tif_postdecode)));
	}
	#endif
	#ifdef __COMPILE_39
	else if (__choose0 == 40)
	{
	//AddInitKind
	memset(&(tif)->tif_postencode, 0, sizeof (*(&(tif)->tif_postencode)));
	}
	#endif
	#ifdef __COMPILE_40
	else if (__choose0 == 41)
	{
	//AddInitKind
	memset(&(tif)->tif_predecode, 0, sizeof (*(&(tif)->tif_predecode)));
	}
	#endif
	#ifdef __COMPILE_41
	else if (__choose0 == 42)
	{
	//AddInitKind
	memset(&(tif)->tif_preencode, 0, sizeof (*(&(tif)->tif_preencode)));
	}
	#endif
	#ifdef __COMPILE_42
	else if (__choose0 == 43)
	{
	//AddInitKind
	memset(&(tif)->tif_rawcc, 0, sizeof (*(&(tif)->tif_rawcc)));
	}
	#endif
	#ifdef __COMPILE_43
	else if (__choose0 == 44)
	{
	//AddInitKind
	memset(&(tif)->tif_rawcp, 0, sizeof (*(&(tif)->tif_rawcp)));
	}
	#endif
	#ifdef __COMPILE_44
	else if (__choose0 == 45)
	{
	//AddInitKind
	memset(&(tif)->tif_rawdata, 0, sizeof (*(&(tif)->tif_rawdata)));
	}
	#endif
	#ifdef __COMPILE_45
	else if (__choose0 == 46)
	{
	//AddInitKind
	memset(&(tif)->tif_rawdatasize, 0, sizeof (*(&(tif)->tif_rawdatasize)));
	}
	#endif
	#ifdef __COMPILE_46
	else if (__choose0 == 47)
	{
	//AddInitKind
	memset(&(tif)->tif_readproc, 0, sizeof (*(&(tif)->tif_readproc)));
	}
	#endif
	#ifdef __COMPILE_47
	else if (__choose0 == 48)
	{
	//AddInitKind
	memset(&(tif)->tif_row, 0, sizeof (*(&(tif)->tif_row)));
	}
	#endif
	#ifdef __COMPILE_48
	else if (__choose0 == 49)
	{
	//AddInitKind
	memset(&(tif)->tif_scanlinesize, 0, sizeof (*(&(tif)->tif_scanlinesize)));
	}
	#endif
	#ifdef __COMPILE_49
	else if (__choose0 == 50)
	{
	//AddInitKind
	memset(&(tif)->tif_scanlineskew, 0, sizeof (*(&(tif)->tif_scanlineskew)));
	}
	#endif
	#ifdef __COMPILE_50
	else if (__choose0 == 51)
	{
	//AddInitKind
	memset(&(tif)->tif_seek, 0, sizeof (*(&(tif)->tif_seek)));
	}
	#endif
	#ifdef __COMPILE_51
	else if (__choose0 == 52)
	{
	//AddInitKind
	memset(&(tif)->tif_seekproc, 0, sizeof (*(&(tif)->tif_seekproc)));
	}
	#endif
	#ifdef __COMPILE_52
	else if (__choose0 == 53)
	{
	//AddInitKind
	memset(&(tif)->tif_setupdecode, 0, sizeof (*(&(tif)->tif_setupdecode)));
	}
	#endif
	#ifdef __COMPILE_53
	else if (__choose0 == 54)
	{
	//AddInitKind
	memset(&(tif)->tif_setupencode, 0, sizeof (*(&(tif)->tif_setupencode)));
	}
	#endif
	#ifdef __COMPILE_54
	else if (__choose0 == 55)
	{
	//AddInitKind
	memset(&(tif)->tif_size, 0, sizeof (*(&(tif)->tif_size)));
	}
	#endif
	#ifdef __COMPILE_55
	else if (__choose0 == 56)
	{
	//AddInitKind
	memset(&(tif)->tif_sizeproc, 0, sizeof (*(&(tif)->tif_sizeproc)));
	}
	#endif
	#ifdef __COMPILE_56
	else if (__choose0 == 57)
	{
	//AddInitKind
	memset(&(tif)->tif_subifdoff, 0, sizeof (*(&(tif)->tif_subifdoff)));
	}
	#endif
	#ifdef __COMPILE_57
	else if (__choose0 == 58)
	{
	//AddInitKind
	memset(&(tif)->tif_tagmethods, 0, sizeof (*(&(tif)->tif_tagmethods)));
	}
	#endif
	#ifdef __COMPILE_58
	else if (__choose0 == 59)
	{
	//AddInitKind
	memset(&(tif)->tif_tilesize, 0, sizeof (*(&(tif)->tif_tilesize)));
	}
	#endif
	#ifdef __COMPILE_59
	else if (__choose0 == 60)
	{
	//AddInitKind
	memset(&(tif)->tif_typemask, 0, sizeof (*(&(tif)->tif_typemask)));
	}
	#endif
	#ifdef __COMPILE_60
	else if (__choose0 == 61)
	{
	//AddInitKind
	memset(&(tif)->tif_typeshift, 0, sizeof (*(&(tif)->tif_typeshift)));
	}
	#endif
	#ifdef __COMPILE_61
	else if (__choose0 == 62)
	{
	//AddInitKind
	memset(&(tif)->tif_unmapproc, 0, sizeof (*(&(tif)->tif_unmapproc)));
	}
	#endif
	#ifdef __COMPILE_62
	else if (__choose0 == 63)
	{
	//AddInitKind
	memset(&(tif)->tif_writeproc, 0, sizeof (*(&(tif)->tif_writeproc)));
	}
	#endif
	#ifdef __COMPILE_63
	else if (__choose0 == 64)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_bit, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_bit)));
	}
	#endif
	#ifdef __COMPILE_64
	else if (__choose0 == 65)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_name)));
	}
	#endif
	#ifdef __COMPILE_65
	else if (__choose0 == 66)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_oktochange, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_oktochange)));
	}
	#endif
	#ifdef __COMPILE_66
	else if (__choose0 == 67)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_passcount, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_passcount)));
	}
	#endif
	#ifdef __COMPILE_67
	else if (__choose0 == 68)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_readcount, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_readcount)));
	}
	#endif
	#ifdef __COMPILE_68
	else if (__choose0 == 69)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_tag, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_tag)));
	}
	#endif
	#ifdef __COMPILE_69
	else if (__choose0 == 70)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_type, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_type)));
	}
	#endif
	#ifdef __COMPILE_70
	else if (__choose0 == 71)
	{
	//AddInitKind
	memset(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_writecount, 0, sizeof (*(&TIFFFieldWithTag(tif, dir->tdir_tag)->field_writecount)));
	}
	#endif
	#ifdef __COMPILE_71
	else if (__choose0 == 72)
	{
	//AddInitKind
	memset(&dir->tdir_count, 0, sizeof (*(&dir->tdir_count)));
	}
	#endif
	#ifdef __COMPILE_72
	else if (__choose0 == 73)
	{
	//AddInitKind
	memset(&dir->tdir_offset, 0, sizeof (*(&dir->tdir_offset)));
	}
	#endif
	#ifdef __COMPILE_73
	else if (__choose0 == 74)
	{
	//AddInitKind
	memset(&dir->tdir_tag, 0, sizeof (*(&dir->tdir_tag)));
	}
	#endif
	#ifdef __COMPILE_74
	else if (__choose0 == 75)
	{
	//AddInitKind
	memset(&dir->tdir_type, 0, sizeof (*(&dir->tdir_type)));
	}
	#endif
	#ifdef __COMPILE_75
	else if (__choose0 == 76)
	{
	//AddInitKind
	memset(&tif->tif_base, 0, sizeof (*(&tif->tif_base)));
	}
	#endif
	#ifdef __COMPILE_76
	else if (__choose0 == 77)
	{
	//AddInitKind
	memset(&tif->tif_cleanup, 0, sizeof (*(&tif->tif_cleanup)));
	}
	#endif
	#ifdef __COMPILE_77
	else if (__choose0 == 78)
	{
	//AddInitKind
	memset(&tif->tif_clientdata, 0, sizeof (*(&tif->tif_clientdata)));
	}
	#endif
	#ifdef __COMPILE_78
	else if (__choose0 == 79)
	{
	//AddInitKind
	memset(&tif->tif_clientinfo, 0, sizeof (*(&tif->tif_clientinfo)));
	}
	#endif
	#ifdef __COMPILE_79
	else if (__choose0 == 80)
	{
	//AddInitKind
	memset(&tif->tif_close, 0, sizeof (*(&tif->tif_close)));
	}
	#endif
	#ifdef __COMPILE_80
	else if (__choose0 == 81)
	{
	//AddInitKind
	memset(&tif->tif_closeproc, 0, sizeof (*(&tif->tif_closeproc)));
	}
	#endif
	#ifdef __COMPILE_81
	else if (__choose0 == 82)
	{
	//AddInitKind
	memset(&tif->tif_col, 0, sizeof (*(&tif->tif_col)));
	}
	#endif
	#ifdef __COMPILE_82
	else if (__choose0 == 83)
	{
	//AddInitKind
	memset(&tif->tif_curdir, 0, sizeof (*(&tif->tif_curdir)));
	}
	#endif
	#ifdef __COMPILE_83
	else if (__choose0 == 84)
	{
	//AddInitKind
	memset(&tif->tif_curoff, 0, sizeof (*(&tif->tif_curoff)));
	}
	#endif
	#ifdef __COMPILE_84
	else if (__choose0 == 85)
	{
	//AddInitKind
	memset(&tif->tif_curstrip, 0, sizeof (*(&tif->tif_curstrip)));
	}
	#endif
	#ifdef __COMPILE_85
	else if (__choose0 == 86)
	{
	//AddInitKind
	memset(&tif->tif_curtile, 0, sizeof (*(&tif->tif_curtile)));
	}
	#endif
	#ifdef __COMPILE_86
	else if (__choose0 == 87)
	{
	//AddInitKind
	memset(&tif->tif_data, 0, sizeof (*(&tif->tif_data)));
	}
	#endif
	#ifdef __COMPILE_87
	else if (__choose0 == 88)
	{
	//AddInitKind
	memset(&tif->tif_dataoff, 0, sizeof (*(&tif->tif_dataoff)));
	}
	#endif
	#ifdef __COMPILE_88
	else if (__choose0 == 89)
	{
	//AddInitKind
	memset(&tif->tif_decoderow, 0, sizeof (*(&tif->tif_decoderow)));
	}
	#endif
	#ifdef __COMPILE_89
	else if (__choose0 == 90)
	{
	//AddInitKind
	memset(&tif->tif_decodestatus, 0, sizeof (*(&tif->tif_decodestatus)));
	}
	#endif
	#ifdef __COMPILE_90
	else if (__choose0 == 91)
	{
	//AddInitKind
	memset(&tif->tif_decodestrip, 0, sizeof (*(&tif->tif_decodestrip)));
	}
	#endif
	#ifdef __COMPILE_91
	else if (__choose0 == 92)
	{
	//AddInitKind
	memset(&tif->tif_decodetile, 0, sizeof (*(&tif->tif_decodetile)));
	}
	#endif
	#ifdef __COMPILE_92
	else if (__choose0 == 93)
	{
	//AddInitKind
	memset(&tif->tif_defstripsize, 0, sizeof (*(&tif->tif_defstripsize)));
	}
	#endif
	#ifdef __COMPILE_93
	else if (__choose0 == 94)
	{
	//AddInitKind
	memset(&tif->tif_deftilesize, 0, sizeof (*(&tif->tif_deftilesize)));
	}
	#endif
	#ifdef __COMPILE_94
	else if (__choose0 == 95)
	{
	//AddInitKind
	memset(&tif->tif_dir, 0, sizeof (*(&tif->tif_dir)));
	}
	#endif
	#ifdef __COMPILE_95
	else if (__choose0 == 96)
	{
	//AddInitKind
	memset(&tif->tif_dirlist, 0, sizeof (*(&tif->tif_dirlist)));
	}
	#endif
	#ifdef __COMPILE_96
	else if (__choose0 == 97)
	{
	//AddInitKind
	memset(&tif->tif_dirnumber, 0, sizeof (*(&tif->tif_dirnumber)));
	}
	#endif
	#ifdef __COMPILE_97
	else if (__choose0 == 98)
	{
	//AddInitKind
	memset(&tif->tif_diroff, 0, sizeof (*(&tif->tif_diroff)));
	}
	#endif
	#ifdef __COMPILE_98
	else if (__choose0 == 99)
	{
	//AddInitKind
	memset(&tif->tif_encoderow, 0, sizeof (*(&tif->tif_encoderow)));
	}
	#endif
	#ifdef __COMPILE_99
	else if (__choose0 == 100)
	{
	//AddInitKind
	memset(&tif->tif_encodestatus, 0, sizeof (*(&tif->tif_encodestatus)));
	}
	#endif
	#ifdef __COMPILE_100
	else if (__choose0 == 101)
	{
	//AddInitKind
	memset(&tif->tif_encodestrip, 0, sizeof (*(&tif->tif_encodestrip)));
	}
	#endif
	#ifdef __COMPILE_101
	else if (__choose0 == 102)
	{
	//AddInitKind
	memset(&tif->tif_encodetile, 0, sizeof (*(&tif->tif_encodetile)));
	}
	#endif
	#ifdef __COMPILE_102
	else if (__choose0 == 103)
	{
	//AddInitKind
	memset(&tif->tif_fd, 0, sizeof (*(&tif->tif_fd)));
	}
	#endif
	#ifdef __COMPILE_103
	else if (__choose0 == 104)
	{
	//AddInitKind
	memset(&tif->tif_fieldinfo, 0, sizeof (*(&tif->tif_fieldinfo)));
	}
	#endif
	#ifdef __COMPILE_104
	else if (__choose0 == 105)
	{
	//AddInitKind
	memset(&tif->tif_flags, 0, sizeof (*(&tif->tif_flags)));
	}
	#endif
	#ifdef __COMPILE_105
	else if (__choose0 == 106)
	{
	//AddInitKind
	memset(&tif->tif_foundfield, 0, sizeof (*(&tif->tif_foundfield)));
	}
	#endif
	#ifdef __COMPILE_106
	else if (__choose0 == 107)
	{
	//AddInitKind
	memset(&tif->tif_header, 0, sizeof (*(&tif->tif_header)));
	}
	#endif
	#ifdef __COMPILE_107
	else if (__choose0 == 108)
	{
	//AddInitKind
	memset(&tif->tif_mapproc, 0, sizeof (*(&tif->tif_mapproc)));
	}
	#endif
	#ifdef __COMPILE_108
	else if (__choose0 == 109)
	{
	//AddInitKind
	memset(&tif->tif_mode, 0, sizeof (*(&tif->tif_mode)));
	}
	#endif
	#ifdef __COMPILE_109
	else if (__choose0 == 110)
	{
	//AddInitKind
	memset(&tif->tif_name, 0, sizeof (*(&tif->tif_name)));
	}
	#endif
	#ifdef __COMPILE_110
	else if (__choose0 == 111)
	{
	//AddInitKind
	memset(&tif->tif_nextdiroff, 0, sizeof (*(&tif->tif_nextdiroff)));
	}
	#endif
	#ifdef __COMPILE_111
	else if (__choose0 == 112)
	{
	//AddInitKind
	memset(&tif->tif_nfields, 0, sizeof (*(&tif->tif_nfields)));
	}
	#endif
	#ifdef __COMPILE_112
	else if (__choose0 == 113)
	{
	//AddInitKind
	memset(&tif->tif_nsubifd, 0, sizeof (*(&tif->tif_nsubifd)));
	}
	#endif
	#ifdef __COMPILE_113
	else if (__choose0 == 114)
	{
	//AddInitKind
	memset(&tif->tif_postdecode, 0, sizeof (*(&tif->tif_postdecode)));
	}
	#endif
	#ifdef __COMPILE_114
	else if (__choose0 == 115)
	{
	//AddInitKind
	memset(&tif->tif_postencode, 0, sizeof (*(&tif->tif_postencode)));
	}
	#endif
	#ifdef __COMPILE_115
	else if (__choose0 == 116)
	{
	//AddInitKind
	memset(&tif->tif_predecode, 0, sizeof (*(&tif->tif_predecode)));
	}
	#endif
	#ifdef __COMPILE_116
	else if (__choose0 == 117)
	{
	//AddInitKind
	memset(&tif->tif_preencode, 0, sizeof (*(&tif->tif_preencode)));
	}
	#endif
	#ifdef __COMPILE_117
	else if (__choose0 == 118)
	{
	//AddInitKind
	memset(&tif->tif_rawcc, 0, sizeof (*(&tif->tif_rawcc)));
	}
	#endif
	#ifdef __COMPILE_118
	else if (__choose0 == 119)
	{
	//AddInitKind
	memset(&tif->tif_rawcp, 0, sizeof (*(&tif->tif_rawcp)));
	}
	#endif
	#ifdef __COMPILE_119
	else if (__choose0 == 120)
	{
	//AddInitKind
	memset(&tif->tif_rawdata, 0, sizeof (*(&tif->tif_rawdata)));
	}
	#endif
	#ifdef __COMPILE_120
	else if (__choose0 == 121)
	{
	//AddInitKind
	memset(&tif->tif_rawdatasize, 0, sizeof (*(&tif->tif_rawdatasize)));
	}
	#endif
	#ifdef __COMPILE_121
	else if (__choose0 == 122)
	{
	//AddInitKind
	memset(&tif->tif_readproc, 0, sizeof (*(&tif->tif_readproc)));
	}
	#endif
	#ifdef __COMPILE_122
	else if (__choose0 == 123)
	{
	//AddInitKind
	memset(&tif->tif_row, 0, sizeof (*(&tif->tif_row)));
	}
	#endif
	#ifdef __COMPILE_123
	else if (__choose0 == 124)
	{
	//AddInitKind
	memset(&tif->tif_scanlinesize, 0, sizeof (*(&tif->tif_scanlinesize)));
	}
	#endif
	#ifdef __COMPILE_124
	else if (__choose0 == 125)
	{
	//AddInitKind
	memset(&tif->tif_scanlineskew, 0, sizeof (*(&tif->tif_scanlineskew)));
	}
	#endif
	#ifdef __COMPILE_125
	else if (__choose0 == 126)
	{
	//AddInitKind
	memset(&tif->tif_seek, 0, sizeof (*(&tif->tif_seek)));
	}
	#endif
	#ifdef __COMPILE_126
	else if (__choose0 == 127)
	{
	//AddInitKind
	memset(&tif->tif_seekproc, 0, sizeof (*(&tif->tif_seekproc)));
	}
	#endif
	#ifdef __COMPILE_127
	else if (__choose0 == 128)
	{
	//AddInitKind
	memset(&tif->tif_setupdecode, 0, sizeof (*(&tif->tif_setupdecode)));
	}
	#endif
	#ifdef __COMPILE_128
	else if (__choose0 == 129)
	{
	//AddInitKind
	memset(&tif->tif_setupencode, 0, sizeof (*(&tif->tif_setupencode)));
	}
	#endif
	#ifdef __COMPILE_129
	else if (__choose0 == 130)
	{
	//AddInitKind
	memset(&tif->tif_size, 0, sizeof (*(&tif->tif_size)));
	}
	#endif
	#ifdef __COMPILE_130
	else if (__choose0 == 131)
	{
	//AddInitKind
	memset(&tif->tif_sizeproc, 0, sizeof (*(&tif->tif_sizeproc)));
	}
	#endif
	#ifdef __COMPILE_131
	else if (__choose0 == 132)
	{
	//AddInitKind
	memset(&tif->tif_subifdoff, 0, sizeof (*(&tif->tif_subifdoff)));
	}
	#endif
	#ifdef __COMPILE_132
	else if (__choose0 == 133)
	{
	//AddInitKind
	memset(&tif->tif_tagmethods, 0, sizeof (*(&tif->tif_tagmethods)));
	}
	#endif
	#ifdef __COMPILE_133
	else if (__choose0 == 134)
	{
	//AddInitKind
	memset(&tif->tif_tilesize, 0, sizeof (*(&tif->tif_tilesize)));
	}
	#endif
	#ifdef __COMPILE_134
	else if (__choose0 == 135)
	{
	//AddInitKind
	memset(&tif->tif_typemask, 0, sizeof (*(&tif->tif_typemask)));
	}
	#endif
	#ifdef __COMPILE_135
	else if (__choose0 == 136)
	{
	//AddInitKind
	memset(&tif->tif_typeshift, 0, sizeof (*(&tif->tif_typeshift)));
	}
	#endif
	#ifdef __COMPILE_136
	else if (__choose0 == 137)
	{
	//AddInitKind
	memset(&tif->tif_unmapproc, 0, sizeof (*(&tif->tif_unmapproc)));
	}
	#endif
	#ifdef __COMPILE_137
	else if (__choose0 == 138)
	{
	//AddInitKind
	memset(&tif->tif_writeproc, 0, sizeof (*(&tif->tif_writeproc)));
	}
	#endif
	#ifdef __COMPILE_138
	else if (__choose0 == 139)
	{
	//AddInitKind
	memset((tif)->tif_base, 0, sizeof (*((tif)->tif_base)));
	}
	#endif
	#ifdef __COMPILE_139
	else if (__choose0 == 140)
	{
	//AddInitKind
	memset((tif)->tif_cleanup, 0, sizeof (*((tif)->tif_cleanup)));
	}
	#endif
	#ifdef __COMPILE_140
	else if (__choose0 == 141)
	{
	//AddInitKind
	memset((tif)->tif_clientdata, 0, sizeof (*((tif)->tif_clientdata)));
	}
	#endif
	#ifdef __COMPILE_141
	else if (__choose0 == 142)
	{
	//AddInitKind
	memset((tif)->tif_clientinfo, 0, sizeof (*((tif)->tif_clientinfo)));
	}
	#endif
	#ifdef __COMPILE_142
	else if (__choose0 == 143)
	{
	//AddInitKind
	memset((tif)->tif_close, 0, sizeof (*((tif)->tif_close)));
	}
	#endif
	#ifdef __COMPILE_143
	else if (__choose0 == 144)
	{
	//AddInitKind
	memset((tif)->tif_closeproc, 0, sizeof (*((tif)->tif_closeproc)));
	}
	#endif
	#ifdef __COMPILE_144
	else if (__choose0 == 145)
	{
	//AddInitKind
	memset((tif)->tif_data, 0, sizeof (*((tif)->tif_data)));
	}
	#endif
	#ifdef __COMPILE_145
	else if (__choose0 == 146)
	{
	//AddInitKind
	memset((tif)->tif_decoderow, 0, sizeof (*((tif)->tif_decoderow)));
	}
	#endif
	#ifdef __COMPILE_146
	else if (__choose0 == 147)
	{
	//AddInitKind
	memset((tif)->tif_decodestrip, 0, sizeof (*((tif)->tif_decodestrip)));
	}
	#endif
	#ifdef __COMPILE_147
	else if (__choose0 == 148)
	{
	//AddInitKind
	memset((tif)->tif_decodetile, 0, sizeof (*((tif)->tif_decodetile)));
	}
	#endif
	#ifdef __COMPILE_148
	else if (__choose0 == 149)
	{
	//AddInitKind
	memset((tif)->tif_defstripsize, 0, sizeof (*((tif)->tif_defstripsize)));
	}
	#endif
	#ifdef __COMPILE_149
	else if (__choose0 == 150)
	{
	//AddInitKind
	memset((tif)->tif_deftilesize, 0, sizeof (*((tif)->tif_deftilesize)));
	}
	#endif
	#ifdef __COMPILE_150
	else if (__choose0 == 151)
	{
	//AddInitKind
	memset((tif)->tif_dirlist, 0, sizeof (*((tif)->tif_dirlist)));
	}
	#endif
	#ifdef __COMPILE_151
	else if (__choose0 == 152)
	{
	//AddInitKind
	memset((tif)->tif_encoderow, 0, sizeof (*((tif)->tif_encoderow)));
	}
	#endif
	#ifdef __COMPILE_152
	else if (__choose0 == 153)
	{
	//AddInitKind
	memset((tif)->tif_encodestrip, 0, sizeof (*((tif)->tif_encodestrip)));
	}
	#endif
	#ifdef __COMPILE_153
	else if (__choose0 == 154)
	{
	//AddInitKind
	memset((tif)->tif_encodetile, 0, sizeof (*((tif)->tif_encodetile)));
	}
	#endif
	#ifdef __COMPILE_154
	else if (__choose0 == 155)
	{
	//AddInitKind
	memset((tif)->tif_fieldinfo, 0, sizeof (*((tif)->tif_fieldinfo)));
	}
	#endif
	#ifdef __COMPILE_155
	else if (__choose0 == 156)
	{
	//AddInitKind
	memset((tif)->tif_foundfield, 0, sizeof (*((tif)->tif_foundfield)));
	}
	#endif
	#ifdef __COMPILE_156
	else if (__choose0 == 157)
	{
	//AddInitKind
	memset((tif)->tif_mapproc, 0, sizeof (*((tif)->tif_mapproc)));
	}
	#endif
	#ifdef __COMPILE_157
	else if (__choose0 == 158)
	{
	//AddInitKind
	memset((tif)->tif_name, 0, sizeof (*((tif)->tif_name)));
	}
	#endif
	#ifdef __COMPILE_158
	else if (__choose0 == 159)
	{
	//AddInitKind
	memset((tif)->tif_postdecode, 0, sizeof (*((tif)->tif_postdecode)));
	}
	#endif
	#ifdef __COMPILE_159
	else if (__choose0 == 160)
	{
	//AddInitKind
	memset((tif)->tif_postencode, 0, sizeof (*((tif)->tif_postencode)));
	}
	#endif
	#ifdef __COMPILE_160
	else if (__choose0 == 161)
	{
	//AddInitKind
	memset((tif)->tif_predecode, 0, sizeof (*((tif)->tif_predecode)));
	}
	#endif
	#ifdef __COMPILE_161
	else if (__choose0 == 162)
	{
	//AddInitKind
	memset((tif)->tif_preencode, 0, sizeof (*((tif)->tif_preencode)));
	}
	#endif
	#ifdef __COMPILE_162
	else if (__choose0 == 163)
	{
	//AddInitKind
	memset((tif)->tif_rawcp, 0, sizeof (*((tif)->tif_rawcp)));
	}
	#endif
	#ifdef __COMPILE_163
	else if (__choose0 == 164)
	{
	//AddInitKind
	memset((tif)->tif_rawdata, 0, sizeof (*((tif)->tif_rawdata)));
	}
	#endif
	#ifdef __COMPILE_164
	else if (__choose0 == 165)
	{
	//AddInitKind
	memset((tif)->tif_readproc, 0, sizeof (*((tif)->tif_readproc)));
	}
	#endif
	#ifdef __COMPILE_165
	else if (__choose0 == 166)
	{
	//AddInitKind
	memset((tif)->tif_seek, 0, sizeof (*((tif)->tif_seek)));
	}
	#endif
	#ifdef __COMPILE_166
	else if (__choose0 == 167)
	{
	//AddInitKind
	memset((tif)->tif_seekproc, 0, sizeof (*((tif)->tif_seekproc)));
	}
	#endif
	#ifdef __COMPILE_167
	else if (__choose0 == 168)
	{
	//AddInitKind
	memset((tif)->tif_setupdecode, 0, sizeof (*((tif)->tif_setupdecode)));
	}
	#endif
	#ifdef __COMPILE_168
	else if (__choose0 == 169)
	{
	//AddInitKind
	memset((tif)->tif_setupencode, 0, sizeof (*((tif)->tif_setupencode)));
	}
	#endif
	#ifdef __COMPILE_169
	else if (__choose0 == 170)
	{
	//AddInitKind
	memset((tif)->tif_sizeproc, 0, sizeof (*((tif)->tif_sizeproc)));
	}
	#endif
	#ifdef __COMPILE_170
	else if (__choose0 == 171)
	{
	//AddInitKind
	memset((tif)->tif_typemask, 0, sizeof (*((tif)->tif_typemask)));
	}
	#endif
	#ifdef __COMPILE_171
	else if (__choose0 == 172)
	{
	//AddInitKind
	memset((tif)->tif_typeshift, 0, sizeof (*((tif)->tif_typeshift)));
	}
	#endif
	#ifdef __COMPILE_172
	else if (__choose0 == 173)
	{
	//AddInitKind
	memset((tif)->tif_unmapproc, 0, sizeof (*((tif)->tif_unmapproc)));
	}
	#endif
	#ifdef __COMPILE_173
	else if (__choose0 == 174)
	{
	//AddInitKind
	memset((tif)->tif_writeproc, 0, sizeof (*((tif)->tif_writeproc)));
	}
	#endif
	#ifdef __COMPILE_174
	else if (__choose0 == 175)
	{
	//AddInitKind
	memset(TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, 0, sizeof (*(TIFFFieldWithTag(tif, dir->tdir_tag)->field_name)));
	}
	#endif
	#ifdef __COMPILE_175
	else if (__choose0 == 176)
	{
	//AddInitKind
	memset(dir, 0, sizeof (*(dir)));
	}
	#endif
	#ifdef __COMPILE_176
	else if (__choose0 == 177)
	{
	//AddInitKind
	memset(tif->tif_base, 0, sizeof (*(tif->tif_base)));
	}
	#endif
	#ifdef __COMPILE_177
	else if (__choose0 == 178)
	{
	//AddInitKind
	memset(tif->tif_cleanup, 0, sizeof (*(tif->tif_cleanup)));
	}
	#endif
	#ifdef __COMPILE_178
	else if (__choose0 == 179)
	{
	//AddInitKind
	memset(tif->tif_clientdata, 0, sizeof (*(tif->tif_clientdata)));
	}
	#endif
	#ifdef __COMPILE_179
	else if (__choose0 == 180)
	{
	//AddInitKind
	memset(tif->tif_clientinfo, 0, sizeof (*(tif->tif_clientinfo)));
	}
	#endif
	#ifdef __COMPILE_180
	else if (__choose0 == 181)
	{
	//AddInitKind
	memset(tif->tif_close, 0, sizeof (*(tif->tif_close)));
	}
	#endif
	#ifdef __COMPILE_181
	else if (__choose0 == 182)
	{
	//AddInitKind
	memset(tif->tif_closeproc, 0, sizeof (*(tif->tif_closeproc)));
	}
	#endif
	#ifdef __COMPILE_182
	else if (__choose0 == 183)
	{
	//AddInitKind
	memset(tif->tif_data, 0, sizeof (*(tif->tif_data)));
	}
	#endif
	#ifdef __COMPILE_183
	else if (__choose0 == 184)
	{
	//AddInitKind
	memset(tif->tif_decoderow, 0, sizeof (*(tif->tif_decoderow)));
	}
	#endif
	#ifdef __COMPILE_184
	else if (__choose0 == 185)
	{
	//AddInitKind
	memset(tif->tif_decodestrip, 0, sizeof (*(tif->tif_decodestrip)));
	}
	#endif
	#ifdef __COMPILE_185
	else if (__choose0 == 186)
	{
	//AddInitKind
	memset(tif->tif_decodetile, 0, sizeof (*(tif->tif_decodetile)));
	}
	#endif
	#ifdef __COMPILE_186
	else if (__choose0 == 187)
	{
	//AddInitKind
	memset(tif->tif_defstripsize, 0, sizeof (*(tif->tif_defstripsize)));
	}
	#endif
	#ifdef __COMPILE_187
	else if (__choose0 == 188)
	{
	//AddInitKind
	memset(tif->tif_deftilesize, 0, sizeof (*(tif->tif_deftilesize)));
	}
	#endif
	#ifdef __COMPILE_188
	else if (__choose0 == 189)
	{
	//AddInitKind
	memset(tif->tif_dirlist, 0, sizeof (*(tif->tif_dirlist)));
	}
	#endif
	#ifdef __COMPILE_189
	else if (__choose0 == 190)
	{
	//AddInitKind
	memset(tif->tif_encoderow, 0, sizeof (*(tif->tif_encoderow)));
	}
	#endif
	#ifdef __COMPILE_190
	else if (__choose0 == 191)
	{
	//AddInitKind
	memset(tif->tif_encodestrip, 0, sizeof (*(tif->tif_encodestrip)));
	}
	#endif
	#ifdef __COMPILE_191
	else if (__choose0 == 192)
	{
	//AddInitKind
	memset(tif->tif_encodetile, 0, sizeof (*(tif->tif_encodetile)));
	}
	#endif
	#ifdef __COMPILE_192
	else if (__choose0 == 193)
	{
	//AddInitKind
	memset(tif->tif_fieldinfo, 0, sizeof (*(tif->tif_fieldinfo)));
	}
	#endif
	#ifdef __COMPILE_193
	else if (__choose0 == 194)
	{
	//AddInitKind
	memset(tif->tif_foundfield, 0, sizeof (*(tif->tif_foundfield)));
	}
	#endif
	#ifdef __COMPILE_194
	else if (__choose0 == 195)
	{
	//AddInitKind
	memset(tif->tif_mapproc, 0, sizeof (*(tif->tif_mapproc)));
	}
	#endif
	#ifdef __COMPILE_195
	else if (__choose0 == 196)
	{
	//AddInitKind
	memset(tif->tif_name, 0, sizeof (*(tif->tif_name)));
	}
	#endif
	#ifdef __COMPILE_196
	else if (__choose0 == 197)
	{
	//AddInitKind
	memset(tif->tif_postdecode, 0, sizeof (*(tif->tif_postdecode)));
	}
	#endif
	#ifdef __COMPILE_197
	else if (__choose0 == 198)
	{
	//AddInitKind
	memset(tif->tif_postencode, 0, sizeof (*(tif->tif_postencode)));
	}
	#endif
	#ifdef __COMPILE_198
	else if (__choose0 == 199)
	{
	//AddInitKind
	memset(tif->tif_predecode, 0, sizeof (*(tif->tif_predecode)));
	}
	#endif
	#ifdef __COMPILE_199
	else if (__choose0 == 200)
	{
	//AddInitKind
	memset(tif->tif_preencode, 0, sizeof (*(tif->tif_preencode)));
	}
	#endif
	#ifdef __COMPILE_200
	else if (__choose0 == 201)
	{
	//AddInitKind
	memset(tif->tif_rawcp, 0, sizeof (*(tif->tif_rawcp)));
	}
	#endif
	#ifdef __COMPILE_201
	else if (__choose0 == 202)
	{
	//AddInitKind
	memset(tif->tif_rawdata, 0, sizeof (*(tif->tif_rawdata)));
	}
	#endif
	#ifdef __COMPILE_202
	else if (__choose0 == 203)
	{
	//AddInitKind
	memset(tif->tif_readproc, 0, sizeof (*(tif->tif_readproc)));
	}
	#endif
	#ifdef __COMPILE_203
	else if (__choose0 == 204)
	{
	//AddInitKind
	memset(tif->tif_seek, 0, sizeof (*(tif->tif_seek)));
	}
	#endif
	#ifdef __COMPILE_204
	else if (__choose0 == 205)
	{
	//AddInitKind
	memset(tif->tif_seekproc, 0, sizeof (*(tif->tif_seekproc)));
	}
	#endif
	#ifdef __COMPILE_205
	else if (__choose0 == 206)
	{
	//AddInitKind
	memset(tif->tif_setupdecode, 0, sizeof (*(tif->tif_setupdecode)));
	}
	#endif
	#ifdef __COMPILE_206
	else if (__choose0 == 207)
	{
	//AddInitKind
	memset(tif->tif_setupencode, 0, sizeof (*(tif->tif_setupencode)));
	}
	#endif
	#ifdef __COMPILE_207
	else if (__choose0 == 208)
	{
	//AddInitKind
	memset(tif->tif_sizeproc, 0, sizeof (*(tif->tif_sizeproc)));
	}
	#endif
	#ifdef __COMPILE_208
	else if (__choose0 == 209)
	{
	//AddInitKind
	memset(tif->tif_typemask, 0, sizeof (*(tif->tif_typemask)));
	}
	#endif
	#ifdef __COMPILE_209
	else if (__choose0 == 210)
	{
	//AddInitKind
	memset(tif->tif_typeshift, 0, sizeof (*(tif->tif_typeshift)));
	}
	#endif
	#ifdef __COMPILE_210
	else if (__choose0 == 211)
	{
	//AddInitKind
	memset(tif->tif_unmapproc, 0, sizeof (*(tif->tif_unmapproc)));
	}
	#endif
	#ifdef __COMPILE_211
	else if (__choose0 == 212)
	{
	//AddInitKind
	memset(tif->tif_writeproc, 0, sizeof (*(tif->tif_writeproc)));
	}
	#endif
	#ifdef __COMPILE_212
	else if (__choose0 == 213)
	{
	//AddStmtAndReplaceAtomKind
	((((tif))->tif_dir.td_fieldsset[(24) / 32]) |= (((unsigned long)1L) << ((24) & 31)));
	}
	#endif
	#ifdef __COMPILE_213
	else if (__choose0 == 214)
	{
	//AddStmtAndReplaceAtomKind
	(tif)->tif_curdir++;
	}
	#endif
	#ifdef __COMPILE_214
	else if (__choose0 == 215)
	{
	//AddStmtAndReplaceAtomKind
	(tif)->tif_dirnumber++;
	}
	#endif
	#ifdef __COMPILE_215
	else if (__choose0 == 216)
	{
	//AddStmtAndReplaceAtomKind
	ChopUpSingleUncompressedStrip((tif));
	}
	#endif
	#ifdef __COMPILE_216
	else if (__choose0 == 217)
	{
	//AddStmtAndReplaceAtomKind
	MissingRequired((tif), "Colormap");
	}
	#endif
	#ifdef __COMPILE_217
	else if (__choose0 == 218)
	{
	//AddStmtAndReplaceAtomKind
	MissingRequired((tif), "ImageLength");
	}
	#endif
	#ifdef __COMPILE_218
	else if (__choose0 == 219)
	{
	//AddStmtAndReplaceAtomKind
	MissingRequired((tif), "PlanarConfiguration");
	}
	#endif
	#ifdef __COMPILE_219
	else if (__choose0 == 220)
	{
	//AddStmtAndReplaceAtomKind
	MissingRequired((tif), "StripByteCounts");
	}
	#endif
	#ifdef __COMPILE_220
	else if (__choose0 == 221)
	{
	//AddStmtAndReplaceAtomKind
	TIFFDefaultDirectory((tif));
	}
	#endif
	#ifdef __COMPILE_221
	else if (__choose0 == 222)
	{
	//AddStmtAndReplaceAtomKind
	TIFFFreeDirectory((tif));
	}
	#endif
	#ifdef __COMPILE_222
	else if (__choose0 == 223)
	{
	//AddStmtAndReplaceAtomKind
	TIFFSetField((tif), 259, 1);
	}
	#endif
	#ifdef __COMPILE_223
	else if (__choose0 == 224)
	{
	//AddStmtAndReplaceAtomKind
	TIFFSetField((tif), 284, 1);
	}
	#endif
	#ifdef __COMPILE_224
	else if (__choose0 == 225)
	{
	//AddStmtAndReplaceAtomKind
	TIFFSwabArrayOfLong(&(dir)->tdir_count, 2);
	}
	#endif
	#ifdef __COMPILE_225
	else if (__choose0 == 226)
	{
	//AddStmtAndReplaceAtomKind
	TIFFSwabArrayOfShort(&(dir)->tdir_tag, 2);
	}
	#endif
	#ifdef __COMPILE_226
	else if (__choose0 == 227)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFfree((cp));
	}
	#endif
	#ifdef __COMPILE_227
	else if (__choose0 == 228)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFfree((dir));
	}
	#endif
	#ifdef __COMPILE_228
	else if (__choose0 == 229)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy((cp), tif->tif_base + dir->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_229
	else if (__choose0 == 230)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy(cp && !(1 << 5), tif->tif_base + dir->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_230
	else if (__choose0 == 231)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy(cp, (tif)->tif_base + dir->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_231
	else if (__choose0 == 232)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy(cp, tif && !(1 << 5)->tif_base + dir->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_232
	else if (__choose0 == 233)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy(cp, tif->tif_base + (dir)->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_233
	else if (__choose0 == 234)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy(cp, tif->tif_base + dir && !(1 << 5)->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_234
	else if (__choose0 == 235)
	{
	//AddStmtAndReplaceAtomKind
	_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc && !(1 << 5));
	}
	#endif
	#ifdef __COMPILE_235
	else if (__choose0 == 236)
	{
	//AddStmtKind
	_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);
	}
	#endif
	#ifdef __COMPILE_236
	else if (__choose0 == 237)
	{
	//IfExitKind
	if (__is_neg("0-237", "L977", 9, &(dir), sizeof (dir), &(w),
				 sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif),
				 sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp),
				 sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)))
	    goto bad;
	}
	#endif
	#ifdef __COMPILE_237
	else if (__choose0 == 238)
	{
	//IfExitKind
	if (__is_neg("0-238", "L977", 9, &(dir), sizeof (dir), &(w),
				 sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif),
				 sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp),
				 sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)))
	    return 0;
	}
	#endif
	#ifdef __COMPILE_238
	else if (__choose0 == 239)
	{
	//IfExitKind
	if (__is_neg("0-239", "L977", 9, &(dir), sizeof (dir), &(w),
				 sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif),
				 sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp),
				 sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)))
	    return 128;
	}
	#endif
	#ifdef __COMPILE_239
	else if (__choose0 == 240)
	{
	//IfExitKind
	if (__is_neg("0-240", "L977", 9, &(dir), sizeof (dir), &(w),
				 sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif),
				 sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp),
				 sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)))
	    return 2048;
	}
	#endif
	#ifdef __COMPILE_240
	else if (__choose0 == 241)
	{
	//IfExitKind
	if (__is_neg("0-241", "L977", 9, &(dir), sizeof (dir), &(w),
				 sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif),
				 sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp),
				 sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)))
	    return 2;
	}
	#endif
	int __choose1 = __choose("__SWITCH1");
	{
	int __temp1=(!dir->tdir_count || !w || (tsize_t)dir->tdir_count / w != cc)
	;
	if (__choose1 == 0)
	{}
	#ifdef __COMPILE_241
	else if (__choose1 == 1)
	{
	__temp1= (__is_neg("1-1", "L977", 9, &(dir), sizeof (dir), &(w), sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif), sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp), sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)));
	}
	#endif
	#ifdef __COMPILE_242
	else if (__choose1 == 2)
	{
	__temp1= ((!dir->tdir_count || !w || (tsize_t)dir->tdir_count / w != cc) || __is_neg("1-2", "L977", 9, &(dir), sizeof (dir), &(w), sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif), sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp), sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)));
	}
	#endif
	#ifdef __COMPILE_243
	else if (__choose1 == 3)
	{
	__temp1= (!dir->tdir_count || !w || (tsize_t)dir->tdir_count != cc / w);
	}
	#endif
	#ifdef __COMPILE_244
	else if (__choose1 == 4)
	{
	__temp1= (!dir->tdir_count || !w);
	}
	#endif
	#ifdef __COMPILE_245
	else if (__choose1 == 5)
	{
	__temp1= (!dir->tdir_count || (tsize_t)dir->tdir_count / w != cc);
	}
	#endif
	#ifdef __COMPILE_246
	else if (__choose1 == 6)
	{
	__temp1= (!w || (tsize_t)dir->tdir_count / w != cc);
	}
	#endif
	#ifdef __COMPILE_247
	else if (__choose1 == 7)
	{
	__temp1= ((!dir->tdir_count || !w || (tsize_t)dir->tdir_count / w != cc) && !__is_neg("1-7", "L977", 9, &(dir), sizeof (dir), &(w), sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif), sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp), sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)));
	}
	#endif
	int __choose2 = __choose("__SWITCH2");
	if (__choose2 == 0)
	{
	if (__temp1)
			goto bad;
	
	}
	#ifdef __COMPILE_248
	else if (__choose2 == 1)
	{
	//GuardKind
	if (!__is_neg("2-1", "L977", 9, &(dir), sizeof (dir), &(w), sizeof (w), &(cc), sizeof (cc), &(dir->tdir_count), sizeof (dir->tdir_count), &(tif), sizeof (tif), &(dir->tdir_type), sizeof (dir->tdir_type), &(dir->tdir_offset), sizeof (dir->tdir_offset), &(cp), sizeof (cp), &(dir->tdir_tag), sizeof (dir->tdir_tag)))
	    if (!dir->tdir_count || !w || (tsize_t)dir->tdir_count / w != cc)
	        goto bad;
	
	}
	#endif
	}
	}

	if (!isMapped(tif)) {
		if (!SeekOK(tif, dir->tdir_offset))
			goto bad;
		if (!ReadOK(tif, cp, cc))
			goto bad;
	} else {
		tsize_t offset = dir->tdir_offset + cc;
		/* Check for overflow. */
		if ((tsize_t)dir->tdir_offset != offset - cc
		    || offset > (tsize_t)tif->tif_size)
			goto bad;
		_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);
	}
	if (tif->tif_flags & TIFF_SWAB) {
		switch (dir->tdir_type) {
		case TIFF_SHORT:
		case TIFF_SSHORT:
			TIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);
			break;
		case TIFF_LONG:
		case TIFF_SLONG:
		case TIFF_FLOAT:
			TIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);
			break;
		case TIFF_RATIONAL:
		case TIFF_SRATIONAL:
			TIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);
			break;
		case TIFF_DOUBLE:
			TIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);
			break;
		}
	}
	return (cc);
bad:
	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
		     "Error fetching data for field \"%s\"",
		     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
	return (tsize_t) 0;
}

/*
 * Fetch an ASCII item from the file.
 */
static tsize_t
TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)
{
	if (dir->tdir_count <= 4) {
		uint32 l = dir->tdir_offset;
		if (tif->tif_flags & TIFF_SWAB)
			TIFFSwabLong(&l);
		_TIFFmemcpy(cp, &l, dir->tdir_count);
		return (1);
	}
	return (TIFFFetchData(tif, dir, cp));
}

/*
 * Convert numerator+denominator to float.
 */
static int
cvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv)
{
	if (denom == 0) {
		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
		    "%s: Rational with zero denominator (num = %lu)",
		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);
		return (0);
	} else {
		if (dir->tdir_type == TIFF_RATIONAL)
			*rv = ((float)num / (float)denom);
		else
			*rv = ((float)(int32)num / (float)(int32)denom);
		return (1);
	}
}

/*
 * Fetch a rational item from the file
 * at offset off and return the value
 * as a floating point number.
 */
static float
TIFFFetchRational(TIFF* tif, TIFFDirEntry* dir)
{
	uint32 l[2];
	float v;

	return (!TIFFFetchData(tif, dir, (char *)l) ||
	    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);
}

/*
 * Fetch a single floating point value
 * from the offset field and return it
 * as a native float.
 */
static float
TIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir)
{
	float v;
	int32 l = TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);
        _TIFFmemcpy(&v, &l, sizeof(float));
	TIFFCvtIEEEFloatToNative(tif, 1, &v);
	return (v);
}

/*
 * Fetch an array of BYTE or SBYTE values.
 */
static int
TIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint8* v)
{
    if (dir->tdir_count <= 4) {
        /*
         * Extract data from offset field.
         */
        if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
	    if (dir->tdir_type == TIFF_SBYTE)
                switch (dir->tdir_count) {
                    case 4: v[3] = dir->tdir_offset & 0xff;
                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;
                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;
		    case 1: v[0] = dir->tdir_offset >> 24;
                }
	    else
                switch (dir->tdir_count) {
                    case 4: v[3] = dir->tdir_offset & 0xff;
                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;
                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;
		    case 1: v[0] = dir->tdir_offset >> 24;
                }
	} else {
	    if (dir->tdir_type == TIFF_SBYTE)
                switch (dir->tdir_count) {
                    case 4: v[3] = dir->tdir_offset >> 24;
                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;
                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;
                    case 1: v[0] = dir->tdir_offset & 0xff;
		}
	    else
                switch (dir->tdir_count) {
                    case 4: v[3] = dir->tdir_offset >> 24;
                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;
                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;
                    case 1: v[0] = dir->tdir_offset & 0xff;
		}
	}
        return (1);
    } else
        return (TIFFFetchData(tif, dir, (char*) v) != 0);	/* XXX */
}

/*
 * Fetch an array of SHORT or SSHORT values.
 */
static int
TIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)
{
	if (dir->tdir_count <= 2) {
		if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
			switch (dir->tdir_count) {
			case 2: v[1] = (uint16) (dir->tdir_offset & 0xffff);
			case 1: v[0] = (uint16) (dir->tdir_offset >> 16);
			}
		} else {
			switch (dir->tdir_count) {
			case 2: v[1] = (uint16) (dir->tdir_offset >> 16);
			case 1: v[0] = (uint16) (dir->tdir_offset & 0xffff);
			}
		}
		return (1);
	} else
		return (TIFFFetchData(tif, dir, (char *)v) != 0);
}

/*
 * Fetch a pair of SHORT or BYTE values. Some tags may have either BYTE
 * or SHORT type and this function works with both ones.
 */
static int
TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)
{
	switch (dir->tdir_type) {
		case TIFF_BYTE:
		case TIFF_SBYTE:
			{
			uint8 v[4];
			return TIFFFetchByteArray(tif, dir, v)
				&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);
			}
		case TIFF_SHORT:
		case TIFF_SSHORT:
			{
			uint16 v[2];
			return TIFFFetchShortArray(tif, dir, v)
				&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);
			}
		default:
			return 0;
	}
}

/*
 * Fetch an array of LONG or SLONG values.
 */
static int
TIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v)
{
	if (dir->tdir_count == 1) {
		v[0] = dir->tdir_offset;
		return (1);
	} else
		return (TIFFFetchData(tif, dir, (char*) v) != 0);
}

/*
 * Fetch an array of RATIONAL or SRATIONAL values.
 */
static int
TIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)
{
	int ok = 0;
	uint32* l;

	l = (uint32*)_TIFFCheckMalloc(tif,
	    dir->tdir_count, TIFFDataWidth((TIFFDataType) dir->tdir_type),
	    "to fetch array of rationals");
	if (l) {
		if (TIFFFetchData(tif, dir, (char *)l)) {
			uint32 i;
			for (i = 0; i < dir->tdir_count; i++) {
				ok = cvtRational(tif, dir,
				    l[2*i+0], l[2*i+1], &v[i]);
				if (!ok)
					break;
			}
		}
		_TIFFfree((char *)l);
	}
	return (ok);
}

/*
 * Fetch an array of FLOAT values.
 */
static int
TIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v)
{

	if (dir->tdir_count == 1) {
		v[0] = *(float*) &dir->tdir_offset;
		TIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);
		return (1);
	} else	if (TIFFFetchData(tif, dir, (char*) v)) {
		TIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);
		return (1);
	} else
		return (0);
}

/*
 * Fetch an array of DOUBLE values.
 */
static int
TIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v)
{
	if (TIFFFetchData(tif, dir, (char*) v)) {
		TIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v);
		return (1);
	} else
		return (0);
}

/*
 * Fetch an array of ANY values.  The actual values are
 * returned as doubles which should be able hold all the
 * types.  Yes, there really should be an tany_t to avoid
 * this potential non-portability ...  Note in particular
 * that we assume that the double return value vector is
 * large enough to read in any fundamental type.  We use
 * that vector as a buffer to read in the base type vector
 * and then convert it in place to double (from end
 * to front of course).
 */
static int
TIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v)
{
	int i;

	switch (dir->tdir_type) {
	case TIFF_BYTE:
	case TIFF_SBYTE:
		if (!TIFFFetchByteArray(tif, dir, (uint8*) v))
			return (0);
		if (dir->tdir_type == TIFF_BYTE) {
			uint8* vp = (uint8*) v;
			for (i = dir->tdir_count-1; i >= 0; i--)
				v[i] = vp[i];
		} else {
			int8* vp = (int8*) v;
			for (i = dir->tdir_count-1; i >= 0; i--)
				v[i] = vp[i];
		}
		break;
	case TIFF_SHORT:
	case TIFF_SSHORT:
		if (!TIFFFetchShortArray(tif, dir, (uint16*) v))
			return (0);
		if (dir->tdir_type == TIFF_SHORT) {
			uint16* vp = (uint16*) v;
			for (i = dir->tdir_count-1; i >= 0; i--)
				v[i] = vp[i];
		} else {
			int16* vp = (int16*) v;
			for (i = dir->tdir_count-1; i >= 0; i--)
				v[i] = vp[i];
		}
		break;
	case TIFF_LONG:
	case TIFF_SLONG:
		if (!TIFFFetchLongArray(tif, dir, (uint32*) v))
			return (0);
		if (dir->tdir_type == TIFF_LONG) {
			uint32* vp = (uint32*) v;
			for (i = dir->tdir_count-1; i >= 0; i--)
				v[i] = vp[i];
		} else {
			int32* vp = (int32*) v;
			for (i = dir->tdir_count-1; i >= 0; i--)
				v[i] = vp[i];
		}
		break;
	case TIFF_RATIONAL:
	case TIFF_SRATIONAL:
		if (!TIFFFetchRationalArray(tif, dir, (float*) v))
			return (0);
		{ float* vp = (float*) v;
		  for (i = dir->tdir_count-1; i >= 0; i--)
			v[i] = vp[i];
		}
		break;
	case TIFF_FLOAT:
		if (!TIFFFetchFloatArray(tif, dir, (float*) v))
			return (0);
		{ float* vp = (float*) v;
		  for (i = dir->tdir_count-1; i >= 0; i--)
			v[i] = vp[i];
		}
		break;
	case TIFF_DOUBLE:
		return (TIFFFetchDoubleArray(tif, dir, (double*) v));
	default:
		/* TIFF_NOTYPE */
		/* TIFF_ASCII */
		/* TIFF_UNDEFINED */
		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
		    "cannot read TIFF_ANY type %d for field \"%s\"",
		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
		return (0);
	}
	return (1);
}

/*
 * Fetch a tag that is not handled by special case code.
 */
static int
TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)
{
	static const char mesg[] = "to fetch tag value";
	int ok = 0;
	const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dp->tdir_tag);

	if (dp->tdir_count > 1) {		/* array of values */
		char* cp = NULL;

		switch (dp->tdir_type) {
		case TIFF_BYTE:
		case TIFF_SBYTE:
			cp = (char *)_TIFFCheckMalloc(tif,
			    dp->tdir_count, sizeof (uint8), mesg);
			ok = cp && TIFFFetchByteArray(tif, dp, (uint8*) cp);
			break;
		case TIFF_SHORT:
		case TIFF_SSHORT:
			cp = (char *)_TIFFCheckMalloc(tif,
			    dp->tdir_count, sizeof (uint16), mesg);
			ok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);
			break;
		case TIFF_LONG:
		case TIFF_SLONG:
			cp = (char *)_TIFFCheckMalloc(tif,
			    dp->tdir_count, sizeof (uint32), mesg);
			ok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);
			break;
		case TIFF_RATIONAL:
		case TIFF_SRATIONAL:
			cp = (char *)_TIFFCheckMalloc(tif,
			    dp->tdir_count, sizeof (float), mesg);
			ok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);
			break;
		case TIFF_FLOAT:
			cp = (char *)_TIFFCheckMalloc(tif,
			    dp->tdir_count, sizeof (float), mesg);
			ok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);
			break;
		case TIFF_DOUBLE:
			cp = (char *)_TIFFCheckMalloc(tif,
			    dp->tdir_count, sizeof (double), mesg);
			ok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);
			break;
		case TIFF_ASCII:
		case TIFF_UNDEFINED:		/* bit of a cheat... */
			/*
			 * Some vendors write strings w/o the trailing
			 * NULL byte, so always append one just in case.
			 */
			cp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count + 1,
						      1, mesg);
			if( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )
				cp[dp->tdir_count] = '\0';	/* XXX */
			break;
		}
		if (ok) {
			ok = (fip->field_passcount ?
			    TIFFSetField(tif, dp->tdir_tag, dp->tdir_count, cp)
			  : TIFFSetField(tif, dp->tdir_tag, cp));
		}
		if (cp != NULL)
			_TIFFfree(cp);
	} else if (CheckDirCount(tif, dp, 1)) {	/* singleton value */
		switch (dp->tdir_type) {
		case TIFF_BYTE:
		case TIFF_SBYTE:
		case TIFF_SHORT:
		case TIFF_SSHORT:
			/*
			 * If the tag is also acceptable as a LONG or SLONG
			 * then TIFFSetField will expect an uint32 parameter
			 * passed to it (through varargs).  Thus, for machines
			 * where sizeof (int) != sizeof (uint32) we must do
			 * a careful check here.  It's hard to say if this
			 * is worth optimizing.
			 *
			 * NB: We use TIFFFieldWithTag here knowing that
			 *     it returns us the first entry in the table
			 *     for the tag and that that entry is for the
			 *     widest potential data type the tag may have.
			 */
			{ TIFFDataType type = fip->field_type;
			  if (type != TIFF_LONG && type != TIFF_SLONG) {
				uint16 v = (uint16)
			   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);
				ok = (fip->field_passcount ?
				    TIFFSetField(tif, dp->tdir_tag, 1, &v)
				  : TIFFSetField(tif, dp->tdir_tag, v));
				break;
			  }
			}
			/* fall thru... */
		case TIFF_LONG:
		case TIFF_SLONG:
			{ uint32 v32 =
		    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);
			  ok = (fip->field_passcount ? 
			      TIFFSetField(tif, dp->tdir_tag, 1, &v32)
			    : TIFFSetField(tif, dp->tdir_tag, v32));
			}
			break;
		case TIFF_RATIONAL:
		case TIFF_SRATIONAL:
		case TIFF_FLOAT:
			{ float v = (dp->tdir_type == TIFF_FLOAT ? 
			      TIFFFetchFloat(tif, dp)
			    : TIFFFetchRational(tif, dp));
			  ok = (fip->field_passcount ?
			      TIFFSetField(tif, dp->tdir_tag, 1, &v)
			    : TIFFSetField(tif, dp->tdir_tag, v));
			}
			break;
		case TIFF_DOUBLE:
			{ double v;
			  ok = (TIFFFetchDoubleArray(tif, dp, &v) &&
			    (fip->field_passcount ?
			      TIFFSetField(tif, dp->tdir_tag, 1, &v)
			    : TIFFSetField(tif, dp->tdir_tag, v))
			  );
			}
			break;
		case TIFF_ASCII:
		case TIFF_UNDEFINED:		/* bit of a cheat... */
			{ char c[2];
			  if( (ok = (TIFFFetchString(tif, dp, c) != 0)) != 0 ) {
				c[1] = '\0';		/* XXX paranoid */
				ok = (fip->field_passcount ?
					TIFFSetField(tif, dp->tdir_tag, 1, c)
				      : TIFFSetField(tif, dp->tdir_tag, c));
			  }
			}
			break;
		}
	}
	return (ok);
}

#define	NITEMS(x)	(sizeof (x) / sizeof (x[0]))
/*
 * Fetch samples/pixel short values for 
 * the specified tag and verify that
 * all values are the same.
 */
static int
TIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, uint16* pl)
{
    uint16 samples = tif->tif_dir.td_samplesperpixel;
    int status = 0;

    if (CheckDirCount(tif, dir, (uint32) samples)) {
        uint16 buf[10];
        uint16* v = buf;

        if (dir->tdir_count > NITEMS(buf))
            v = (uint16*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint16),
                                      "to fetch per-sample values");
        if (v && TIFFFetchShortArray(tif, dir, v)) {
            uint16 i;
            int check_count = dir->tdir_count;
            if( samples < check_count )
                check_count = samples;

            for (i = 1; i < check_count; i++)
                if (v[i] != v[0]) {
					TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                              "Cannot handle different per-sample values for field \"%s\"",
                              _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
                    goto bad;
                }
            *pl = v[0];
            status = 1;
        }
      bad:
        if (v && v != buf)
            _TIFFfree(v);
    }
    return (status);
}

/*
 * Fetch samples/pixel long values for 
 * the specified tag and verify that
 * all values are the same.
 */
static int
TIFFFetchPerSampleLongs(TIFF* tif, TIFFDirEntry* dir, uint32* pl)
{
    uint16 samples = tif->tif_dir.td_samplesperpixel;
    int status = 0;

    if (CheckDirCount(tif, dir, (uint32) samples)) {
        uint32 buf[10];
        uint32* v = buf;

        if (dir->tdir_count > NITEMS(buf))
            v = (uint32*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint32),
                                      "to fetch per-sample values");
        if (v && TIFFFetchLongArray(tif, dir, v)) {
            uint16 i;
            int check_count = dir->tdir_count;

            if( samples < check_count )
                check_count = samples;
            for (i = 1; i < check_count; i++)
                if (v[i] != v[0]) {
					TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                              "Cannot handle different per-sample values for field \"%s\"",
                              _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
                    goto bad;
                }
            *pl = v[0];
            status = 1;
        }
      bad:
        if (v && v != buf)
            _TIFFfree(v);
    }
    return (status);
}

/*
 * Fetch samples/pixel ANY values for the specified tag and verify that all
 * values are the same.
 */
static int
TIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl)
{
    uint16 samples = tif->tif_dir.td_samplesperpixel;
    int status = 0;

    if (CheckDirCount(tif, dir, (uint32) samples)) {
        double buf[10];
        double* v = buf;

        if (dir->tdir_count > NITEMS(buf))
            v = (double*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (double),
                                      "to fetch per-sample values");
        if (v && TIFFFetchAnyArray(tif, dir, v)) {
            uint16 i;
            int check_count = dir->tdir_count;
            if( samples < check_count )
                check_count = samples;

            for (i = 1; i < check_count; i++)
                if (v[i] != v[0]) {
                    TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                              "Cannot handle different per-sample values for field \"%s\"",
                              _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
                    goto bad;
                }
            *pl = v[0];
            status = 1;
        }
      bad:
        if (v && v != buf)
            _TIFFfree(v);
    }
    return (status);
}
#undef NITEMS

/*
 * Fetch a set of offsets or lengths.
 * While this routine says "strips", in fact it's also used for tiles.
 */
static int
TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp)
{
	register uint32* lp;
	int status;

        CheckDirCount(tif, dir, (uint32) nstrips);

	/*
	 * Allocate space for strip information.
	 */
	if (*lpp == NULL &&
	    (*lpp = (uint32 *)_TIFFCheckMalloc(tif,
	      nstrips, sizeof (uint32), "for strip array")) == NULL)
		return (0);
	lp = *lpp;
        _TIFFmemset( lp, 0, sizeof(uint32) * nstrips );

	if (dir->tdir_type == (int)TIFF_SHORT) {
		/*
		 * Handle uint16->uint32 expansion.
		 */
		uint16* dp = (uint16*) _TIFFCheckMalloc(tif,
		    dir->tdir_count, sizeof (uint16), "to fetch strip tag");
		if (dp == NULL)
			return (0);
		if( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) {
                    int i;
                    
                    for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )
                    {
                        lp[i] = dp[i];
                    }
		}
		_TIFFfree((char*) dp);

        } else if( nstrips != (int) dir->tdir_count ) {
            /* Special case to correct length */

            uint32* dp = (uint32*) _TIFFCheckMalloc(tif,
		    dir->tdir_count, sizeof (uint32), "to fetch strip tag");
            if (dp == NULL)
                return (0);

            status = TIFFFetchLongArray(tif, dir, dp);
            if( status != 0 ) {
                int i;

                for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )
                {
                    lp[i] = dp[i];
                }
            }

            _TIFFfree( (char *) dp );
	} else
            status = TIFFFetchLongArray(tif, dir, lp);
        
	return (status);
}

/*
 * Fetch and set the RefBlackWhite tag.
 */
static int
TIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir)
{
	static const char mesg[] = "for \"ReferenceBlackWhite\" array";
	char* cp;
	int ok;

	if (dir->tdir_type == TIFF_RATIONAL)
		return (TIFFFetchNormalTag(tif, dir));
	/*
	 * Handle LONG's for backward compatibility.
	 */
	cp = (char *)_TIFFCheckMalloc(tif, dir->tdir_count,
				      sizeof (uint32), mesg);
	if( (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) != 0) {
		float* fp = (float*)
		    _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (float), mesg);
		if( (ok = (fp != NULL)) != 0 ) {
			uint32 i;
			for (i = 0; i < dir->tdir_count; i++)
				fp[i] = (float)((uint32*) cp)[i];
			ok = TIFFSetField(tif, dir->tdir_tag, fp);
			_TIFFfree((char*) fp);
		}
	}
	if (cp)
		_TIFFfree(cp);
	return (ok);
}

/*
 * Replace a single strip (tile) of uncompressed data by
 * multiple strips (tiles), each approximately 8Kbytes.
 * This is useful for dealing with large images or
 * for dealing with machines with a limited amount
 * memory.
 */
static void
ChopUpSingleUncompressedStrip(TIFF* tif)
{
	register TIFFDirectory *td = &tif->tif_dir;
	uint32 bytecount = td->td_stripbytecount[0];
	uint32 offset = td->td_stripoffset[0];
	tsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes;
	tstrip_t strip, nstrips, rowsperstrip;
	uint32* newcounts;
	uint32* newoffsets;

	/*
	 * Make the rows hold at least one scanline, but fill specified amount
	 * of data if possible.
	 */
#ifndef STRIP_SIZE_DEFAULT
# define STRIP_SIZE_DEFAULT 8192
#endif
	if (rowbytes > STRIP_SIZE_DEFAULT) {
		stripbytes = rowbytes;
		rowsperstrip = 1;
	} else if (rowbytes > 0 ) {
		rowsperstrip = STRIP_SIZE_DEFAULT / rowbytes;
		stripbytes = rowbytes * rowsperstrip;
	}
        else
            return;
#undef STRIP_SIZE_DEFAULT

	/* 
	 * never increase the number of strips in an image
	 */
	if (rowsperstrip >= td->td_rowsperstrip)
		return;
	nstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);
        if( nstrips == 0 ) /* something is wonky, do nothing. */
            return;

	newcounts = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),
				"for chopped \"StripByteCounts\" array");
	newoffsets = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),
				"for chopped \"StripOffsets\" array");
	if (newcounts == NULL || newoffsets == NULL) {
	        /*
		 * Unable to allocate new strip information, give
		 * up and use the original one strip information.
		 */
		if (newcounts != NULL)
			_TIFFfree(newcounts);
		if (newoffsets != NULL)
			_TIFFfree(newoffsets);
		return;
	}
	/*
	 * Fill the strip information arrays with new bytecounts and offsets
	 * that reflect the broken-up format.
	 */
	for (strip = 0; strip < nstrips; strip++) {
		if (stripbytes > (tsize_t) bytecount)
			stripbytes = bytecount;
		newcounts[strip] = stripbytes;
		newoffsets[strip] = offset;
		offset += stripbytes;
		bytecount -= stripbytes;
	}
	/*
	 * Replace old single strip info with multi-strip info.
	 */
	td->td_stripsperimage = td->td_nstrips = nstrips;
	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);

	_TIFFfree(td->td_stripbytecount);
	_TIFFfree(td->td_stripoffset);
	td->td_stripbytecount = newcounts;
	td->td_stripoffset = newoffsets;
	td->td_stripbytecountsorted = 1;
}

/* vim: set ts=8 sts=8 sw=8 noet: */
