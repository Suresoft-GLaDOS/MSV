int __get_mutant();
int __is_neg(const char *, int, const int *, int, const char *, int,
             const void **, int, const double *, int, ...);
int __abst_hole();
int __choose(char *);
void *memset(void *, int, unsigned long);
/*
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
   | Copyright (c) 1997-2011 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   | Authors: Christian Stocker <chregu@php.net>                          |
   |          Rob Richards <rrichards@php.net>                            |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#if HAVE_LIBXML && HAVE_DOM
#include "php_dom.h"
#include <libxml/SAX.h>
#ifdef LIBXML_SCHEMAS_ENABLED
#include <libxml/relaxng.h>
#include <libxml/xmlschemas.h>
#endif

typedef struct _idsIterator idsIterator;
struct _idsIterator {
  xmlChar *elementId;
  xmlNode *element;
};

#define DOM_LOAD_STRING 0
#define DOM_LOAD_FILE 1

/* {{{ arginfo */
ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_element, 0, 0, 1)
ZEND_ARG_INFO(0, tagName)
ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_document_fragment, 0, 0, 0)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_text_node, 0, 0, 1)
ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_comment, 0, 0, 1)
ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_cdatasection, 0, 0, 1)
ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_processing_instruction, 0, 0,
                       2)
ZEND_ARG_INFO(0, target)
ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_attribute, 0, 0, 1)
ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_entity_reference, 0, 0, 1)
ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_get_elements_by_tag_name, 0, 0, 1)
ZEND_ARG_INFO(0, tagName)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_import_node, 0, 0, 2)
ZEND_ARG_OBJ_INFO(0, importedNode, DOMNode, 0)
ZEND_ARG_INFO(0, deep)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_element_ns, 0, 0, 2)
ZEND_ARG_INFO(0, namespaceURI)
ZEND_ARG_INFO(0, qualifiedName)
ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_create_attribute_ns, 0, 0, 2)
ZEND_ARG_INFO(0, namespaceURI)
ZEND_ARG_INFO(0, qualifiedName)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_get_elements_by_tag_name_ns, 0, 0,
                       2)
ZEND_ARG_INFO(0, namespaceURI)
ZEND_ARG_INFO(0, localName)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_get_element_by_id, 0, 0, 1)
ZEND_ARG_INFO(0, elementId)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_adopt_node, 0, 0, 1)
ZEND_ARG_OBJ_INFO(0, source, DOMNode, 0)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_normalize_document, 0, 0, 0)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_rename_node, 0, 0, 3)
ZEND_ARG_OBJ_INFO(0, node, DOMNode, 0)
ZEND_ARG_INFO(0, namespaceURI)
ZEND_ARG_INFO(0, qualifiedName)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_load, 0, 0, 1)
ZEND_ARG_INFO(0, source)
ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_save, 0, 0, 1)
ZEND_ARG_INFO(0, file)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_loadxml, 0, 0, 1)
ZEND_ARG_INFO(0, source)
ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_savexml, 0, 0, 0)
ZEND_ARG_OBJ_INFO(0, node, DOMNode, 1)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_construct, 0, 0, 0)
ZEND_ARG_INFO(0, version)
ZEND_ARG_INFO(0, encoding)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_validate, 0, 0, 0)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_xinclude, 0, 0, 0)
ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_loadhtml, 0, 0, 1)
ZEND_ARG_INFO(0, source)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_loadhtmlfile, 0, 0, 1)
ZEND_ARG_INFO(0, source)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_savehtml, 0, 0, 0)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_savehtmlfile, 0, 0, 1)
ZEND_ARG_INFO(0, file)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_schema_validate_file, 0, 0, 1)
ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_schema_validate_xml, 0, 0, 1)
ZEND_ARG_INFO(0, source)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_relaxNG_validate_file, 0, 0, 1)
ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_relaxNG_validate_xml, 0, 0, 1)
ZEND_ARG_INFO(0, source)
ZEND_END_ARG_INFO();

ZEND_BEGIN_ARG_INFO_EX(arginfo_dom_document_registernodeclass, 0, 0, 2)
ZEND_ARG_INFO(0, baseClass)
ZEND_ARG_INFO(0, extendedClass)
ZEND_END_ARG_INFO();
/* }}} */

/*
 * class DOMDocument extends DOMNode
 *
 * URL:
 * http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-i-Document
 * Since:
 */

const zend_function_entry php_dom_document_class_functions[] =
    {/* {{{ */
     PHP_FALIAS(createElement, dom_document_create_element, arginfo_dom_document_create_element) PHP_FALIAS(
         createDocumentFragment, dom_document_create_document_fragment,
         arginfo_dom_document_create_document_fragment) PHP_FALIAS(createTextNode,
                                                                   dom_document_create_text_node,
                                                                   arginfo_dom_document_create_text_node)
         PHP_FALIAS(createComment, dom_document_create_comment, arginfo_dom_document_create_comment) PHP_FALIAS(
             createCDATASection, dom_document_create_cdatasection,
             arginfo_dom_document_create_cdatasection) PHP_FALIAS(createProcessingInstruction,
                                                                  dom_document_create_processing_instruction,
                                                                  arginfo_dom_document_create_processing_instruction)
             PHP_FALIAS(createAttribute, dom_document_create_attribute, arginfo_dom_document_create_attribute) PHP_FALIAS(
                 createEntityReference, dom_document_create_entity_reference,
                 arginfo_dom_document_create_entity_reference) PHP_FALIAS(getElementsByTagName,
                                                                          dom_document_get_elements_by_tag_name,
                                                                          arginfo_dom_document_get_elements_by_tag_name)
                 PHP_FALIAS(importNode, dom_document_import_node, arginfo_dom_document_import_node) PHP_FALIAS(
                     createElementNS,
                     dom_document_create_element_ns,
                     arginfo_dom_document_create_element_ns)
                     PHP_FALIAS(createAttributeNS, dom_document_create_attribute_ns, arginfo_dom_document_create_attribute_ns) PHP_FALIAS(
                         getElementsByTagNameNS,
                         dom_document_get_elements_by_tag_name_ns,
                         arginfo_dom_document_get_elements_by_tag_name_ns)
                         PHP_FALIAS(getElementById,
                                    dom_document_get_element_by_id,
                                    arginfo_dom_document_get_element_by_id)
                             PHP_FALIAS(adoptNode, dom_document_adopt_node, arginfo_dom_document_adopt_node) PHP_FALIAS(
                                 normalizeDocument,
                                 dom_document_normalize_document,
                                 arginfo_dom_document_normalize_document)
                                 PHP_FALIAS(renameNode, dom_document_rename_node, arginfo_dom_document_rename_node) PHP_ME(
                                     domdocument,
                                     load, arginfo_dom_document_load,
                                     ZEND_ACC_PUBLIC | ZEND_ACC_ALLOW_STATIC)
                                     PHP_FALIAS(save, dom_document_save, arginfo_dom_document_save) PHP_ME(
                                         domdocument, loadXML,
                                         arginfo_dom_document_loadxml,
                                         ZEND_ACC_PUBLIC |
                                             ZEND_ACC_ALLOW_STATIC)
                                         PHP_FALIAS(saveXML, dom_document_savexml, arginfo_dom_document_savexml) PHP_ME(
                                             domdocument, __construct,
                                             arginfo_dom_document_construct,
                                             ZEND_ACC_PUBLIC) PHP_FALIAS(validate, dom_document_validate, arginfo_dom_document_validate)
                                             PHP_FALIAS(
                                                 xinclude,
                                                 dom_document_xinclude,
                                                 arginfo_dom_document_xinclude)
#if defined(LIBXML_HTML_ENABLED)
                                                 PHP_ME(
                                                     domdocument, loadHTML,
                                                     arginfo_dom_document_loadhtml,
                                                     ZEND_ACC_PUBLIC |
                                                         ZEND_ACC_ALLOW_STATIC)
                                                     PHP_ME(
                                                         domdocument,
                                                         loadHTMLFile,
                                                         arginfo_dom_document_loadhtmlfile,
                                                         ZEND_ACC_PUBLIC |
                                                             ZEND_ACC_ALLOW_STATIC)
                                                         PHP_FALIAS(
                                                             saveHTML,
                                                             dom_document_save_html,
                                                             arginfo_dom_document_savehtml)
                                                             PHP_FALIAS(
                                                                 saveHTMLFile,
                                                                 dom_document_save_html_file,
                                                                 arginfo_dom_document_savehtmlfile)
#endif /* defined(LIBXML_HTML_ENABLED) */
#if defined(LIBXML_SCHEMAS_ENABLED)
                                                                 PHP_FALIAS(
                                                                     schemaValidate,
                                                                     dom_document_schema_validate_file,
                                                                     arginfo_dom_document_schema_validate_file)
                                                                     PHP_FALIAS(
                                                                         schemaValidateSource,
                                                                         dom_document_schema_validate_xml,
                                                                         arginfo_dom_document_schema_validate_xml)
                                                                         PHP_FALIAS(
                                                                             relaxNGValidate,
                                                                             dom_document_relaxNG_validate_file,
                                                                             arginfo_dom_document_relaxNG_validate_file)
                                                                             PHP_FALIAS(
                                                                                 relaxNGValidateSource,
                                                                                 dom_document_relaxNG_validate_xml,
                                                                                 arginfo_dom_document_relaxNG_validate_xml)
#endif
                                                                                 PHP_ME(
                                                                                     domdocument,
                                                                                     registerNodeClass,
                                                                                     arginfo_dom_document_registernodeclass,
                                                                                     ZEND_ACC_PUBLIC){
                                                                                     NULL,
                                                                                     NULL,
                                                                                     NULL}};
/* }}} */

/* {{{ docType	DOMDocumentType
readonly=yes
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-B63ED1A31
Since:
*/
int dom_document_doctype_read(dom_object *obj, zval **retval TSRMLS_DC) {
  xmlDoc *docp;
  xmlDtdPtr dtdptr;
  int ret;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  ALLOC_ZVAL(*retval);

  dtdptr = xmlGetIntSubset(docp);
  if (!dtdptr) {
    ZVAL_NULL(*retval);
    return SUCCESS;
  }

  if (NULL == (*retval = php_dom_create_object((xmlNodePtr)dtdptr, &ret, NULL,
                                               *retval, obj TSRMLS_CC))) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Cannot create required DOM object");
    return FAILURE;
  }
  return SUCCESS;
}

/* }}} */

/* {{{ implementation	DOMImplementation
readonly=yes
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-1B793EBA
Since:
*/
int dom_document_implementation_read(dom_object *obj, zval **retval TSRMLS_DC) {
  ALLOC_ZVAL(*retval);
  php_dom_create_implementation(retval TSRMLS_CC);
  return SUCCESS;
}

/* }}} */

/* {{{ documentElement	DOMElement
readonly=yes
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-87CD092
Since:
*/
int dom_document_document_element_read(dom_object *obj,
                                       zval **retval TSRMLS_DC) {
  xmlDoc *docp;
  xmlNode *root;
  int ret;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  ALLOC_ZVAL(*retval);

  root = xmlDocGetRootElement(docp);
  if (!root) {
    ZVAL_NULL(*retval);
    return SUCCESS;
  }

  if (NULL == (*retval = php_dom_create_object(root, &ret, NULL, *retval,
                                               obj TSRMLS_CC))) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Cannot create required DOM object");
    return FAILURE;
  }
  return SUCCESS;
}

/* }}} */

/* {{{ encoding	string
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-encoding
Since: DOM Level 3
*/
int dom_document_encoding_read(dom_object *obj, zval **retval TSRMLS_DC) {
  xmlDoc *docp;
  char *encoding;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  encoding = (char *)docp->encoding;
  ALLOC_ZVAL(*retval);

  if (encoding != NULL) {
    ZVAL_STRING(*retval, encoding, 1);
  } else {
    ZVAL_NULL(*retval);
  }

  return SUCCESS;
}

int dom_document_encoding_write(dom_object *obj, zval *newval TSRMLS_DC) {
  zval value_copy;
  xmlDoc *docp;
  xmlCharEncodingHandlerPtr handler;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  if (newval->type != IS_STRING) {
    if (Z_REFCOUNT_P(newval) > 1) {
      value_copy = *newval;
      zval_copy_ctor(&value_copy);
      newval = &value_copy;
    }
    convert_to_string(newval);
  }

  handler = xmlFindCharEncodingHandler(Z_STRVAL_P(newval));

  if (handler != NULL) {
    xmlCharEncCloseFunc(handler);
    if (docp->encoding != NULL) {
      xmlFree((xmlChar *)docp->encoding);
    }
    docp->encoding = xmlStrdup((const xmlChar *)Z_STRVAL_P(newval));
  } else {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Document Encoding");
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}

/* }}} */

/* {{{ standalone	boolean
readonly=no
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-standalone
Since: DOM Level 3
*/
int dom_document_standalone_read(dom_object *obj, zval **retval TSRMLS_DC) {
  xmlDoc *docp;
  int standalone;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  ALLOC_ZVAL(*retval);
  standalone = docp->standalone;
  ZVAL_BOOL(*retval, standalone);

  return SUCCESS;
}

int dom_document_standalone_write(dom_object *obj, zval *newval TSRMLS_DC) {
  zval value_copy;
  xmlDoc *docp;
  int standalone;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_long(newval);

  standalone = Z_LVAL_P(newval);
  if (standalone > 0) {
    docp->standalone = 1;
  } else if (standalone < 0) {
    docp->standalone = -1;
  } else {
    docp->standalone = 0;
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}

/* }}} */

/* {{{ version	string
readonly=no
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-version
Since: DOM Level 3
*/
int dom_document_version_read(dom_object *obj, zval **retval TSRMLS_DC) {
  xmlDoc *docp;
  char *version;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  version = (char *)docp->version;
  ALLOC_ZVAL(*retval);

  if (version != NULL) {
    ZVAL_STRING(*retval, version, 1);
  } else {
    ZVAL_NULL(*retval);
  }

  return SUCCESS;
}

int dom_document_version_write(dom_object *obj, zval *newval TSRMLS_DC) {
  zval value_copy;
  xmlDoc *docp;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  if (docp->version != NULL) {
    xmlFree((xmlChar *)docp->version);
  }

  if (newval->type != IS_STRING) {
    if (Z_REFCOUNT_P(newval) > 1) {
      value_copy = *newval;
      zval_copy_ctor(&value_copy);
      newval = &value_copy;
    }
    convert_to_string(newval);
  }

  docp->version = xmlStrdup((const xmlChar *)Z_STRVAL_P(newval));

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}

/* }}} */

/* {{{ strictErrorChecking	boolean
readonly=no
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-strictErrorChecking
Since: DOM Level 3
*/
int dom_document_strict_error_checking_read(dom_object *obj,
                                            zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->stricterror);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_strict_error_checking_write(dom_object *obj,
                                             zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->stricterror = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}

/* }}} */

/* {{{ formatOutput	boolean
readonly=no
*/
int dom_document_format_output_read(dom_object *obj, zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->formatoutput);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_format_output_write(dom_object *obj, zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->formatoutput = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}
/* }}} */

/* {{{ validateOnParse	boolean
readonly=no
*/
int dom_document_validate_on_parse_read(dom_object *obj,
                                        zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->validateonparse);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_validate_on_parse_write(dom_object *obj,
                                         zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->validateonparse = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}
/* }}} */

/* {{{ resolveExternals	boolean
readonly=no
*/
int dom_document_resolve_externals_read(dom_object *obj,
                                        zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->resolveexternals);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_resolve_externals_write(dom_object *obj,
                                         zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->resolveexternals = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}
/* }}} */

/* {{{ preserveWhiteSpace	boolean
readonly=no
*/
int dom_document_preserve_whitespace_read(dom_object *obj,
                                          zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->preservewhitespace);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_preserve_whitespace_write(dom_object *obj,
                                           zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->preservewhitespace = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}
/* }}} */

/* {{{ recover	boolean
readonly=no
*/
int dom_document_recover_read(dom_object *obj, zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->recover);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_recover_write(dom_object *obj, zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->recover = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}
/* }}} */

/* {{{ substituteEntities	boolean
readonly=no
*/
int dom_document_substitue_entities_read(dom_object *obj,
                                         zval **retval TSRMLS_DC) {
  dom_doc_propsptr doc_prop;

  ALLOC_ZVAL(*retval);
  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    ZVAL_BOOL(*retval, doc_prop->substituteentities);
  } else {
    ZVAL_FALSE(*retval);
  }
  return SUCCESS;
}

int dom_document_substitue_entities_write(dom_object *obj,
                                          zval *newval TSRMLS_DC) {
  zval value_copy;
  dom_doc_propsptr doc_prop;

  if (Z_REFCOUNT_P(newval) > 1) {
    value_copy = *newval;
    zval_copy_ctor(&value_copy);
    newval = &value_copy;
  }
  convert_to_boolean(newval);

  if (obj->document) {
    doc_prop = dom_get_doc_props(obj->document);
    doc_prop->substituteentities = Z_LVAL_P(newval);
  }

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}
/* }}} */

/* {{{ documentURI	string
readonly=no
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-documentURI
Since: DOM Level 3
*/
int dom_document_document_uri_read(dom_object *obj, zval **retval TSRMLS_DC) {
  xmlDoc *docp;
  char *url;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  ALLOC_ZVAL(*retval);
  url = (char *)docp->URL;
  if (url != NULL) {
    ZVAL_STRING(*retval, url, 1);
  } else {
    ZVAL_NULL(*retval);
  }

  return SUCCESS;
}

int dom_document_document_uri_write(dom_object *obj, zval *newval TSRMLS_DC) {
  zval value_copy;
  xmlDoc *docp;

  docp = (xmlDocPtr)dom_object_get_node(obj);

  if (docp == NULL) {
    php_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);
    return FAILURE;
  }

  if (docp->URL != NULL) {
    xmlFree((xmlChar *)docp->URL);
  }

  if (newval->type != IS_STRING) {
    if (Z_REFCOUNT_P(newval) > 1) {
      value_copy = *newval;
      zval_copy_ctor(&value_copy);
      newval = &value_copy;
    }
    convert_to_string(newval);
  }

  docp->URL = xmlStrdup((const xmlChar *)Z_STRVAL_P(newval));

  if (newval == &value_copy) {
    zval_dtor(newval);
  }

  return SUCCESS;
}

/* }}} */

/* {{{ config	DOMConfiguration
readonly=yes
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-config
Since: DOM Level 3
*/
int dom_document_config_read(dom_object *obj, zval **retval TSRMLS_DC) {
  ALLOC_ZVAL(*retval);
  ZVAL_NULL(*retval);
  return SUCCESS;
}

/* }}} */

/* {{{ proto DOMElement dom_document_create_element(string tagName [, string
value]); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-2141741547
Since:
*/
PHP_FUNCTION(dom_document_create_element) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp;
  dom_object *intern;
  int ret, name_len, value_len;
  char *name, *value = NULL;

  // prophet generated patch
  switch (__choose("__ID0")) {
  case 0: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#ifdef COMPILE_0
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_2
  case 3: {
    (name)++;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3
  case 4: {
    (node) = xmlNewDocNode(docp, ((void *)0), name, value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_4
  case 5: {
    (value)++;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_5
  case 6: {
    _convert_to_string(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_6
  case 7: {
    _convert_to_string(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_7
  case 8: {
    _convert_to_string(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_8
  case 9: {
    _convert_to_string(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_9
  case 10: {
    _efree(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_10
  case 11: {
    _efree(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_11
  case 12: {
    _efree(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_12
  case 13: {
    _efree(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_13
  case 14: {
    _zval_copy_ctor_func((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_14
  case 15: {
    _zval_copy_ctor_func((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_15
  case 16: {
    _zval_copy_ctor_func((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_16
  case 17: {
    _zval_copy_ctor_func((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_17
  case 18: {
    _zval_dtor(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_18
  case 19: {
    _zval_dtor(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_19
  case 20: {
    _zval_dtor(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_20
  case 21: {
    _zval_dtor(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_21
  case 22: {
    _zval_dtor_func((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_22
  case 23: {
    _zval_dtor_func((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_23
  case 24: {
    _zval_dtor_func((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_24
  case 25: {
    _zval_dtor_func((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_25
  case 26: {
    _zval_ptr_dtor((&(id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_26
  case 27: {
    _zval_ptr_dtor((&(return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_27
  case 28: {
    _zval_ptr_dtor((&(rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_28
  case 29: {
    _zval_ptr_dtor((&(this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_29
  case 30: {
    convert_to_boolean((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_30
  case 31: {
    convert_to_boolean((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_31
  case 32: {
    convert_to_boolean((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_32
  case 33: {
    convert_to_boolean((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_33
  case 34: {
    convert_to_long((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_34
  case 35: {
    convert_to_long((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_35
  case 36: {
    convert_to_long((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_36
  case 37: {
    convert_to_long((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_37
  case 38: {
    exit(1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_38
  case 39: {
    gc_remove_zval_from_buffer((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_39
  case 40: {
    gc_remove_zval_from_buffer((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_40
  case 41: {
    gc_remove_zval_from_buffer((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_41
  case 42: {
    gc_remove_zval_from_buffer((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_42
  case 43: {
    gc_zval_check_possible_root(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_43
  case 44: {
    gc_zval_check_possible_root(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_44
  case 45: {
    gc_zval_check_possible_root(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_45
  case 46: {
    gc_zval_check_possible_root(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_46
  case 47: {
    gc_zval_possible_root((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_47
  case 48: {
    gc_zval_possible_root((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_48
  case 49: {
    gc_zval_possible_root((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_49
  case 50: {
    gc_zval_possible_root((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_50
  case 51: {
    i_zval_ptr_dtor((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_51
  case 52: {
    i_zval_ptr_dtor((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_52
  case 53: {
    i_zval_ptr_dtor((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_53
  case 54: {
    i_zval_ptr_dtor((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_54
  case 55: {
    if (!__is_neg("0-55", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                  (void **){this_ptr, id, name, value, dom_document_class_entry,
                            return_value, docp, intern, node, rv},
                  0, 0, 14, "ht", "this_ptr", "id", "name_len", "value_len",
                  "name", "value", "dom_document_class_entry", "return_value",
                  "docp", "intern", "node", "rv", "ret") &&
        (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                      dom_document_class_entry, &name,
                                      &name_len, &value, &value_len) == -1)) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_55
  case 56: {
    if (!__is_neg("0-56", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                  (void **){this_ptr, id, name, value, dom_document_class_entry,
                            return_value, docp, intern, node, rv},
                  0, 0, 14, "ht", "this_ptr", "id", "name_len", "value_len",
                  "name", "value", "dom_document_class_entry", "return_value",
                  "docp", "intern", "node", "rv", "ret"))
      if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                       dom_document_class_entry, &name,
                                       &name_len, &value, &value_len) == -1) {
        return;
      }

    break;
  }
#endif
#ifdef COMPILE_56
  case 57: {
    if ((zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                      dom_document_class_entry, &name,
                                      &name_len, &value, &value_len) == -1) &&
        !__is_neg("0-57", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                  (void **){this_ptr, id, name, value, dom_document_class_entry,
                            return_value, docp, intern, node, rv},
                  0, 0, 14, "ht", "this_ptr", "id", "name_len", "value_len",
                  "name", "value", "dom_document_class_entry", "return_value",
                  "docp", "intern", "node", "rv", "ret")) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_57
  case 58: {
    if ((zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                      dom_document_class_entry, &name,
                                      &name_len, &value, &value_len) == -1) ||
        __is_neg("0-58", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                 (void **){this_ptr, id, name, value, dom_document_class_entry,
                           return_value, docp, intern, node, rv},
                 0, 0, 14, "ht", "this_ptr", "id", "name_len", "value_len",
                 "name", "value", "dom_document_class_entry", "return_value",
                 "docp", "intern", "node", "rv", "ret")) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_58
  case 59: {
    if (__is_neg("0-59", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                 (void **){this_ptr, id, name, value, dom_document_class_entry,
                           return_value, docp, intern, node, rv},
                 0, 0, 14, "ht", "this_ptr", "id", "name_len", "value_len",
                 "name", "value", "dom_document_class_entry", "return_value",
                 "docp", "intern", "node", "rv", "ret"))
      return;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_59
  case 60: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_60
  case 61: {
    node = xmlNewDocNode((docp), ((void *)0), name, value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_61
  case 62: {
    node = xmlNewDocNode(docp, ((void *)0), (name), value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_62
  case 63: {
    node = xmlNewDocNode(docp, ((void *)0), (value), value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_63
  case 64: {
    node = xmlNewDocNode(docp, ((void *)0), name, (name));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_64
  case 65: {
    node = xmlNewDocNode(docp, ((void *)0), name, (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_65
  case 66: {
    node = xmlNewDocNode(docp, ((void *)0), name, value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_66
  case 67: {
    php_dom_create_implementation((return_value_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_67
  case 68: {
    php_dom_create_interator((id), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_68
  case 69: {
    php_dom_create_interator((return_value), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_69
  case 70: {
    php_dom_create_interator((rv), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_70
  case 71: {
    php_dom_create_interator((this_ptr), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_71
  case 72: {
    php_dom_remove_xinclude_nodes((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_72
  case 73: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_73
  case 74: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_74
  case 75: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_75
  case 76: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_76
  case 77: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_77
  case 78: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_78
  case 79: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_79
  case 80: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_80
  case 81: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_81
  case 82: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_82
  case 83: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_83
  case 84: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_84
  case 85: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_85
  case 86: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_86
  case 87: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_87
  case 88: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_88
  case 89: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_89
  case 90: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_90
  case 91: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_91
  case 92: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_92
  case 93: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_93
  case 94: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_94
  case 95: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_95
  case 96: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_96
  case 97: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_97
  case 98: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_98
  case 99: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_99
  case 100: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_100
  case 101: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_101
  case 102: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_102
  case 103: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_103
  case 104: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_104
  case 105: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_105
  case 106: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_106
  case 107: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_107
  case 108: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_108
  case 109: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_109
  case 110: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_110
  case 111: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_111
  case 112: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_112
  case 113: {
    php_dom_throw_error((PHP_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_113
  case 114: {
    php_dom_throw_error((PHP_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_114
  case 115: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_115
  case 116: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_116
  case 117: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_117
  case 118: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_118
  case 119: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_119
  case 120: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_120
  case 121: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_121
  case 122: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_122
  case 123: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_123
  case 124: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_124
  case 125: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_125
  case 126: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_126
  case 127: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_127
  case 128: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_128
  case 129: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_129
  case 130: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (name));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_130
  case 131: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_131
  case 132: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (name));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_132
  case 133: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_133
  case 134: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (name));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_134
  case 135: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_135
  case 136: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_136
  case 137: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_137
  case 138: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_138
  case 139: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_139
  case 140: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_140
  case 141: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_141
  case 142: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_142
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_143
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_144
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_145
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_146
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_147
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_148
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_149
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_150
  case 151: {
    php_libxml_node_free_resource((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_151
  case 152: {
    xmlFreeNode((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_152
  case 153: {
    xmlInitParser();
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_153
  case 154: {
    xmlUnlinkNode((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_154
  case 155: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_155
  case 156: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_156
  case 157: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_157
  case 158: {
    zval_unset_isref_p((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_158
  case 159: {
    zval_unset_isref_p((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_159
  case 160: {
    zval_unset_isref_p((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_160
  case 161: {
    zval_unset_isref_p((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }

    break;
  }
#endif
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  // prophet generated patch
  switch (__choose("__ID1")) {
  case 0: {
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#ifdef COMPILE_161
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_162
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_163
  case 3: {
    (name)++;
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_164
  case 4: {
    (node) = xmlNewDocNode(docp, ((void *)0), name, value);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_165
  case 5: {
    (value)++;
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_166
  case 6: {
    _convert_to_string(((id)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_167
  case 7: {
    _convert_to_string(((return_value)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_168
  case 8: {
    _convert_to_string(((rv)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_169
  case 9: {
    _convert_to_string(((this_ptr)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_170
  case 10: {
    _efree(((id)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_171
  case 11: {
    _efree(((return_value)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_172
  case 12: {
    _efree(((rv)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_173
  case 13: {
    _efree(((this_ptr)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_174
  case 14: {
    _zval_copy_ctor_func((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_175
  case 15: {
    _zval_copy_ctor_func((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_176
  case 16: {
    _zval_copy_ctor_func((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_177
  case 17: {
    _zval_copy_ctor_func((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_178
  case 18: {
    _zval_dtor(((id)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_179
  case 19: {
    _zval_dtor(((return_value)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_180
  case 20: {
    _zval_dtor(((rv)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_181
  case 21: {
    _zval_dtor(((this_ptr)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_182
  case 22: {
    _zval_dtor_func((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_183
  case 23: {
    _zval_dtor_func((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_184
  case 24: {
    _zval_dtor_func((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_185
  case 25: {
    _zval_dtor_func((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_186
  case 26: {
    _zval_ptr_dtor((&(id)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_187
  case 27: {
    _zval_ptr_dtor((&(return_value)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_188
  case 28: {
    _zval_ptr_dtor((&(rv)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_189
  case 29: {
    _zval_ptr_dtor((&(this_ptr)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_190
  case 30: {
    convert_to_boolean((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_191
  case 31: {
    convert_to_boolean((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_192
  case 32: {
    convert_to_boolean((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_193
  case 33: {
    convert_to_boolean((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_194
  case 34: {
    convert_to_long((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_195
  case 35: {
    convert_to_long((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_196
  case 36: {
    convert_to_long((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_197
  case 37: {
    convert_to_long((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_198
  case 38: {
    exit(1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_199
  case 39: {
    gc_remove_zval_from_buffer((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_200
  case 40: {
    gc_remove_zval_from_buffer((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_201
  case 41: {
    gc_remove_zval_from_buffer((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_202
  case 42: {
    gc_remove_zval_from_buffer((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_203
  case 43: {
    gc_zval_check_possible_root(((id)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_204
  case 44: {
    gc_zval_check_possible_root(((return_value)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_205
  case 45: {
    gc_zval_check_possible_root(((rv)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_206
  case 46: {
    gc_zval_check_possible_root(((this_ptr)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_207
  case 47: {
    gc_zval_possible_root((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_208
  case 48: {
    gc_zval_possible_root((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_209
  case 49: {
    gc_zval_possible_root((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_210
  case 50: {
    gc_zval_possible_root((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_211
  case 51: {
    i_zval_ptr_dtor((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_212
  case 52: {
    i_zval_ptr_dtor((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_213
  case 53: {
    i_zval_ptr_dtor((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_214
  case 54: {
    i_zval_ptr_dtor((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_215
  case 55: {
    if (!__is_neg("1-55", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                  (void **){name, intern, return_value, id, docp, node, value,
                            this_ptr, dom_document_class_entry, rv},
                  0, 0, 14, "name", "intern", "return_value", "id", "docp",
                  "node", "value", "ht", "this_ptr", "name_len", "value_len",
                  "dom_document_class_entry", "rv", "ret") &&
        (xmlValidateName((xmlChar *)name, 0) != 0)) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_216
  case 56: {
    if (!__is_neg("1-56", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                  (void **){name, intern, return_value, id, docp, node, value,
                            this_ptr, dom_document_class_entry, rv},
                  0, 0, 14, "name", "intern", "return_value", "id", "docp",
                  "node", "value", "ht", "this_ptr", "name_len", "value_len",
                  "dom_document_class_entry", "rv", "ret"))
      if (xmlValidateName((xmlChar *)name, 0) != 0) {
        php_dom_throw_error(INVALID_CHARACTER_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

    break;
  }
#endif
#ifdef COMPILE_217
  case 57: {
    if ((xmlValidateName((xmlChar *)name, 0) != 0) &&
        !__is_neg("1-57", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                  (void **){name, intern, return_value, id, docp, node, value,
                            this_ptr, dom_document_class_entry, rv},
                  0, 0, 14, "name", "intern", "return_value", "id", "docp",
                  "node", "value", "ht", "this_ptr", "name_len", "value_len",
                  "dom_document_class_entry", "rv", "ret")) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_218
  case 58: {
    if ((xmlValidateName((xmlChar *)name, 0) != 0) ||
        __is_neg("1-58", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                 (void **){name, intern, return_value, id, docp, node, value,
                           this_ptr, dom_document_class_entry, rv},
                 0, 0, 14, "name", "intern", "return_value", "id", "docp",
                 "node", "value", "ht", "this_ptr", "name_len", "value_len",
                 "dom_document_class_entry", "rv", "ret")) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_219
  case 59: {
    if (__is_neg("1-59", 4, (int *){ht, name_len, value_len, ret}, 0, 0, 10,
                 (void **){name, intern, return_value, id, docp, node, value,
                           this_ptr, dom_document_class_entry, rv},
                 0, 0, 14, "name", "intern", "return_value", "id", "docp",
                 "node", "value", "ht", "this_ptr", "name_len", "value_len",
                 "dom_document_class_entry", "rv", "ret"))
      return;
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_220
  case 60: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_221
  case 61: {
    memset(intern, 0, sizeof(*(intern)));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_222
  case 62: {
    node = xmlNewDocNode((docp), ((void *)0), name, value);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_223
  case 63: {
    node = xmlNewDocNode(docp, ((void *)0), (name), value);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_224
  case 64: {
    node = xmlNewDocNode(docp, ((void *)0), (value), value);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_225
  case 65: {
    node = xmlNewDocNode(docp, ((void *)0), name, (name));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_226
  case 66: {
    node = xmlNewDocNode(docp, ((void *)0), name, (value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_227
  case 67: {
    node = xmlNewDocNode(docp, ((void *)0), name, value);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_228
  case 68: {
    php_dom_create_implementation((return_value_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_229
  case 69: {
    php_dom_create_interator((id), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_230
  case 70: {
    php_dom_create_interator((return_value), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_231
  case 71: {
    php_dom_create_interator((rv), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_232
  case 72: {
    php_dom_create_interator((this_ptr), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_233
  case 73: {
    php_dom_remove_xinclude_nodes((node));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_234
  case 74: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_235
  case 75: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_236
  case 76: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_237
  case 77: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_238
  case 78: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_239
  case 79: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_240
  case 80: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_241
  case 81: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_242
  case 82: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_243
  case 83: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_244
  case 84: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_245
  case 85: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_246
  case 86: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_247
  case 87: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_248
  case 88: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_249
  case 89: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_250
  case 90: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_251
  case 91: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_252
  case 92: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_253
  case 93: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_254
  case 94: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_255
  case 95: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_256
  case 96: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_257
  case 97: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_258
  case 98: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_259
  case 99: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_260
  case 100: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_261
  case 101: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_262
  case 102: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_263
  case 103: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_264
  case 104: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_265
  case 105: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_266
  case 106: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_267
  case 107: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_268
  case 108: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_269
  case 109: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_270
  case 110: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_271
  case 111: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_272
  case 112: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_273
  case 113: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_274
  case 114: {
    php_dom_throw_error((PHP_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_275
  case 115: {
    php_dom_throw_error((PHP_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_276
  case 116: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_277
  case 117: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_278
  case 118: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_279
  case 119: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_280
  case 120: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_281
  case 121: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_282
  case 122: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_283
  case 123: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_284
  case 124: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_285
  case 125: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_286
  case 126: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_287
  case 127: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_288
  case 128: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_289
  case 129: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_290
  case 130: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_291
  case 131: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (name));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_292
  case 132: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_293
  case 133: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (name));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_294
  case 134: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_295
  case 135: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (name));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_296
  case 136: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_297
  case 137: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_298
  case 138: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_299
  case 139: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_300
  case 140: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_301
  case 141: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_302
  case 142: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_303
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_304
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_305
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_306
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_307
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_308
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_309
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_310
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_311
  case 151: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_312
  case 152: {
    php_libxml_node_free_resource((node));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_313
  case 153: {
    xmlFreeNode((node));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_314
  case 154: {
    xmlInitParser();
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_315
  case 155: {
    xmlUnlinkNode((node));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_316
  case 156: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_317
  case 157: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_318
  case 158: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_319
  case 159: {
    zval_unset_isref_p((id));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_320
  case 160: {
    zval_unset_isref_p((return_value));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_321
  case 161: {
    zval_unset_isref_p((rv));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_322
  case 162: {
    zval_unset_isref_p((this_ptr));
    if (xmlValidateName((xmlChar *)name, 0) != 0) {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID2")) {
  case 0: {
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#ifdef COMPILE_323
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_324
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_325
  case 3: {
    (name)++;
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_326
  case 4: {
    (node) = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_327
  case 5: {
    (node) = xmlNewDocNode(docp, ((void *)0), name, value);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_328
  case 6: {
    (value)++;
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_329
  case 7: {
    _convert_to_string(((id)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_330
  case 8: {
    _convert_to_string(((return_value)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_331
  case 9: {
    _convert_to_string(((rv)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_332
  case 10: {
    _convert_to_string(((this_ptr)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_333
  case 11: {
    _efree(((id)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_334
  case 12: {
    _efree(((return_value)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_335
  case 13: {
    _efree(((rv)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_336
  case 14: {
    _efree(((this_ptr)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_337
  case 15: {
    _zval_copy_ctor_func((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_338
  case 16: {
    _zval_copy_ctor_func((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_339
  case 17: {
    _zval_copy_ctor_func((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_340
  case 18: {
    _zval_copy_ctor_func((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_341
  case 19: {
    _zval_dtor(((id)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_342
  case 20: {
    _zval_dtor(((return_value)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_343
  case 21: {
    _zval_dtor(((rv)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_344
  case 22: {
    _zval_dtor(((this_ptr)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_345
  case 23: {
    _zval_dtor_func((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_346
  case 24: {
    _zval_dtor_func((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_347
  case 25: {
    _zval_dtor_func((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_348
  case 26: {
    _zval_dtor_func((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_349
  case 27: {
    _zval_ptr_dtor((&(id)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_350
  case 28: {
    _zval_ptr_dtor((&(return_value)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_351
  case 29: {
    _zval_ptr_dtor((&(rv)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_352
  case 30: {
    _zval_ptr_dtor((&(this_ptr)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_353
  case 31: {
    convert_to_boolean((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_354
  case 32: {
    convert_to_boolean((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_355
  case 33: {
    convert_to_boolean((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_356
  case 34: {
    convert_to_boolean((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_357
  case 35: {
    convert_to_long((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_358
  case 36: {
    convert_to_long((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_359
  case 37: {
    convert_to_long((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_360
  case 38: {
    convert_to_long((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_361
  case 39: {
    exit(1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_362
  case 40: {
    gc_remove_zval_from_buffer((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_363
  case 41: {
    gc_remove_zval_from_buffer((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_364
  case 42: {
    gc_remove_zval_from_buffer((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_365
  case 43: {
    gc_remove_zval_from_buffer((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_366
  case 44: {
    gc_zval_check_possible_root(((id)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_367
  case 45: {
    gc_zval_check_possible_root(((return_value)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_368
  case 46: {
    gc_zval_check_possible_root(((rv)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_369
  case 47: {
    gc_zval_check_possible_root(((this_ptr)));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_370
  case 48: {
    gc_zval_possible_root((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_371
  case 49: {
    gc_zval_possible_root((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_372
  case 50: {
    gc_zval_possible_root((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_373
  case 51: {
    gc_zval_possible_root((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_374
  case 52: {
    i_zval_ptr_dtor((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_375
  case 53: {
    i_zval_ptr_dtor((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_376
  case 54: {
    i_zval_ptr_dtor((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_377
  case 55: {
    i_zval_ptr_dtor((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_378
  case 56: {
    if (!__is_neg("2-56", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                  (void **){node, docp, name, value, return_value, intern, rv,
                            id, this_ptr, dom_document_class_entry},
                  0, 0, 14, "node", "docp", "name", "value", "return_value",
                  "intern", "rv", "ret", "id", "ht", "this_ptr", "name_len",
                  "value_len", "dom_document_class_entry"))
      node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_379
  case 57: {
    if (__is_neg("2-57", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                 (void **){node, docp, name, value, return_value, intern, rv,
                           id, this_ptr, dom_document_class_entry},
                 0, 0, 14, "node", "docp", "name", "value", "return_value",
                 "intern", "rv", "ret", "id", "ht", "this_ptr", "name_len",
                 "value_len", "dom_document_class_entry"))
      return;
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_380
  case 58: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_381
  case 59: {
    node = xmlNewChild(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_382
  case 60: {
    node = xmlNewDocNode((docp), ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_383
  case 61: {
    node = xmlNewDocNode((docp), ((void *)0), name, value);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_384
  case 62: {
    node = xmlNewDocNode(docp, ((void *)0), (name), value);

    break;
  }
#endif
#ifdef COMPILE_385
  case 63: {
    node = xmlNewDocNode(docp, ((void *)0), (name), value);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_386
  case 64: {
    node = xmlNewDocNode(docp, ((void *)0), (value), value);

    break;
  }
#endif
#ifdef COMPILE_387
  case 65: {
    node = xmlNewDocNode(docp, ((void *)0), (value), value);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_388
  case 66: {
    node = xmlNewDocNode(docp, ((void *)0), name, (name));

    break;
  }
#endif
#ifdef COMPILE_389
  case 67: {
    node = xmlNewDocNode(docp, ((void *)0), name, (name));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_390
  case 68: {
    node = xmlNewDocNode(docp, ((void *)0), name, (value));

    break;
  }
#endif
#ifdef COMPILE_391
  case 69: {
    node = xmlNewDocNode(docp, ((void *)0), name, (value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_392
  case 70: {
    node = xmlNewDocNode(docp, ((void *)0), name, value);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_393
  case 71: {
    node = xmlNewDocNodeEatName(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_394
  case 72: {
    node = xmlNewDocRawNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_395
  case 73: {
    node = xmlNewTextChild(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_396
  case 74: {
    php_dom_create_implementation((return_value_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_397
  case 75: {
    php_dom_create_interator((id), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_398
  case 76: {
    php_dom_create_interator((return_value), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_399
  case 77: {
    php_dom_create_interator((rv), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_400
  case 78: {
    php_dom_create_interator((this_ptr), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_401
  case 79: {
    php_dom_remove_xinclude_nodes((node));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_402
  case 80: {
    php_dom_remove_xinclude_nodes((node)->children);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_403
  case 81: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_404
  case 82: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_405
  case 83: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_406
  case 84: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_407
  case 85: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_408
  case 86: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_409
  case 87: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_410
  case 88: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_411
  case 89: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_412
  case 90: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_413
  case 91: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_414
  case 92: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_415
  case 93: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_416
  case 94: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_417
  case 95: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_418
  case 96: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_419
  case 97: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_420
  case 98: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_421
  case 99: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_422
  case 100: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_423
  case 101: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_424
  case 102: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_425
  case 103: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_426
  case 104: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_427
  case 105: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_428
  case 106: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_429
  case 107: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_430
  case 108: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_431
  case 109: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_432
  case 110: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_433
  case 111: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_434
  case 112: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_435
  case 113: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_436
  case 114: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_437
  case 115: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_438
  case 116: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_439
  case 117: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_440
  case 118: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_441
  case 119: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_442
  case 120: {
    php_dom_throw_error((PHP_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_443
  case 121: {
    php_dom_throw_error((PHP_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_444
  case 122: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_445
  case 123: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_446
  case 124: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_447
  case 125: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_448
  case 126: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_449
  case 127: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_450
  case 128: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_451
  case 129: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_452
  case 130: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_453
  case 131: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_454
  case 132: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_455
  case 133: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_456
  case 134: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_457
  case 135: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_458
  case 136: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_459
  case 137: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (name));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_460
  case 138: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_461
  case 139: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (name));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_462
  case 140: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_463
  case 141: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (name));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_464
  case 142: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_465
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_466
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_467
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_468
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_469
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_470
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_471
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_472
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_473
  case 151: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_474
  case 152: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_475
  case 153: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_476
  case 154: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_477
  case 155: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_478
  case 156: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_479
  case 157: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_480
  case 158: {
    php_libxml_node_free_resource((node));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_481
  case 159: {
    xmlFreeNode((node));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_482
  case 160: {
    xmlInitParser();
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_483
  case 161: {
    xmlUnlinkNode((node));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_484
  case 162: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_485
  case 163: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_486
  case 164: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_487
  case 165: {
    zval_unset_isref_p((id));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_488
  case 166: {
    zval_unset_isref_p((return_value));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_489
  case 167: {
    zval_unset_isref_p((rv));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
#ifdef COMPILE_490
  case 168: {
    zval_unset_isref_p((this_ptr));
    node = xmlNewDocNode(docp, ((void *)0), name, value);

    break;
  }
#endif
  }
  // prophet generated patch
  switch (__choose("__ID3")) {
  case 0: {
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#ifdef COMPILE_491
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_492
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_493
  case 3: {
    (name)++;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_494
  case 4: {
    (node) = xmlNewDocNode(docp, ((void *)0), name, value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_495
  case 5: {
    (value)++;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_496
  case 6: {
    _convert_to_string(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_497
  case 7: {
    _convert_to_string(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_498
  case 8: {
    _convert_to_string(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_499
  case 9: {
    _convert_to_string(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_500
  case 10: {
    _efree(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_501
  case 11: {
    _efree(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_502
  case 12: {
    _efree(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_503
  case 13: {
    _efree(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_504
  case 14: {
    _zval_copy_ctor_func((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_505
  case 15: {
    _zval_copy_ctor_func((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_506
  case 16: {
    _zval_copy_ctor_func((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_507
  case 17: {
    _zval_copy_ctor_func((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_508
  case 18: {
    _zval_dtor(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_509
  case 19: {
    _zval_dtor(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_510
  case 20: {
    _zval_dtor(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_511
  case 21: {
    _zval_dtor(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_512
  case 22: {
    _zval_dtor_func((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_513
  case 23: {
    _zval_dtor_func((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_514
  case 24: {
    _zval_dtor_func((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_515
  case 25: {
    _zval_dtor_func((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_516
  case 26: {
    _zval_ptr_dtor((&(id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_517
  case 27: {
    _zval_ptr_dtor((&(return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_518
  case 28: {
    _zval_ptr_dtor((&(rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_519
  case 29: {
    _zval_ptr_dtor((&(this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_520
  case 30: {
    convert_to_boolean((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_521
  case 31: {
    convert_to_boolean((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_522
  case 32: {
    convert_to_boolean((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_523
  case 33: {
    convert_to_boolean((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_524
  case 34: {
    convert_to_long((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_525
  case 35: {
    convert_to_long((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_526
  case 36: {
    convert_to_long((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_527
  case 37: {
    convert_to_long((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_528
  case 38: {
    exit(1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_529
  case 39: {
    gc_remove_zval_from_buffer((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_530
  case 40: {
    gc_remove_zval_from_buffer((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_531
  case 41: {
    gc_remove_zval_from_buffer((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_532
  case 42: {
    gc_remove_zval_from_buffer((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_533
  case 43: {
    gc_zval_check_possible_root(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_534
  case 44: {
    gc_zval_check_possible_root(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_535
  case 45: {
    gc_zval_check_possible_root(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_536
  case 46: {
    gc_zval_check_possible_root(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_537
  case 47: {
    gc_zval_possible_root((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_538
  case 48: {
    gc_zval_possible_root((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_539
  case 49: {
    gc_zval_possible_root((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_540
  case 50: {
    gc_zval_possible_root((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_541
  case 51: {
    i_zval_ptr_dtor((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_542
  case 52: {
    i_zval_ptr_dtor((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_543
  case 53: {
    i_zval_ptr_dtor((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_544
  case 54: {
    i_zval_ptr_dtor((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_545
  case 55: {
    if (!__is_neg("3-55", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                  (void **){node, return_value, docp, name, value, rv, intern,
                            id, this_ptr, dom_document_class_entry},
                  0, 0, 14, "node", "return_value", "docp", "name", "value",
                  "rv", "intern", "ret", "id", "ht", "this_ptr", "name_len",
                  "value_len", "dom_document_class_entry"))
      if (!node) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

    break;
  }
#endif
#ifdef COMPILE_546
  case 56: {
    if ((!node) &&
        !__is_neg("3-56", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                  (void **){node, return_value, docp, name, value, rv, intern,
                            id, this_ptr, dom_document_class_entry},
                  0, 0, 14, "node", "return_value", "docp", "name", "value",
                  "rv", "intern", "ret", "id", "ht", "this_ptr", "name_len",
                  "value_len", "dom_document_class_entry")) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_547
  case 57: {
    if ((!node) ||
        __is_neg("3-57", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                 (void **){node, return_value, docp, name, value, rv, intern,
                           id, this_ptr, dom_document_class_entry},
                 0, 0, 14, "node", "return_value", "docp", "name", "value",
                 "rv", "intern", "ret", "id", "ht", "this_ptr", "name_len",
                 "value_len", "dom_document_class_entry")) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_548
  case 58: {
    if (__is_neg("3-58", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                 (void **){node, return_value, docp, name, value, rv, intern,
                           id, this_ptr, dom_document_class_entry},
                 0, 0, 14, "node", "return_value", "docp", "name", "value",
                 "rv", "intern", "ret", "id", "ht", "this_ptr", "name_len",
                 "value_len", "dom_document_class_entry"))
      return;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_549
  case 59: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_550
  case 60: {
    node = xmlNewDocNode((docp), ((void *)0), name, value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_551
  case 61: {
    node = xmlNewDocNode(docp, ((void *)0), (name), value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_552
  case 62: {
    node = xmlNewDocNode(docp, ((void *)0), (value), value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_553
  case 63: {
    node = xmlNewDocNode(docp, ((void *)0), name, (name));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_554
  case 64: {
    node = xmlNewDocNode(docp, ((void *)0), name, (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_555
  case 65: {
    node = xmlNewDocNode(docp, ((void *)0), name, value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_556
  case 66: {
    php_dom_create_implementation((return_value_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_557
  case 67: {
    php_dom_create_interator((id), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_558
  case 68: {
    php_dom_create_interator((return_value), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_559
  case 69: {
    php_dom_create_interator((rv), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_560
  case 70: {
    php_dom_create_interator((this_ptr), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_561
  case 71: {
    php_dom_remove_xinclude_nodes((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_562
  case 72: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_563
  case 73: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_564
  case 74: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_565
  case 75: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_566
  case 76: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_567
  case 77: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_568
  case 78: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_569
  case 79: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_570
  case 80: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_571
  case 81: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_572
  case 82: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_573
  case 83: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_574
  case 84: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_575
  case 85: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_576
  case 86: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_577
  case 87: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_578
  case 88: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_579
  case 89: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_580
  case 90: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_581
  case 91: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_582
  case 92: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_583
  case 93: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_584
  case 94: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_585
  case 95: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_586
  case 96: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_587
  case 97: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_588
  case 98: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_589
  case 99: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_590
  case 100: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_591
  case 101: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_592
  case 102: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_593
  case 103: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_594
  case 104: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_595
  case 105: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_596
  case 106: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_597
  case 107: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_598
  case 108: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_599
  case 109: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_600
  case 110: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_601
  case 111: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_602
  case 112: {
    php_dom_throw_error((PHP_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_603
  case 113: {
    php_dom_throw_error((PHP_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_604
  case 114: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_605
  case 115: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_606
  case 116: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_607
  case 117: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_608
  case 118: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_609
  case 119: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_610
  case 120: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_611
  case 121: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_612
  case 122: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_613
  case 123: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_614
  case 124: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_615
  case 125: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_616
  case 126: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_617
  case 127: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_618
  case 128: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_619
  case 129: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (name));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_620
  case 130: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_621
  case 131: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (name));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_622
  case 132: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_623
  case 133: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (name));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_624
  case 134: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_625
  case 135: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_626
  case 136: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_627
  case 137: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_628
  case 138: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_629
  case 139: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_630
  case 140: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_631
  case 141: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_632
  case 142: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_633
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_634
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_635
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_636
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_637
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_638
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_639
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_640
  case 150: {
    php_libxml_node_free_resource((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_641
  case 151: {
    xmlFreeNode((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_642
  case 152: {
    xmlInitParser();
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_643
  case 153: {
    xmlUnlinkNode((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_644
  case 154: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_645
  case 155: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_646
  case 156: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_647
  case 157: {
    zval_unset_isref_p((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_648
  case 158: {
    zval_unset_isref_p((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_649
  case 159: {
    zval_unset_isref_p((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_650
  case 160: {
    zval_unset_isref_p((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID4")) {
  case 0: {
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#ifdef COMPILE_651
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_652
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_653
  case 3: {
    (name)++;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_654
  case 4: {
    (node) = xmlNewDocNode(docp, ((void *)0), name, value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_655
  case 5: {
    (value)++;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_656
  case 6: {
    _convert_to_string(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_657
  case 7: {
    _convert_to_string(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_658
  case 8: {
    _convert_to_string(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_659
  case 9: {
    _convert_to_string(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_660
  case 10: {
    _efree(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_661
  case 11: {
    _efree(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_662
  case 12: {
    _efree(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_663
  case 13: {
    _efree(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_664
  case 14: {
    _zval_copy_ctor_func((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_665
  case 15: {
    _zval_copy_ctor_func((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_666
  case 16: {
    _zval_copy_ctor_func((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_667
  case 17: {
    _zval_copy_ctor_func((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_668
  case 18: {
    _zval_dtor(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_669
  case 19: {
    _zval_dtor(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_670
  case 20: {
    _zval_dtor(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_671
  case 21: {
    _zval_dtor(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_672
  case 22: {
    _zval_dtor_func((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_673
  case 23: {
    _zval_dtor_func((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_674
  case 24: {
    _zval_dtor_func((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_675
  case 25: {
    _zval_dtor_func((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_676
  case 26: {
    _zval_ptr_dtor((&(id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_677
  case 27: {
    _zval_ptr_dtor((&(return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_678
  case 28: {
    _zval_ptr_dtor((&(rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_679
  case 29: {
    _zval_ptr_dtor((&(this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_680
  case 30: {
    convert_to_boolean((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_681
  case 31: {
    convert_to_boolean((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_682
  case 32: {
    convert_to_boolean((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_683
  case 33: {
    convert_to_boolean((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_684
  case 34: {
    convert_to_long((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_685
  case 35: {
    convert_to_long((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_686
  case 36: {
    convert_to_long((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_687
  case 37: {
    convert_to_long((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_688
  case 38: {
    exit(1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_689
  case 39: {
    gc_remove_zval_from_buffer((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_690
  case 40: {
    gc_remove_zval_from_buffer((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_691
  case 41: {
    gc_remove_zval_from_buffer((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_692
  case 42: {
    gc_remove_zval_from_buffer((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_693
  case 43: {
    gc_zval_check_possible_root(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_694
  case 44: {
    gc_zval_check_possible_root(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_695
  case 45: {
    gc_zval_check_possible_root(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_696
  case 46: {
    gc_zval_check_possible_root(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_697
  case 47: {
    gc_zval_possible_root((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_698
  case 48: {
    gc_zval_possible_root((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_699
  case 49: {
    gc_zval_possible_root((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_700
  case 50: {
    gc_zval_possible_root((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_701
  case 51: {
    i_zval_ptr_dtor((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_702
  case 52: {
    i_zval_ptr_dtor((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_703
  case 53: {
    i_zval_ptr_dtor((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_704
  case 54: {
    i_zval_ptr_dtor((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_705
  case 55: {
    if (!__is_neg("4-55", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                  (void **){return_value, rv, node, intern, docp, name, value,
                            id, this_ptr, dom_document_class_entry},
                  0, 0, 14, "return_value", "rv", "node", "intern", "ret",
                  "docp", "name", "value", "id", "ht", "this_ptr", "name_len",
                  "value_len", "dom_document_class_entry") &&
        (((void *)0) ==
         (rv = php_dom_create_object(node, &ret, rv, return_value, intern)))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_706
  case 56: {
    if (!__is_neg("4-56", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                  (void **){return_value, rv, node, intern, docp, name, value,
                            id, this_ptr, dom_document_class_entry},
                  0, 0, 14, "return_value", "rv", "node", "intern", "ret",
                  "docp", "name", "value", "id", "ht", "this_ptr", "name_len",
                  "value_len", "dom_document_class_entry"))
      if (((void *)0) ==
          (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Cannot create required DOM object");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

    break;
  }
#endif
#ifdef COMPILE_707
  case 57: {
    if ((((void *)0) ==
         (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) &&
        !__is_neg("4-57", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                  (void **){return_value, rv, node, intern, docp, name, value,
                            id, this_ptr, dom_document_class_entry},
                  0, 0, 14, "return_value", "rv", "node", "intern", "ret",
                  "docp", "name", "value", "id", "ht", "this_ptr", "name_len",
                  "value_len", "dom_document_class_entry")) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_708
  case 58: {
    if ((((void *)0) ==
         (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) ||
        __is_neg("4-58", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                 (void **){return_value, rv, node, intern, docp, name, value,
                           id, this_ptr, dom_document_class_entry},
                 0, 0, 14, "return_value", "rv", "node", "intern", "ret",
                 "docp", "name", "value", "id", "ht", "this_ptr", "name_len",
                 "value_len", "dom_document_class_entry")) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_709
  case 59: {
    if (__is_neg("4-59", 4, (int *){ret, ht, name_len, value_len}, 0, 0, 10,
                 (void **){return_value, rv, node, intern, docp, name, value,
                           id, this_ptr, dom_document_class_entry},
                 0, 0, 14, "return_value", "rv", "node", "intern", "ret",
                 "docp", "name", "value", "id", "ht", "this_ptr", "name_len",
                 "value_len", "dom_document_class_entry"))
      return;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_710
  case 60: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os|s", &id,
                                     dom_document_class_entry, &name, &name_len,
                                     &value, &value_len) == -1) {
      return;
    }
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_711
  case 61: {
    memset(intern, 0, sizeof(*(intern)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_712
  case 62: {
    node = xmlNewDocNode((docp), ((void *)0), name, value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_713
  case 63: {
    node = xmlNewDocNode(docp, ((void *)0), (name), value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_714
  case 64: {
    node = xmlNewDocNode(docp, ((void *)0), (value), value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_715
  case 65: {
    node = xmlNewDocNode(docp, ((void *)0), name, (name));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_716
  case 66: {
    node = xmlNewDocNode(docp, ((void *)0), name, (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_717
  case 67: {
    node = xmlNewDocNode(docp, ((void *)0), name, value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_718
  case 68: {
    php_dom_create_implementation((return_value_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_719
  case 69: {
    php_dom_create_interator((id), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_720
  case 70: {
    php_dom_create_interator((return_value), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_721
  case 71: {
    php_dom_create_interator((rv), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_722
  case 72: {
    php_dom_create_interator((this_ptr), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_723
  case 73: {
    php_dom_remove_xinclude_nodes((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_724
  case 74: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_725
  case 75: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_726
  case 76: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_727
  case 77: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_728
  case 78: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_729
  case 79: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_730
  case 80: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_731
  case 81: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_732
  case 82: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_733
  case 83: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_734
  case 84: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_735
  case 85: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_736
  case 86: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_737
  case 87: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_738
  case 88: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_739
  case 89: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_740
  case 90: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_741
  case 91: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_742
  case 92: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_743
  case 93: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_744
  case 94: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_745
  case 95: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_746
  case 96: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_747
  case 97: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_748
  case 98: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_749
  case 99: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_750
  case 100: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_751
  case 101: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_752
  case 102: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_753
  case 103: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_754
  case 104: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_755
  case 105: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_756
  case 106: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_757
  case 107: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_758
  case 108: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_759
  case 109: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_760
  case 110: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_761
  case 111: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_762
  case 112: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_763
  case 113: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_764
  case 114: {
    php_dom_throw_error((PHP_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_765
  case 115: {
    php_dom_throw_error((PHP_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_766
  case 116: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_767
  case 117: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_768
  case 118: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_769
  case 119: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_770
  case 120: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_771
  case 121: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_772
  case 122: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_773
  case 123: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_774
  case 124: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_775
  case 125: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_776
  case 126: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_777
  case 127: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_778
  case 128: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_779
  case 129: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_780
  case 130: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_781
  case 131: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (name));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_782
  case 132: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_783
  case 133: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (name));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_784
  case 134: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_785
  case 135: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (name));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_786
  case 136: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_787
  case 137: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_788
  case 138: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_789
  case 139: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_790
  case 140: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_791
  case 141: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_792
  case 142: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_793
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_794
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_795
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_796
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_797
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_798
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_799
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_800
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_801
  case 151: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_802
  case 152: {
    php_libxml_node_free_resource((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_803
  case 153: {
    xmlFreeNode((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_804
  case 154: {
    xmlInitParser();
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_805
  case 155: {
    xmlUnlinkNode((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_806
  case 156: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_807
  case 157: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_808
  case 158: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_809
  case 159: {
    zval_unset_isref_p((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_810
  case 160: {
    zval_unset_isref_p((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_811
  case 161: {
    zval_unset_isref_p((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_812
  case 162: {
    zval_unset_isref_p((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
  }
}
/* }}} end dom_document_create_element */

/* {{{ proto DOMDocumentFragment dom_document_create_document_fragment();
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-35CB04B5
Since:
*/
PHP_FUNCTION(dom_document_create_document_fragment) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp;
  dom_object *intern;
  int ret;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",
                                   &id, dom_document_class_entry) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  node = xmlNewDocFragment(docp);
  if (!node) {
    RETURN_FALSE;
  }

  DOM_RET_OBJ(rv, node, &ret, intern);
}
/* }}} end dom_document_create_document_fragment */

/* {{{ proto DOMText dom_document_create_text_node(string data);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-1975348127
Since:
*/
PHP_FUNCTION(dom_document_create_text_node) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp;
  int ret, value_len;
  dom_object *intern;
  char *value;

  // prophet generated patch
  switch (__choose("__ID5")) {
  case 0: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#ifdef COMPILE_813
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_814
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_815
  case 3: {
    (node) = xmlNewDocText(docp, (xmlChar *)value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_816
  case 4: {
    (value)++;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_817
  case 5: {
    _convert_to_string(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_818
  case 6: {
    _convert_to_string(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_819
  case 7: {
    _convert_to_string(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_820
  case 8: {
    _convert_to_string(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_821
  case 9: {
    _efree(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_822
  case 10: {
    _efree(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_823
  case 11: {
    _efree(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_824
  case 12: {
    _efree(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_825
  case 13: {
    _zval_copy_ctor_func((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_826
  case 14: {
    _zval_copy_ctor_func((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_827
  case 15: {
    _zval_copy_ctor_func((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_828
  case 16: {
    _zval_copy_ctor_func((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_829
  case 17: {
    _zval_dtor(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_830
  case 18: {
    _zval_dtor(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_831
  case 19: {
    _zval_dtor(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_832
  case 20: {
    _zval_dtor(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_833
  case 21: {
    _zval_dtor_func((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_834
  case 22: {
    _zval_dtor_func((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_835
  case 23: {
    _zval_dtor_func((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_836
  case 24: {
    _zval_dtor_func((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_837
  case 25: {
    _zval_ptr_dtor((&(id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_838
  case 26: {
    _zval_ptr_dtor((&(return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_839
  case 27: {
    _zval_ptr_dtor((&(rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_840
  case 28: {
    _zval_ptr_dtor((&(this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_841
  case 29: {
    convert_to_boolean((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_842
  case 30: {
    convert_to_boolean((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_843
  case 31: {
    convert_to_boolean((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_844
  case 32: {
    convert_to_boolean((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_845
  case 33: {
    convert_to_long((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_846
  case 34: {
    convert_to_long((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_847
  case 35: {
    convert_to_long((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_848
  case 36: {
    convert_to_long((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_849
  case 37: {
    exit(1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_850
  case 38: {
    gc_remove_zval_from_buffer((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_851
  case 39: {
    gc_remove_zval_from_buffer((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_852
  case 40: {
    gc_remove_zval_from_buffer((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_853
  case 41: {
    gc_remove_zval_from_buffer((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_854
  case 42: {
    gc_zval_check_possible_root(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_855
  case 43: {
    gc_zval_check_possible_root(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_856
  case 44: {
    gc_zval_check_possible_root(((rv)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_857
  case 45: {
    gc_zval_check_possible_root(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_858
  case 46: {
    gc_zval_possible_root((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_859
  case 47: {
    gc_zval_possible_root((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_860
  case 48: {
    gc_zval_possible_root((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_861
  case 49: {
    gc_zval_possible_root((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_862
  case 50: {
    i_zval_ptr_dtor((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_863
  case 51: {
    i_zval_ptr_dtor((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_864
  case 52: {
    i_zval_ptr_dtor((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_865
  case 53: {
    i_zval_ptr_dtor((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_866
  case 54: {
    if (!__is_neg("5-54", 3, (int *){ht, value_len, ret}, 0, 0, 9,
                  (void **){this_ptr, id, value, dom_document_class_entry,
                            return_value, docp, intern, node, rv},
                  0, 0, 12, "ht", "this_ptr", "id", "value_len", "value",
                  "dom_document_class_entry", "return_value", "docp", "intern",
                  "node", "rv", "ret") &&
        (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                      dom_document_class_entry, &value,
                                      &value_len) == -1)) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_867
  case 55: {
    if (!__is_neg("5-55", 3, (int *){ht, value_len, ret}, 0, 0, 9,
                  (void **){this_ptr, id, value, dom_document_class_entry,
                            return_value, docp, intern, node, rv},
                  0, 0, 12, "ht", "this_ptr", "id", "value_len", "value",
                  "dom_document_class_entry", "return_value", "docp", "intern",
                  "node", "rv", "ret"))
      if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                       dom_document_class_entry, &value,
                                       &value_len) == -1) {
        return;
      }

    break;
  }
#endif
#ifdef COMPILE_868
  case 56: {
    if ((zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                      dom_document_class_entry, &value,
                                      &value_len) == -1) &&
        !__is_neg("5-56", 3, (int *){ht, value_len, ret}, 0, 0, 9,
                  (void **){this_ptr, id, value, dom_document_class_entry,
                            return_value, docp, intern, node, rv},
                  0, 0, 12, "ht", "this_ptr", "id", "value_len", "value",
                  "dom_document_class_entry", "return_value", "docp", "intern",
                  "node", "rv", "ret")) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_869
  case 57: {
    if ((zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                      dom_document_class_entry, &value,
                                      &value_len) == -1) ||
        __is_neg("5-57", 3, (int *){ht, value_len, ret}, 0, 0, 9,
                 (void **){this_ptr, id, value, dom_document_class_entry,
                           return_value, docp, intern, node, rv},
                 0, 0, 12, "ht", "this_ptr", "id", "value_len", "value",
                 "dom_document_class_entry", "return_value", "docp", "intern",
                 "node", "rv", "ret")) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_870
  case 58: {
    if (__is_neg("5-58", 3, (int *){ht, value_len, ret}, 0, 0, 9,
                 (void **){this_ptr, id, value, dom_document_class_entry,
                           return_value, docp, intern, node, rv},
                 0, 0, 12, "ht", "this_ptr", "id", "value_len", "value",
                 "dom_document_class_entry", "return_value", "docp", "intern",
                 "node", "rv", "ret"))
      return;
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_871
  case 59: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_872
  case 60: {
    node = xmlNewDocText((docp), (xmlChar *)value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_873
  case 61: {
    node = xmlNewDocText(docp, (xmlChar *)value);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_874
  case 62: {
    php_dom_create_implementation((return_value_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_875
  case 63: {
    php_dom_create_interator((id), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_876
  case 64: {
    php_dom_create_interator((return_value), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_877
  case 65: {
    php_dom_create_interator((rv), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_878
  case 66: {
    php_dom_create_interator((this_ptr), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_879
  case 67: {
    php_dom_remove_xinclude_nodes((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_880
  case 68: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_881
  case 69: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_882
  case 70: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_883
  case 71: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_884
  case 72: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_885
  case 73: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_886
  case 74: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_887
  case 75: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_888
  case 76: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_889
  case 77: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_890
  case 78: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_891
  case 79: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_892
  case 80: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_893
  case 81: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_894
  case 82: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_895
  case 83: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_896
  case 84: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_897
  case 85: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_898
  case 86: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_899
  case 87: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_900
  case 88: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_901
  case 89: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_902
  case 90: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_903
  case 91: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_904
  case 92: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_905
  case 93: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_906
  case 94: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_907
  case 95: {
    php_dom_throw_error((PHP_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_908
  case 96: {
    php_dom_throw_error((PHP_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_909
  case 97: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_910
  case 98: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_911
  case 99: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_912
  case 100: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_913
  case 101: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_914
  case 102: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_915
  case 103: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_916
  case 104: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_917
  case 105: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_918
  case 106: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_919
  case 107: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_920
  case 108: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_921
  case 109: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_922
  case 110: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_923
  case 111: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_924
  case 112: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_925
  case 113: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_926
  case 114: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_927
  case 115: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_928
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_929
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_930
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_931
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_932
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_933
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_934
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_935
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_936
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_937
  case 125: {
    php_libxml_node_free_resource((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_938
  case 126: {
    xmlFreeNode((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_939
  case 127: {
    xmlInitParser();
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_940
  case 128: {
    xmlUnlinkNode((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_941
  case 129: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_942
  case 130: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_943
  case 131: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_944
  case 132: {
    zval_unset_isref_p((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_945
  case 133: {
    zval_unset_isref_p((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_946
  case 134: {
    zval_unset_isref_p((rv));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_947
  case 135: {
    zval_unset_isref_p((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }

    break;
  }
#endif
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  // prophet generated patch
  switch (__choose("__ID6")) {
  case 0: {
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#ifdef COMPILE_948
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_949
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_950
  case 3: {
    (node) = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_951
  case 4: {
    (node) = xmlNewDocText(docp, (xmlChar *)value);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_952
  case 5: {
    (value)++;
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_953
  case 6: {
    _convert_to_string(((id)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_954
  case 7: {
    _convert_to_string(((return_value)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_955
  case 8: {
    _convert_to_string(((rv)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_956
  case 9: {
    _convert_to_string(((this_ptr)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_957
  case 10: {
    _efree(((id)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_958
  case 11: {
    _efree(((return_value)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_959
  case 12: {
    _efree(((rv)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_960
  case 13: {
    _efree(((this_ptr)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_961
  case 14: {
    _zval_copy_ctor_func((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_962
  case 15: {
    _zval_copy_ctor_func((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_963
  case 16: {
    _zval_copy_ctor_func((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_964
  case 17: {
    _zval_copy_ctor_func((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_965
  case 18: {
    _zval_dtor(((id)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_966
  case 19: {
    _zval_dtor(((return_value)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_967
  case 20: {
    _zval_dtor(((rv)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_968
  case 21: {
    _zval_dtor(((this_ptr)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_969
  case 22: {
    _zval_dtor_func((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_970
  case 23: {
    _zval_dtor_func((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_971
  case 24: {
    _zval_dtor_func((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_972
  case 25: {
    _zval_dtor_func((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_973
  case 26: {
    _zval_ptr_dtor((&(id)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_974
  case 27: {
    _zval_ptr_dtor((&(return_value)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_975
  case 28: {
    _zval_ptr_dtor((&(rv)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_976
  case 29: {
    _zval_ptr_dtor((&(this_ptr)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_977
  case 30: {
    convert_to_boolean((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_978
  case 31: {
    convert_to_boolean((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_979
  case 32: {
    convert_to_boolean((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_980
  case 33: {
    convert_to_boolean((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_981
  case 34: {
    convert_to_long((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_982
  case 35: {
    convert_to_long((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_983
  case 36: {
    convert_to_long((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_984
  case 37: {
    convert_to_long((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_985
  case 38: {
    exit(1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_986
  case 39: {
    gc_remove_zval_from_buffer((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_987
  case 40: {
    gc_remove_zval_from_buffer((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_988
  case 41: {
    gc_remove_zval_from_buffer((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_989
  case 42: {
    gc_remove_zval_from_buffer((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_990
  case 43: {
    gc_zval_check_possible_root(((id)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_991
  case 44: {
    gc_zval_check_possible_root(((return_value)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_992
  case 45: {
    gc_zval_check_possible_root(((rv)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_993
  case 46: {
    gc_zval_check_possible_root(((this_ptr)));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_994
  case 47: {
    gc_zval_possible_root((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_995
  case 48: {
    gc_zval_possible_root((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_996
  case 49: {
    gc_zval_possible_root((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_997
  case 50: {
    gc_zval_possible_root((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_998
  case 51: {
    i_zval_ptr_dtor((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_999
  case 52: {
    i_zval_ptr_dtor((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1000
  case 53: {
    i_zval_ptr_dtor((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1001
  case 54: {
    i_zval_ptr_dtor((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1002
  case 55: {
    if (!__is_neg("6-55", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                  (void **){node, docp, value, return_value, id, intern, rv,
                            this_ptr, dom_document_class_entry},
                  0, 0, 12, "node", "docp", "value", "return_value", "id",
                  "intern", "rv", "ret", "ht", "this_ptr", "value_len",
                  "dom_document_class_entry"))
      node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1003
  case 56: {
    if (__is_neg("6-56", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                 (void **){node, docp, value, return_value, id, intern, rv,
                           this_ptr, dom_document_class_entry},
                 0, 0, 12, "node", "docp", "value", "return_value", "id",
                 "intern", "rv", "ret", "ht", "this_ptr", "value_len",
                 "dom_document_class_entry"))
      return;
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1004
  case 57: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1005
  case 58: {
    node = xmlDocCopyNodeList(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1006
  case 59: {
    node = xmlDocSetRootElement(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1007
  case 60: {
    node = xmlNewCharRef(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1008
  case 61: {
    node = xmlNewDocComment(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1009
  case 62: {
    node = xmlNewDocText((docp), (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1010
  case 63: {
    node = xmlNewDocText((docp), (xmlChar *)value);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1011
  case 64: {
    node = xmlNewDocText(docp, (xmlChar *)value);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1012
  case 65: {
    node = xmlNewNode(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1013
  case 66: {
    node = xmlNewPI(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1014
  case 67: {
    node = xmlNewReference(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1015
  case 68: {
    node = xmlStringGetNodeList(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1016
  case 69: {
    php_dom_create_implementation((return_value_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1017
  case 70: {
    php_dom_create_interator((id), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1018
  case 71: {
    php_dom_create_interator((return_value), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1019
  case 72: {
    php_dom_create_interator((rv), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1020
  case 73: {
    php_dom_create_interator((this_ptr), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1021
  case 74: {
    php_dom_remove_xinclude_nodes((node));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1022
  case 75: {
    php_dom_remove_xinclude_nodes((node)->children);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1023
  case 76: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1024
  case 77: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1025
  case 78: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1026
  case 79: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1027
  case 80: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1028
  case 81: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1029
  case 82: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1030
  case 83: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1031
  case 84: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1032
  case 85: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1033
  case 86: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1034
  case 87: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1035
  case 88: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1036
  case 89: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1037
  case 90: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1038
  case 91: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1039
  case 92: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1040
  case 93: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1041
  case 94: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1042
  case 95: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1043
  case 96: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1044
  case 97: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1045
  case 98: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1046
  case 99: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1047
  case 100: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1048
  case 101: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1049
  case 102: {
    php_dom_throw_error((PHP_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1050
  case 103: {
    php_dom_throw_error((PHP_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1051
  case 104: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1052
  case 105: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1053
  case 106: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1054
  case 107: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1055
  case 108: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1056
  case 109: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1057
  case 110: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1058
  case 111: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1059
  case 112: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1060
  case 113: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1061
  case 114: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1062
  case 115: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1063
  case 116: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1064
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1065
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1066
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1067
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1068
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1069
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1070
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1071
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1072
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1073
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1074
  case 127: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1075
  case 128: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1076
  case 129: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1077
  case 130: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1078
  case 131: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1079
  case 132: {
    php_libxml_node_free_resource((node));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1080
  case 133: {
    xmlFreeNode((node));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1081
  case 134: {
    xmlInitParser();
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1082
  case 135: {
    xmlUnlinkNode((node));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1083
  case 136: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1084
  case 137: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1085
  case 138: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1086
  case 139: {
    zval_unset_isref_p((id));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1087
  case 140: {
    zval_unset_isref_p((return_value));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1088
  case 141: {
    zval_unset_isref_p((rv));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
#ifdef COMPILE_1089
  case 142: {
    zval_unset_isref_p((this_ptr));
    node = xmlNewDocText(docp, (xmlChar *)value);

    break;
  }
#endif
  }
  // prophet generated patch
  switch (__choose("__ID7")) {
  case 0: {
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#ifdef COMPILE_1090
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1091
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1092
  case 3: {
    (node) = xmlNewDocText(docp, (xmlChar *)value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1093
  case 4: {
    (value)++;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1094
  case 5: {
    _convert_to_string(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1095
  case 6: {
    _convert_to_string(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1096
  case 7: {
    _convert_to_string(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1097
  case 8: {
    _convert_to_string(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1098
  case 9: {
    _efree(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1099
  case 10: {
    _efree(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1100
  case 11: {
    _efree(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1101
  case 12: {
    _efree(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1102
  case 13: {
    _zval_copy_ctor_func((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1103
  case 14: {
    _zval_copy_ctor_func((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1104
  case 15: {
    _zval_copy_ctor_func((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1105
  case 16: {
    _zval_copy_ctor_func((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1106
  case 17: {
    _zval_dtor(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1107
  case 18: {
    _zval_dtor(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1108
  case 19: {
    _zval_dtor(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1109
  case 20: {
    _zval_dtor(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1110
  case 21: {
    _zval_dtor_func((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1111
  case 22: {
    _zval_dtor_func((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1112
  case 23: {
    _zval_dtor_func((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1113
  case 24: {
    _zval_dtor_func((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1114
  case 25: {
    _zval_ptr_dtor((&(id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1115
  case 26: {
    _zval_ptr_dtor((&(return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1116
  case 27: {
    _zval_ptr_dtor((&(rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1117
  case 28: {
    _zval_ptr_dtor((&(this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1118
  case 29: {
    convert_to_boolean((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1119
  case 30: {
    convert_to_boolean((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1120
  case 31: {
    convert_to_boolean((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1121
  case 32: {
    convert_to_boolean((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1122
  case 33: {
    convert_to_long((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1123
  case 34: {
    convert_to_long((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1124
  case 35: {
    convert_to_long((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1125
  case 36: {
    convert_to_long((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1126
  case 37: {
    exit(1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1127
  case 38: {
    gc_remove_zval_from_buffer((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1128
  case 39: {
    gc_remove_zval_from_buffer((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1129
  case 40: {
    gc_remove_zval_from_buffer((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1130
  case 41: {
    gc_remove_zval_from_buffer((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1131
  case 42: {
    gc_zval_check_possible_root(((id)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1132
  case 43: {
    gc_zval_check_possible_root(((return_value)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1133
  case 44: {
    gc_zval_check_possible_root(((rv)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1134
  case 45: {
    gc_zval_check_possible_root(((this_ptr)));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1135
  case 46: {
    gc_zval_possible_root((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1136
  case 47: {
    gc_zval_possible_root((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1137
  case 48: {
    gc_zval_possible_root((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1138
  case 49: {
    gc_zval_possible_root((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1139
  case 50: {
    i_zval_ptr_dtor((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1140
  case 51: {
    i_zval_ptr_dtor((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1141
  case 52: {
    i_zval_ptr_dtor((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1142
  case 53: {
    i_zval_ptr_dtor((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1143
  case 54: {
    if (!__is_neg("7-54", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                  (void **){node, return_value, docp, value, id, intern, rv,
                            this_ptr, dom_document_class_entry},
                  0, 0, 12, "node", "return_value", "docp", "value", "id",
                  "intern", "rv", "ret", "ht", "this_ptr", "value_len",
                  "dom_document_class_entry"))
      if (!node) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

    break;
  }
#endif
#ifdef COMPILE_1144
  case 55: {
    if ((!node) &&
        !__is_neg("7-55", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                  (void **){node, return_value, docp, value, id, intern, rv,
                            this_ptr, dom_document_class_entry},
                  0, 0, 12, "node", "return_value", "docp", "value", "id",
                  "intern", "rv", "ret", "ht", "this_ptr", "value_len",
                  "dom_document_class_entry")) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1145
  case 56: {
    if ((!node) ||
        __is_neg("7-56", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                 (void **){node, return_value, docp, value, id, intern, rv,
                           this_ptr, dom_document_class_entry},
                 0, 0, 12, "node", "return_value", "docp", "value", "id",
                 "intern", "rv", "ret", "ht", "this_ptr", "value_len",
                 "dom_document_class_entry")) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1146
  case 57: {
    if (__is_neg("7-57", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                 (void **){node, return_value, docp, value, id, intern, rv,
                           this_ptr, dom_document_class_entry},
                 0, 0, 12, "node", "return_value", "docp", "value", "id",
                 "intern", "rv", "ret", "ht", "this_ptr", "value_len",
                 "dom_document_class_entry"))
      return;
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1147
  case 58: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1148
  case 59: {
    node = xmlNewDocText((docp), (xmlChar *)value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1149
  case 60: {
    node = xmlNewDocText(docp, (xmlChar *)value);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1150
  case 61: {
    php_dom_create_implementation((return_value_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1151
  case 62: {
    php_dom_create_interator((id), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1152
  case 63: {
    php_dom_create_interator((return_value), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1153
  case 64: {
    php_dom_create_interator((rv), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1154
  case 65: {
    php_dom_create_interator((this_ptr), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1155
  case 66: {
    php_dom_remove_xinclude_nodes((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1156
  case 67: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1157
  case 68: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1158
  case 69: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1159
  case 70: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1160
  case 71: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1161
  case 72: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1162
  case 73: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1163
  case 74: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1164
  case 75: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1165
  case 76: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1166
  case 77: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1167
  case 78: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1168
  case 79: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1169
  case 80: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1170
  case 81: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1171
  case 82: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1172
  case 83: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1173
  case 84: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1174
  case 85: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1175
  case 86: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1176
  case 87: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1177
  case 88: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1178
  case 89: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1179
  case 90: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1180
  case 91: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1181
  case 92: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1182
  case 93: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1183
  case 94: {
    php_dom_throw_error((PHP_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1184
  case 95: {
    php_dom_throw_error((PHP_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1185
  case 96: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1186
  case 97: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1187
  case 98: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1188
  case 99: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1189
  case 100: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1190
  case 101: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1191
  case 102: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1192
  case 103: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1193
  case 104: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1194
  case 105: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1195
  case 106: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1196
  case 107: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1197
  case 108: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1198
  case 109: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1199
  case 110: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1200
  case 111: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1201
  case 112: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1202
  case 113: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1203
  case 114: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1204
  case 115: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1205
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1206
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1207
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1208
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1209
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1210
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1211
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1212
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1213
  case 124: {
    php_libxml_node_free_resource((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1214
  case 125: {
    xmlFreeNode((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1215
  case 126: {
    xmlInitParser();
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1216
  case 127: {
    xmlUnlinkNode((node));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1217
  case 128: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1218
  case 129: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1219
  case 130: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1220
  case 131: {
    zval_unset_isref_p((id));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1221
  case 132: {
    zval_unset_isref_p((return_value));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1222
  case 133: {
    zval_unset_isref_p((rv));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1223
  case 134: {
    zval_unset_isref_p((this_ptr));
    if (!node) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID8")) {
  case 0: {
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#ifdef COMPILE_1224
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1225
  case 2: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1226
  case 3: {
    (node) = xmlNewDocText(docp, (xmlChar *)value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1227
  case 4: {
    (value)++;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1228
  case 5: {
    _convert_to_string(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1229
  case 6: {
    _convert_to_string(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1230
  case 7: {
    _convert_to_string(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1231
  case 8: {
    _convert_to_string(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1232
  case 9: {
    _efree(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1233
  case 10: {
    _efree(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1234
  case 11: {
    _efree(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1235
  case 12: {
    _efree(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1236
  case 13: {
    _zval_copy_ctor_func((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1237
  case 14: {
    _zval_copy_ctor_func((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1238
  case 15: {
    _zval_copy_ctor_func((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1239
  case 16: {
    _zval_copy_ctor_func((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1240
  case 17: {
    _zval_dtor(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1241
  case 18: {
    _zval_dtor(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1242
  case 19: {
    _zval_dtor(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1243
  case 20: {
    _zval_dtor(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1244
  case 21: {
    _zval_dtor_func((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1245
  case 22: {
    _zval_dtor_func((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1246
  case 23: {
    _zval_dtor_func((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1247
  case 24: {
    _zval_dtor_func((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1248
  case 25: {
    _zval_ptr_dtor((&(id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1249
  case 26: {
    _zval_ptr_dtor((&(return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1250
  case 27: {
    _zval_ptr_dtor((&(rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1251
  case 28: {
    _zval_ptr_dtor((&(this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1252
  case 29: {
    convert_to_boolean((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1253
  case 30: {
    convert_to_boolean((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1254
  case 31: {
    convert_to_boolean((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1255
  case 32: {
    convert_to_boolean((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1256
  case 33: {
    convert_to_long((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1257
  case 34: {
    convert_to_long((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1258
  case 35: {
    convert_to_long((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1259
  case 36: {
    convert_to_long((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1260
  case 37: {
    exit(1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1261
  case 38: {
    gc_remove_zval_from_buffer((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1262
  case 39: {
    gc_remove_zval_from_buffer((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1263
  case 40: {
    gc_remove_zval_from_buffer((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1264
  case 41: {
    gc_remove_zval_from_buffer((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1265
  case 42: {
    gc_zval_check_possible_root(((id)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1266
  case 43: {
    gc_zval_check_possible_root(((return_value)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1267
  case 44: {
    gc_zval_check_possible_root(((rv)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1268
  case 45: {
    gc_zval_check_possible_root(((this_ptr)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1269
  case 46: {
    gc_zval_possible_root((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1270
  case 47: {
    gc_zval_possible_root((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1271
  case 48: {
    gc_zval_possible_root((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1272
  case 49: {
    gc_zval_possible_root((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1273
  case 50: {
    i_zval_ptr_dtor((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1274
  case 51: {
    i_zval_ptr_dtor((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1275
  case 52: {
    i_zval_ptr_dtor((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1276
  case 53: {
    i_zval_ptr_dtor((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1277
  case 54: {
    if (!__is_neg("8-54", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                  (void **){return_value, rv, node, intern, docp, value, id,
                            this_ptr, dom_document_class_entry},
                  0, 0, 12, "return_value", "rv", "node", "ret", "intern",
                  "docp", "value", "id", "ht", "this_ptr", "value_len",
                  "dom_document_class_entry") &&
        (((void *)0) ==
         (rv = php_dom_create_object(node, &ret, rv, return_value, intern)))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1278
  case 55: {
    if (!__is_neg("8-55", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                  (void **){return_value, rv, node, intern, docp, value, id,
                            this_ptr, dom_document_class_entry},
                  0, 0, 12, "return_value", "rv", "node", "ret", "intern",
                  "docp", "value", "id", "ht", "this_ptr", "value_len",
                  "dom_document_class_entry"))
      if (((void *)0) ==
          (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Cannot create required DOM object");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

    break;
  }
#endif
#ifdef COMPILE_1279
  case 56: {
    if ((((void *)0) ==
         (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) &&
        !__is_neg("8-56", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                  (void **){return_value, rv, node, intern, docp, value, id,
                            this_ptr, dom_document_class_entry},
                  0, 0, 12, "return_value", "rv", "node", "ret", "intern",
                  "docp", "value", "id", "ht", "this_ptr", "value_len",
                  "dom_document_class_entry")) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1280
  case 57: {
    if ((((void *)0) ==
         (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) ||
        __is_neg("8-57", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                 (void **){return_value, rv, node, intern, docp, value, id,
                           this_ptr, dom_document_class_entry},
                 0, 0, 12, "return_value", "rv", "node", "ret", "intern",
                 "docp", "value", "id", "ht", "this_ptr", "value_len",
                 "dom_document_class_entry")) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1281
  case 58: {
    if (__is_neg("8-58", 3, (int *){ret, ht, value_len}, 0, 0, 9,
                 (void **){return_value, rv, node, intern, docp, value, id,
                           this_ptr, dom_document_class_entry},
                 0, 0, 12, "return_value", "rv", "node", "ret", "intern",
                 "docp", "value", "id", "ht", "this_ptr", "value_len",
                 "dom_document_class_entry"))
      return;
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1282
  case 59: {
    if (zend_parse_method_parameters((ht), (this_ptr), "Os", &id,
                                     dom_document_class_entry, &value,
                                     &value_len) == -1) {
      return;
    }
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1283
  case 60: {
    memset(intern, 0, sizeof(*(intern)));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1284
  case 61: {
    node = xmlNewDocText((docp), (xmlChar *)value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1285
  case 62: {
    node = xmlNewDocText(docp, (xmlChar *)value);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1286
  case 63: {
    php_dom_create_implementation((return_value_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1287
  case 64: {
    php_dom_create_interator((id), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1288
  case 65: {
    php_dom_create_interator((return_value), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1289
  case 66: {
    php_dom_create_interator((rv), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1290
  case 67: {
    php_dom_create_interator((this_ptr), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1291
  case 68: {
    php_dom_remove_xinclude_nodes((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1292
  case 69: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1293
  case 70: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1294
  case 71: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1295
  case 72: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1296
  case 73: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1297
  case 74: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1298
  case 75: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1299
  case 76: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1300
  case 77: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1301
  case 78: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1302
  case 79: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1303
  case 80: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1304
  case 81: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1305
  case 82: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1306
  case 83: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1307
  case 84: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1308
  case 85: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1309
  case 86: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1310
  case 87: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1311
  case 88: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1312
  case 89: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1313
  case 90: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1314
  case 91: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1315
  case 92: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1316
  case 93: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1317
  case 94: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1318
  case 95: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1319
  case 96: {
    php_dom_throw_error((PHP_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1320
  case 97: {
    php_dom_throw_error((PHP_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1321
  case 98: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1322
  case 99: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1323
  case 100: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1324
  case 101: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1325
  case 102: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1326
  case 103: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1327
  case 104: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1328
  case 105: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1329
  case 106: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1330
  case 107: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1331
  case 108: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1332
  case 109: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1333
  case 110: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1334
  case 111: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1335
  case 112: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1336
  case 113: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1337
  case 114: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1338
  case 115: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1339
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1340
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1341
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1342
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1343
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1344
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1345
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1346
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1347
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1348
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1349
  case 126: {
    php_libxml_node_free_resource((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1350
  case 127: {
    xmlFreeNode((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1351
  case 128: {
    xmlInitParser();
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1352
  case 129: {
    xmlUnlinkNode((node));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1353
  case 130: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1354
  case 131: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1355
  case 132: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1356
  case 133: {
    zval_unset_isref_p((id));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1357
  case 134: {
    zval_unset_isref_p((return_value));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1358
  case 135: {
    zval_unset_isref_p((rv));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1359
  case 136: {
    zval_unset_isref_p((this_ptr));
    if (((void *)0) ==
        (rv = php_dom_create_object(node, &ret, rv, return_value, intern))) {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
  }
}
/* }}} end dom_document_create_text_node */

/* {{{ proto DOMComment dom_document_create_comment(string data);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-1334481328
Since:
*/
PHP_FUNCTION(dom_document_create_comment) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp;
  int ret, value_len;
  dom_object *intern;
  char *value;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &value,
                                   &value_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  node = xmlNewDocComment(docp, (xmlChar *)value);
  if (!node) {
    RETURN_FALSE;
  }

  DOM_RET_OBJ(rv, node, &ret, intern);
}
/* }}} end dom_document_create_comment */

/* {{{ proto DOMCdataSection dom_document_create_cdatasection(string data);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-D26C0AF8
Since:
*/
PHP_FUNCTION(dom_document_create_cdatasection) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp;
  int ret, value_len;
  dom_object *intern;
  char *value;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &value,
                                   &value_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  node = xmlNewCDataBlock(docp, (xmlChar *)value, value_len);
  if (!node) {
    RETURN_FALSE;
  }

  DOM_RET_OBJ(rv, node, &ret, intern);
}
/* }}} end dom_document_create_cdatasection */

/* {{{ proto DOMProcessingInstruction
dom_document_create_processing_instruction(string target, string data); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-135944439
Since:
*/
PHP_FUNCTION(dom_document_create_processing_instruction) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp;
  int ret, value_len, name_len = 0;
  dom_object *intern;
  char *name, *value = NULL;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os|s",
                                   &id, dom_document_class_entry, &name,
                                   &name_len, &value, &value_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  if (xmlValidateName((xmlChar *)name, 0) != 0) {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document) TSRMLS_CC);
    RETURN_FALSE;
  }

  node = xmlNewPI((xmlChar *)name, (xmlChar *)value);
  if (!node) {
    RETURN_FALSE;
  }

  node->doc = docp;

  DOM_RET_OBJ(rv, node, &ret, intern);
}
/* }}} end dom_document_create_processing_instruction */

/* {{{ proto DOMAttr dom_document_create_attribute(string name);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-1084891198
Since:
*/
PHP_FUNCTION(dom_document_create_attribute) {
  zval *id, *rv = NULL;
  xmlAttrPtr node;
  xmlDocPtr docp;
  int ret, name_len;
  dom_object *intern;
  char *name;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &name,
                                   &name_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  if (xmlValidateName((xmlChar *)name, 0) != 0) {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document) TSRMLS_CC);
    RETURN_FALSE;
  }

  node = xmlNewDocProp(docp, (xmlChar *)name, NULL);
  if (!node) {
    RETURN_FALSE;
  }

  DOM_RET_OBJ(rv, (xmlNodePtr)node, &ret, intern);
}
/* }}} end dom_document_create_attribute */

/* {{{ proto DOMEntityReference dom_document_create_entity_reference(string
name); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-392B75AE
Since:
*/
PHP_FUNCTION(dom_document_create_entity_reference) {
  zval *id, *rv = NULL;
  xmlNode *node;
  xmlDocPtr docp = NULL;
  dom_object *intern;
  int ret, name_len;
  char *name;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &name,
                                   &name_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  if (xmlValidateName((xmlChar *)name, 0) != 0) {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error(intern->document) TSRMLS_CC);
    RETURN_FALSE;
  }

  node = xmlNewReference(docp, name);
  if (!node) {
    RETURN_FALSE;
  }

  DOM_RET_OBJ(rv, (xmlNodePtr)node, &ret, intern);
}
/* }}} end dom_document_create_entity_reference */

/* {{{ proto DOMNodeList dom_document_get_elements_by_tag_name(string tagname);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-A6C9094
Since:
*/
PHP_FUNCTION(dom_document_get_elements_by_tag_name) {
  zval *id;
  xmlDocPtr docp;
  int name_len;
  dom_object *intern, *namednode;
  char *name;
  xmlChar *local;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &name,
                                   &name_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  php_dom_create_interator(return_value, DOM_NODELIST TSRMLS_CC);
  namednode = (dom_object *)zend_objects_get_address(return_value TSRMLS_CC);
  local = xmlCharStrndup(name, name_len);
  dom_namednode_iter(intern, 0, namednode, NULL, local, NULL TSRMLS_CC);
}
/* }}} end dom_document_get_elements_by_tag_name */

/* {{{ proto DOMNode dom_document_import_node(DOMNode importedNode, boolean
deep); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#Core-Document-importNode
Since: DOM Level 2
*/
PHP_FUNCTION(dom_document_import_node) {
  zval *rv = NULL;
  zval *id, *node;
  xmlDocPtr docp;
  xmlNodePtr nodep, retnodep;
  dom_object *intern, *nodeobj;
  int ret;
  long recursive = 0;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "OO|l",
                                   &id, dom_document_class_entry, &node,
                                   dom_node_class_entry,
                                   &recursive) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  DOM_GET_OBJ(nodep, node, xmlNodePtr, nodeobj);

  if (nodep->type == XML_HTML_DOCUMENT_NODE ||
      nodep->type == XML_DOCUMENT_NODE ||
      nodep->type == XML_DOCUMENT_TYPE_NODE) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Cannot import: Node Type Not Supported");
    RETURN_FALSE;
  }

  if (nodep->doc == docp) {
    retnodep = nodep;
  } else {
    if ((recursive == 0) && (nodep->type == XML_ELEMENT_NODE)) {
      recursive = 2;
    }
    retnodep = xmlDocCopyNode(nodep, docp, recursive);
    if (!retnodep) {
      RETURN_FALSE;
    }

    if ((retnodep->type == XML_ATTRIBUTE_NODE) && (nodep->ns != NULL)) {
      xmlNsPtr nsptr = NULL;
      xmlNodePtr root = xmlDocGetRootElement(docp);

      nsptr = xmlSearchNsByHref(nodep->doc, root, nodep->ns->href);
      if (nsptr == NULL) {
        int errorcode;
        nsptr = dom_get_ns(root, (char *)nodep->ns->href, &errorcode,
                           (char *)nodep->ns->prefix);
      }
      xmlSetNs(retnodep, nsptr);
    }
  }

  DOM_RET_OBJ(rv, (xmlNodePtr)retnodep, &ret, intern);
}
/* }}} end dom_document_import_node */

/* {{{ proto DOMElement dom_document_create_element_ns(string namespaceURI,
string qualifiedName [,string value]); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-DocCrElNS
Since: DOM Level 2
*/
PHP_FUNCTION(dom_document_create_element_ns) {
  zval *id, *rv = NULL;
  xmlDocPtr docp;
  xmlNodePtr nodep = NULL;
  xmlNsPtr nsptr = NULL;
  int ret, uri_len = 0, name_len = 0, value_len = 0;
  char *uri, *name, *value = NULL;
  char *localname = NULL, *prefix = NULL;
  int errorcode;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(),
                                   "Os!s|s", &id, dom_document_class_entry,
                                   &uri, &uri_len, &name, &name_len, &value,
                                   &value_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  errorcode = dom_check_qname(name, &localname, &prefix, uri_len, name_len);

  if (errorcode == 0) {
    if (xmlValidateName((xmlChar *)localname, 0) == 0) {
      nodep = xmlNewDocNode(docp, NULL, localname, value);
      if (nodep != NULL && uri != NULL) {
        nsptr = xmlSearchNsByHref(nodep->doc, nodep, uri);
        if (nsptr == NULL) {
          nsptr = dom_get_ns(nodep, uri, &errorcode, prefix);
        }
        xmlSetNs(nodep, nsptr);
      }
    } else {
      errorcode = INVALID_CHARACTER_ERR;
    }
  }

  xmlFree(localname);
  if (prefix != NULL) {
    xmlFree(prefix);
  }

  if (errorcode != 0) {
    if (nodep != NULL) {
      xmlFreeNode(nodep);
    }
    php_dom_throw_error(errorcode,
                        dom_get_strict_error(intern->document) TSRMLS_CC);
    RETURN_FALSE;
  }

  if (nodep == NULL) {
    RETURN_FALSE;
  }

  nodep->ns = nsptr;

  DOM_RET_OBJ(rv, nodep, &ret, intern);
}
/* }}} end dom_document_create_element_ns */

/* {{{ proto DOMAttr dom_document_create_attribute_ns(string namespaceURI,
string qualifiedName); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-DocCrAttrNS
Since: DOM Level 2
*/
PHP_FUNCTION(dom_document_create_attribute_ns) {
  zval *id, *rv = NULL;
  xmlDocPtr docp;
  xmlNodePtr nodep = NULL, root;
  xmlNsPtr nsptr;
  int ret, uri_len = 0, name_len = 0;
  char *uri, *name;
  char *localname = NULL, *prefix = NULL;
  dom_object *intern;
  int errorcode;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os!s",
                                   &id, dom_document_class_entry, &uri,
                                   &uri_len, &name, &name_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  root = xmlDocGetRootElement(docp);
  if (root != NULL) {
    errorcode = dom_check_qname(name, &localname, &prefix, uri_len, name_len);
    if (errorcode == 0) {
      if (xmlValidateName((xmlChar *)localname, 0) == 0) {
        nodep = (xmlNodePtr)xmlNewDocProp(docp, localname, NULL);
        if (nodep != NULL && uri_len > 0) {
          nsptr = xmlSearchNsByHref(nodep->doc, root, uri);
          if (nsptr == NULL) {
            nsptr = dom_get_ns(root, uri, &errorcode, prefix);
          }
          xmlSetNs(nodep, nsptr);
        }
      } else {
        errorcode = INVALID_CHARACTER_ERR;
      }
    }
  } else {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Document Missing Root Element");
    RETURN_FALSE;
  }

  xmlFree(localname);
  if (prefix != NULL) {
    xmlFree(prefix);
  }

  if (errorcode != 0) {
    if (nodep != NULL) {
      xmlFreeProp((xmlAttrPtr)nodep);
    }
    php_dom_throw_error(errorcode,
                        dom_get_strict_error(intern->document) TSRMLS_CC);
    RETURN_FALSE;
  }

  if (nodep == NULL) {
    RETURN_FALSE;
  }

  DOM_RET_OBJ(rv, nodep, &ret, intern);
}
/* }}} end dom_document_create_attribute_ns */

/* {{{ proto DOMNodeList dom_document_get_elements_by_tag_name_ns(string
namespaceURI, string localName); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-getElBTNNS
Since: DOM Level 2
*/
PHP_FUNCTION(dom_document_get_elements_by_tag_name_ns) {
  zval *id;
  xmlDocPtr docp;
  int uri_len, name_len;
  dom_object *intern, *namednode;
  char *uri, *name;
  xmlChar *local, *nsuri;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oss",
                                   &id, dom_document_class_entry, &uri,
                                   &uri_len, &name, &name_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  php_dom_create_interator(return_value, DOM_NODELIST TSRMLS_CC);
  namednode = (dom_object *)zend_objects_get_address(return_value TSRMLS_CC);
  local = xmlCharStrndup(name, name_len);
  nsuri = xmlCharStrndup(uri, uri_len);
  dom_namednode_iter(intern, 0, namednode, NULL, local, nsuri TSRMLS_CC);
}
/* }}} end dom_document_get_elements_by_tag_name_ns */

/* {{{ proto DOMElement dom_document_get_element_by_id(string elementId);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-ID-getElBId
Since: DOM Level 2
*/
PHP_FUNCTION(dom_document_get_element_by_id) {
  zval *id, *rv = NULL;
  xmlDocPtr docp;
  xmlAttrPtr attrp;
  int ret, idname_len;
  dom_object *intern;
  char *idname;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &idname,
                                   &idname_len) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  attrp = xmlGetID(docp, (xmlChar *)idname);

  if (attrp && attrp->parent) {
    DOM_RET_OBJ(rv, (xmlNodePtr)attrp->parent, &ret, intern);
  } else {
    RETVAL_NULL();
  }
}
/* }}} end dom_document_get_element_by_id */

/* {{{ proto DOMNode dom_document_adopt_node(DOMNode source);
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-adoptNode
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_adopt_node) { DOM_NOT_IMPLEMENTED(); }
/* }}} end dom_document_adopt_node */

/* {{{ proto void dom_document_normalize_document();
URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-normalizeDocument
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_normalize_document) {
  zval *id;
  xmlDocPtr docp;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",
                                   &id, dom_document_class_entry) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  dom_normalize((xmlNodePtr)docp TSRMLS_CC);
}
/* }}} end dom_document_normalize_document */

/* {{{ proto DOMNode dom_document_rename_node(node n, string namespaceURI,
string qualifiedName); URL:
http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#core-Document3-renameNode
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_rename_node) { DOM_NOT_IMPLEMENTED(); }
/* }}} end dom_document_rename_node */

/* {{{ proto void DOMDocument::__construct([string version], [string encoding]);
 */
PHP_METHOD(domdocument, __construct) {

  zval *id;
  xmlDoc *docp = NULL, *olddoc;
  dom_object *intern;
  char *encoding, *version = NULL;
  int encoding_len = 0, version_len = 0, refcount;
  zend_error_handling error_handling;

  // prophet generated patch
  switch (__choose("__ID9")) {
  case 0: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#ifdef COMPILE_1360
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1361
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1362
  case 3: {
    (docp) = xmlNewDoc(version);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1363
  case 4: {
    (docp)->_private = ((void *)0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1364
  case 5: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1365
  case 6: {
    (encoding)++;
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1366
  case 7: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1367
  case 8: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1368
  case 9: {
    (intern)->document = ((void *)0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1369
  case 10: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1370
  case 11: {
    (olddoc) = xmlNewDoc(version);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1371
  case 12: {
    (olddoc)->_private = ((void *)0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1372
  case 13: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1373
  case 14: {
    (version)++;
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1374
  case 15: {
    _convert_to_string(((id)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1375
  case 16: {
    _convert_to_string(((return_value)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1376
  case 17: {
    _convert_to_string(((this_ptr)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1377
  case 18: {
    _efree(((id)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1378
  case 19: {
    _efree(((return_value)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1379
  case 20: {
    _efree(((this_ptr)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1380
  case 21: {
    _zval_copy_ctor_func((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1381
  case 22: {
    _zval_copy_ctor_func((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1382
  case 23: {
    _zval_copy_ctor_func((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1383
  case 24: {
    _zval_dtor(((id)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1384
  case 25: {
    _zval_dtor(((return_value)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1385
  case 26: {
    _zval_dtor(((this_ptr)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1386
  case 27: {
    _zval_dtor_func((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1387
  case 28: {
    _zval_dtor_func((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1388
  case 29: {
    _zval_dtor_func((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1389
  case 30: {
    _zval_ptr_dtor((&(id)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1390
  case 31: {
    _zval_ptr_dtor((&(return_value)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1391
  case 32: {
    _zval_ptr_dtor((&(this_ptr)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1392
  case 33: {
    convert_to_boolean((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1393
  case 34: {
    convert_to_boolean((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1394
  case 35: {
    convert_to_boolean((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1395
  case 36: {
    convert_to_long((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1396
  case 37: {
    convert_to_long((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1397
  case 38: {
    convert_to_long((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1398
  case 39: {
    docp = xmlNewDoc((encoding));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1399
  case 40: {
    docp = xmlNewDoc((version));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1400
  case 41: {
    docp = xmlNewDoc(version);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1401
  case 42: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1402
  case 43: {
    exit(1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1403
  case 44: {
    gc_remove_zval_from_buffer((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1404
  case 45: {
    gc_remove_zval_from_buffer((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1405
  case 46: {
    gc_remove_zval_from_buffer((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1406
  case 47: {
    gc_zval_check_possible_root(((id)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1407
  case 48: {
    gc_zval_check_possible_root(((return_value)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1408
  case 49: {
    gc_zval_check_possible_root(((this_ptr)));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1409
  case 50: {
    gc_zval_possible_root((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1410
  case 51: {
    gc_zval_possible_root((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1411
  case 52: {
    gc_zval_possible_root((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1412
  case 53: {
    i_zval_ptr_dtor((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1413
  case 54: {
    i_zval_ptr_dtor((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1414
  case 55: {
    i_zval_ptr_dtor((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1415
  case 56: {
    if (!__is_neg("9-56", 4, (int *){ht, encoding_len, version_len, refcount},
                  0, 0, 10,
                  (void **){dom_domexception_class_entry, this_ptr, id,
                            encoding, version, dom_document_class_entry, docp,
                            return_value, intern, olddoc},
                  0, 0, 14, "dom_domexception_class_entry", "ht", "this_ptr",
                  "id", "encoding", "version", "encoding_len", "version_len",
                  "dom_document_class_entry", "docp", "return_value", "intern",
                  "olddoc", "refcount"))
      zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                  &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1416
  case 57: {
    if (__is_neg("9-57", 4, (int *){ht, encoding_len, version_len, refcount}, 0,
                 0, 10,
                 (void **){dom_domexception_class_entry, this_ptr, id, encoding,
                           version, dom_document_class_entry, docp,
                           return_value, intern, olddoc},
                 0, 0, 14, "dom_domexception_class_entry", "ht", "this_ptr",
                 "id", "encoding", "version", "encoding_len", "version_len",
                 "dom_document_class_entry", "docp", "return_value", "intern",
                 "olddoc", "refcount"))
      return;
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1417
  case 58: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1418
  case 59: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1419
  case 60: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1420
  case 61: {
    intern = (dom_object *)zend_object_store_get_object(id);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1421
  case 62: {
    intern->document = ((void *)0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1422
  case 63: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1423
  case 64: {
    olddoc->_private = ((void *)0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1424
  case 65: {
    php_dom_create_implementation((return_value_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1425
  case 66: {
    php_dom_create_interator((id), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1426
  case 67: {
    php_dom_create_interator((return_value), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1427
  case 68: {
    php_dom_create_interator((this_ptr), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1428
  case 69: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1429
  case 70: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1430
  case 71: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1431
  case 72: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1432
  case 73: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1433
  case 74: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1434
  case 75: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1435
  case 76: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1436
  case 77: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1437
  case 78: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1438
  case 79: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1439
  case 80: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1440
  case 81: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1441
  case 82: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1442
  case 83: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1443
  case 84: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1444
  case 85: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1445
  case 86: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1446
  case 87: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1447
  case 88: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1448
  case 89: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1449
  case 90: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1450
  case 91: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1451
  case 92: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1452
  case 93: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1453
  case 94: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1454
  case 95: {
    php_dom_throw_error((PHP_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1455
  case 96: {
    php_dom_throw_error((PHP_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1456
  case 97: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1457
  case 98: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1458
  case 99: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1459
  case 100: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1460
  case 101: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1461
  case 102: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1462
  case 103: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1463
  case 104: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1464
  case 105: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1465
  case 106: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1466
  case 107: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1467
  case 108: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1468
  case 109: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1469
  case 110: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1470
  case 111: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1471
  case 112: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1472
  case 113: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1473
  case 114: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1474
  case 115: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1475
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1476
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1477
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1478
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1479
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1480
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1481
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1482
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1483
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1484
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1485
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1486
  case 127: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1487
  case 128: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1488
  case 129: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1489
  case 130: {
    xmlInitParser();
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1490
  case 131: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1491
  case 132: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1492
  case 133: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1493
  case 134: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1494
  case 135: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1495
  case 136: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1496
  case 137: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1497
  case 138: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1498
  case 139: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1499
  case 140: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1500
  case 141: {
    zend_restore_error_handling(&error_handling);
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1501
  case 142: {
    zval_unset_isref_p((id));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1502
  case 143: {
    zval_unset_isref_p((return_value));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
#ifdef COMPILE_1503
  case 144: {
    zval_unset_isref_p((this_ptr));
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);

    break;
  }
#endif
  }
  // prophet generated patch
  switch (__choose("__ID10")) {
  case 0: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#ifdef COMPILE_1504
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1505
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1506
  case 3: {
    (docp) = xmlNewDoc(version);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1507
  case 4: {
    (docp)->_private = ((void *)0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1508
  case 5: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1509
  case 6: {
    (encoding)++;
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1510
  case 7: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1511
  case 8: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1512
  case 9: {
    (intern)->document = ((void *)0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1513
  case 10: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1514
  case 11: {
    (olddoc) = xmlNewDoc(version);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1515
  case 12: {
    (olddoc)->_private = ((void *)0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1516
  case 13: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1517
  case 14: {
    (version)++;
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1518
  case 15: {
    _convert_to_string(((id)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1519
  case 16: {
    _convert_to_string(((return_value)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1520
  case 17: {
    _convert_to_string(((this_ptr)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1521
  case 18: {
    _efree(((id)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1522
  case 19: {
    _efree(((return_value)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1523
  case 20: {
    _efree(((this_ptr)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1524
  case 21: {
    _zval_copy_ctor_func((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1525
  case 22: {
    _zval_copy_ctor_func((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1526
  case 23: {
    _zval_copy_ctor_func((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1527
  case 24: {
    _zval_dtor(((id)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1528
  case 25: {
    _zval_dtor(((return_value)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1529
  case 26: {
    _zval_dtor(((this_ptr)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1530
  case 27: {
    _zval_dtor_func((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1531
  case 28: {
    _zval_dtor_func((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1532
  case 29: {
    _zval_dtor_func((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1533
  case 30: {
    _zval_ptr_dtor((&(id)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1534
  case 31: {
    _zval_ptr_dtor((&(return_value)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1535
  case 32: {
    _zval_ptr_dtor((&(this_ptr)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1536
  case 33: {
    convert_to_boolean((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1537
  case 34: {
    convert_to_boolean((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1538
  case 35: {
    convert_to_boolean((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1539
  case 36: {
    convert_to_long((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1540
  case 37: {
    convert_to_long((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1541
  case 38: {
    convert_to_long((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1542
  case 39: {
    docp = xmlNewDoc((encoding));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1543
  case 40: {
    docp = xmlNewDoc((version));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1544
  case 41: {
    docp = xmlNewDoc(version);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1545
  case 42: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1546
  case 43: {
    exit(1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1547
  case 44: {
    gc_remove_zval_from_buffer((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1548
  case 45: {
    gc_remove_zval_from_buffer((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1549
  case 46: {
    gc_remove_zval_from_buffer((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1550
  case 47: {
    gc_zval_check_possible_root(((id)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1551
  case 48: {
    gc_zval_check_possible_root(((return_value)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1552
  case 49: {
    gc_zval_check_possible_root(((this_ptr)));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1553
  case 50: {
    gc_zval_possible_root((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1554
  case 51: {
    gc_zval_possible_root((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1555
  case 52: {
    gc_zval_possible_root((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1556
  case 53: {
    i_zval_ptr_dtor((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1557
  case 54: {
    i_zval_ptr_dtor((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1558
  case 55: {
    i_zval_ptr_dtor((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1559
  case 56: {
    if (!__is_neg("10-56", 4, (int *){ht, encoding_len, version_len, refcount},
                  0, 0, 10,
                  (void **){this_ptr, id, encoding, version,
                            dom_document_class_entry,
                            dom_domexception_class_entry, docp, return_value,
                            intern, olddoc},
                  0, 0, 14, "ht", "this_ptr", "id", "encoding", "version",
                  "encoding_len", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry", "docp", "return_value",
                  "intern", "olddoc", "refcount") &&
        (zend_parse_method_parameters(
             (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
             &version_len, &encoding, &encoding_len) == -1)) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1560
  case 57: {
    if (!__is_neg("10-57", 4, (int *){ht, encoding_len, version_len, refcount},
                  0, 0, 10,
                  (void **){this_ptr, id, encoding, version,
                            dom_document_class_entry,
                            dom_domexception_class_entry, docp, return_value,
                            intern, olddoc},
                  0, 0, 14, "ht", "this_ptr", "id", "encoding", "version",
                  "encoding_len", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry", "docp", "return_value",
                  "intern", "olddoc", "refcount"))
      if (zend_parse_method_parameters(
              (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
              &version_len, &encoding, &encoding_len) == -1) {
        zend_restore_error_handling(&error_handling);
        return;
      }

    break;
  }
#endif
#ifdef COMPILE_1561
  case 58: {
    if ((zend_parse_method_parameters(
             (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
             &version_len, &encoding, &encoding_len) == -1) &&
        !__is_neg("10-58", 4, (int *){ht, encoding_len, version_len, refcount},
                  0, 0, 10,
                  (void **){this_ptr, id, encoding, version,
                            dom_document_class_entry,
                            dom_domexception_class_entry, docp, return_value,
                            intern, olddoc},
                  0, 0, 14, "ht", "this_ptr", "id", "encoding", "version",
                  "encoding_len", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry", "docp", "return_value",
                  "intern", "olddoc", "refcount")) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1562
  case 59: {
    if ((zend_parse_method_parameters(
             (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
             &version_len, &encoding, &encoding_len) == -1) ||
        __is_neg("10-59", 4, (int *){ht, encoding_len, version_len, refcount},
                 0, 0, 10,
                 (void **){this_ptr, id, encoding, version,
                           dom_document_class_entry,
                           dom_domexception_class_entry, docp, return_value,
                           intern, olddoc},
                 0, 0, 14, "ht", "this_ptr", "id", "encoding", "version",
                 "encoding_len", "version_len", "dom_document_class_entry",
                 "dom_domexception_class_entry", "docp", "return_value",
                 "intern", "olddoc", "refcount")) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1563
  case 60: {
    if (__is_neg("10-60", 4, (int *){ht, encoding_len, version_len, refcount},
                 0, 0, 10,
                 (void **){this_ptr, id, encoding, version,
                           dom_document_class_entry,
                           dom_domexception_class_entry, docp, return_value,
                           intern, olddoc},
                 0, 0, 14, "ht", "this_ptr", "id", "encoding", "version",
                 "encoding_len", "version_len", "dom_document_class_entry",
                 "dom_domexception_class_entry", "docp", "return_value",
                 "intern", "olddoc", "refcount"))
      return;
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1564
  case 61: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1565
  case 62: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1566
  case 63: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1567
  case 64: {
    intern = (dom_object *)zend_object_store_get_object(id);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1568
  case 65: {
    intern->document = ((void *)0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1569
  case 66: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1570
  case 67: {
    olddoc->_private = ((void *)0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1571
  case 68: {
    php_dom_create_implementation((return_value_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1572
  case 69: {
    php_dom_create_interator((id), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1573
  case 70: {
    php_dom_create_interator((return_value), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1574
  case 71: {
    php_dom_create_interator((this_ptr), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1575
  case 72: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1576
  case 73: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1577
  case 74: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1578
  case 75: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1579
  case 76: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1580
  case 77: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1581
  case 78: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1582
  case 79: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1583
  case 80: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1584
  case 81: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1585
  case 82: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1586
  case 83: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1587
  case 84: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1588
  case 85: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1589
  case 86: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1590
  case 87: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1591
  case 88: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1592
  case 89: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1593
  case 90: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1594
  case 91: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1595
  case 92: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1596
  case 93: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1597
  case 94: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1598
  case 95: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1599
  case 96: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1600
  case 97: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1601
  case 98: {
    php_dom_throw_error((PHP_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1602
  case 99: {
    php_dom_throw_error((PHP_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1603
  case 100: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1604
  case 101: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1605
  case 102: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1606
  case 103: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1607
  case 104: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1608
  case 105: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1609
  case 106: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1610
  case 107: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1611
  case 108: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1612
  case 109: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1613
  case 110: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1614
  case 111: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1615
  case 112: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1616
  case 113: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1617
  case 114: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1618
  case 115: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1619
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1620
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1621
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1622
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1623
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1624
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1625
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1626
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1627
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1628
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1629
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1630
  case 127: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1631
  case 128: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1632
  case 129: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1633
  case 130: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1634
  case 131: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1635
  case 132: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1636
  case 133: {
    xmlInitParser();
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1637
  case 134: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1638
  case 135: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1639
  case 136: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1640
  case 137: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1641
  case 138: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1642
  case 139: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1643
  case 140: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1644
  case 141: {
    zend_restore_error_handling(&error_handling);
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1645
  case 142: {
    zval_unset_isref_p((id));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1646
  case 143: {
    zval_unset_isref_p((return_value));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_1647
  case 144: {
    zval_unset_isref_p((this_ptr));
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID11")) {
  case 0: {
    zend_restore_error_handling(&error_handling);

    break;
  }
#ifdef COMPILE_1648
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1649
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1650
  case 3: {
    (docp) = xmlNewDoc(version);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1651
  case 4: {
    (docp)->_private = ((void *)0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1652
  case 5: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1653
  case 6: {
    (encoding)++;
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1654
  case 7: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1655
  case 8: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1656
  case 9: {
    (intern)->document = ((void *)0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1657
  case 10: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1658
  case 11: {
    (olddoc) = xmlNewDoc(version);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1659
  case 12: {
    (olddoc)->_private = ((void *)0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1660
  case 13: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1661
  case 14: {
    (version)++;
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1662
  case 15: {
    _convert_to_string(((id)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1663
  case 16: {
    _convert_to_string(((return_value)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1664
  case 17: {
    _convert_to_string(((this_ptr)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1665
  case 18: {
    _efree(((id)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1666
  case 19: {
    _efree(((return_value)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1667
  case 20: {
    _efree(((this_ptr)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1668
  case 21: {
    _zval_copy_ctor_func((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1669
  case 22: {
    _zval_copy_ctor_func((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1670
  case 23: {
    _zval_copy_ctor_func((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1671
  case 24: {
    _zval_dtor(((id)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1672
  case 25: {
    _zval_dtor(((return_value)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1673
  case 26: {
    _zval_dtor(((this_ptr)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1674
  case 27: {
    _zval_dtor_func((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1675
  case 28: {
    _zval_dtor_func((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1676
  case 29: {
    _zval_dtor_func((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1677
  case 30: {
    _zval_ptr_dtor((&(id)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1678
  case 31: {
    _zval_ptr_dtor((&(return_value)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1679
  case 32: {
    _zval_ptr_dtor((&(this_ptr)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1680
  case 33: {
    convert_to_boolean((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1681
  case 34: {
    convert_to_boolean((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1682
  case 35: {
    convert_to_boolean((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1683
  case 36: {
    convert_to_long((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1684
  case 37: {
    convert_to_long((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1685
  case 38: {
    convert_to_long((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1686
  case 39: {
    docp = xmlNewDoc((encoding));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1687
  case 40: {
    docp = xmlNewDoc((version));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1688
  case 41: {
    docp = xmlNewDoc(version);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1689
  case 42: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1690
  case 43: {
    exit(1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1691
  case 44: {
    gc_remove_zval_from_buffer((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1692
  case 45: {
    gc_remove_zval_from_buffer((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1693
  case 46: {
    gc_remove_zval_from_buffer((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1694
  case 47: {
    gc_zval_check_possible_root(((id)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1695
  case 48: {
    gc_zval_check_possible_root(((return_value)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1696
  case 49: {
    gc_zval_check_possible_root(((this_ptr)));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1697
  case 50: {
    gc_zval_possible_root((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1698
  case 51: {
    gc_zval_possible_root((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1699
  case 52: {
    gc_zval_possible_root((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1700
  case 53: {
    i_zval_ptr_dtor((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1701
  case 54: {
    i_zval_ptr_dtor((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1702
  case 55: {
    i_zval_ptr_dtor((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1703
  case 56: {
    if (!__is_neg("11-56", 4, (int *){ht, encoding_len, version_len, refcount},
                  0, 0, 10,
                  (void **){docp, version, return_value, this_ptr, id, encoding,
                            dom_document_class_entry,
                            dom_domexception_class_entry, intern, olddoc},
                  0, 0, 14, "docp", "version", "ht", "return_value", "this_ptr",
                  "id", "encoding", "encoding_len", "version_len",
                  "dom_document_class_entry", "dom_domexception_class_entry",
                  "intern", "olddoc", "refcount"))
      zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1704
  case 57: {
    if (__is_neg("11-57", 4, (int *){ht, encoding_len, version_len, refcount},
                 0, 0, 10,
                 (void **){docp, version, return_value, this_ptr, id, encoding,
                           dom_document_class_entry,
                           dom_domexception_class_entry, intern, olddoc},
                 0, 0, 14, "docp", "version", "ht", "return_value", "this_ptr",
                 "id", "encoding", "encoding_len", "version_len",
                 "dom_document_class_entry", "dom_domexception_class_entry",
                 "intern", "olddoc", "refcount"))
      return;
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1705
  case 58: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1706
  case 59: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1707
  case 60: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1708
  case 61: {
    intern = (dom_object *)zend_object_store_get_object(id);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1709
  case 62: {
    intern->document = ((void *)0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1710
  case 63: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1711
  case 64: {
    olddoc->_private = ((void *)0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1712
  case 65: {
    php_dom_create_implementation((return_value_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1713
  case 66: {
    php_dom_create_interator((id), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1714
  case 67: {
    php_dom_create_interator((return_value), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1715
  case 68: {
    php_dom_create_interator((this_ptr), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1716
  case 69: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1717
  case 70: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1718
  case 71: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1719
  case 72: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1720
  case 73: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1721
  case 74: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1722
  case 75: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1723
  case 76: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1724
  case 77: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1725
  case 78: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1726
  case 79: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1727
  case 80: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1728
  case 81: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1729
  case 82: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1730
  case 83: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1731
  case 84: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1732
  case 85: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1733
  case 86: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1734
  case 87: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1735
  case 88: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1736
  case 89: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1737
  case 90: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1738
  case 91: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1739
  case 92: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1740
  case 93: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1741
  case 94: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1742
  case 95: {
    php_dom_throw_error((PHP_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1743
  case 96: {
    php_dom_throw_error((PHP_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1744
  case 97: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1745
  case 98: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1746
  case 99: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1747
  case 100: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1748
  case 101: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1749
  case 102: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1750
  case 103: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1751
  case 104: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1752
  case 105: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1753
  case 106: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1754
  case 107: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1755
  case 108: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1756
  case 109: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1757
  case 110: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1758
  case 111: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1759
  case 112: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1760
  case 113: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1761
  case 114: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1762
  case 115: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1763
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1764
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1765
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1766
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1767
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1768
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1769
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1770
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1771
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1772
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1773
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1774
  case 127: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1775
  case 128: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1776
  case 129: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1777
  case 130: {
    xmlInitParser();
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1778
  case 131: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1779
  case 132: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1780
  case 133: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1781
  case 134: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1782
  case 135: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1783
  case 136: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1784
  case 137: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1785
  case 138: {
    zend_restore_error_handling(&error_handling);
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1786
  case 139: {
    zend_save_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1787
  case 140: {
    zval_unset_isref_p((id));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1788
  case 141: {
    zval_unset_isref_p((return_value));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
#ifdef COMPILE_1789
  case 142: {
    zval_unset_isref_p((this_ptr));
    zend_restore_error_handling(&error_handling);

    break;
  }
#endif
  }
  // prophet generated patch
  switch (__choose("__ID12")) {
  case 0: {
    docp = xmlNewDoc(version);

    break;
  }
#ifdef COMPILE_1790
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1791
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1792
  case 3: {
    (docp) = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1793
  case 4: {
    (docp) = xmlNewDoc(version);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1794
  case 5: {
    (docp)->_private = ((void *)0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1795
  case 6: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1796
  case 7: {
    (encoding)++;
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1797
  case 8: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1798
  case 9: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1799
  case 10: {
    (intern)->document = ((void *)0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1800
  case 11: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1801
  case 12: {
    (olddoc) = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1802
  case 13: {
    (olddoc) = xmlNewDoc(version);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1803
  case 14: {
    (olddoc)->_private = ((void *)0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1804
  case 15: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1805
  case 16: {
    (version)++;
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1806
  case 17: {
    _convert_to_string(((id)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1807
  case 18: {
    _convert_to_string(((return_value)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1808
  case 19: {
    _convert_to_string(((this_ptr)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1809
  case 20: {
    _efree(((id)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1810
  case 21: {
    _efree(((return_value)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1811
  case 22: {
    _efree(((this_ptr)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1812
  case 23: {
    _zval_copy_ctor_func((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1813
  case 24: {
    _zval_copy_ctor_func((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1814
  case 25: {
    _zval_copy_ctor_func((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1815
  case 26: {
    _zval_dtor(((id)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1816
  case 27: {
    _zval_dtor(((return_value)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1817
  case 28: {
    _zval_dtor(((this_ptr)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1818
  case 29: {
    _zval_dtor_func((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1819
  case 30: {
    _zval_dtor_func((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1820
  case 31: {
    _zval_dtor_func((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1821
  case 32: {
    _zval_ptr_dtor((&(id)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1822
  case 33: {
    _zval_ptr_dtor((&(return_value)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1823
  case 34: {
    _zval_ptr_dtor((&(this_ptr)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1824
  case 35: {
    convert_to_boolean((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1825
  case 36: {
    convert_to_boolean((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1826
  case 37: {
    convert_to_boolean((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1827
  case 38: {
    convert_to_long((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1828
  case 39: {
    convert_to_long((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1829
  case 40: {
    convert_to_long((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1830
  case 41: {
    docp = xmlNewDoc((encoding));

    break;
  }
#endif
#ifdef COMPILE_1831
  case 42: {
    docp = xmlNewDoc((encoding));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1832
  case 43: {
    docp = xmlNewDoc((version));

    break;
  }
#endif
#ifdef COMPILE_1833
  case 44: {
    docp = xmlNewDoc((version));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1834
  case 45: {
    docp = xmlNewDoc(version);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1835
  case 46: {
    docp = xmlParseDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1836
  case 47: {
    docp = xmlRecoverDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1837
  case 48: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1838
  case 49: {
    exit(1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1839
  case 50: {
    gc_remove_zval_from_buffer((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1840
  case 51: {
    gc_remove_zval_from_buffer((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1841
  case 52: {
    gc_remove_zval_from_buffer((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1842
  case 53: {
    gc_zval_check_possible_root(((id)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1843
  case 54: {
    gc_zval_check_possible_root(((return_value)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1844
  case 55: {
    gc_zval_check_possible_root(((this_ptr)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1845
  case 56: {
    gc_zval_possible_root((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1846
  case 57: {
    gc_zval_possible_root((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1847
  case 58: {
    gc_zval_possible_root((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1848
  case 59: {
    i_zval_ptr_dtor((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1849
  case 60: {
    i_zval_ptr_dtor((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1850
  case 61: {
    i_zval_ptr_dtor((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1851
  case 62: {
    if (!__is_neg("12-62", 4, (int *){ht, encoding_len, version_len, refcount},
                  0, 0, 10,
                  (void **){docp, version, return_value, this_ptr, id, encoding,
                            dom_document_class_entry,
                            dom_domexception_class_entry, intern, olddoc},
                  0, 0, 14, "docp", "version", "return_value", "ht", "this_ptr",
                  "id", "encoding", "encoding_len", "version_len",
                  "dom_document_class_entry", "dom_domexception_class_entry",
                  "intern", "olddoc", "refcount"))
      docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1852
  case 63: {
    if (__is_neg("12-63", 4, (int *){ht, encoding_len, version_len, refcount},
                 0, 0, 10,
                 (void **){docp, version, return_value, this_ptr, id, encoding,
                           dom_document_class_entry,
                           dom_domexception_class_entry, intern, olddoc},
                 0, 0, 14, "docp", "version", "return_value", "ht", "this_ptr",
                 "id", "encoding", "encoding_len", "version_len",
                 "dom_document_class_entry", "dom_domexception_class_entry",
                 "intern", "olddoc", "refcount"))
      return;
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1853
  case 64: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1854
  case 65: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1855
  case 66: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1856
  case 67: {
    intern = (dom_object *)zend_object_store_get_object(id);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1857
  case 68: {
    intern->document = ((void *)0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1858
  case 69: {
    memset(docp, 0, sizeof(*(docp)));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1859
  case 70: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1860
  case 71: {
    olddoc->_private = ((void *)0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1861
  case 72: {
    php_dom_create_implementation((return_value_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1862
  case 73: {
    php_dom_create_interator((id), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1863
  case 74: {
    php_dom_create_interator((return_value), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1864
  case 75: {
    php_dom_create_interator((this_ptr), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1865
  case 76: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1866
  case 77: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1867
  case 78: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1868
  case 79: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1869
  case 80: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1870
  case 81: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1871
  case 82: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1872
  case 83: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1873
  case 84: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1874
  case 85: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1875
  case 86: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1876
  case 87: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1877
  case 88: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1878
  case 89: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1879
  case 90: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1880
  case 91: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1881
  case 92: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1882
  case 93: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1883
  case 94: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1884
  case 95: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1885
  case 96: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1886
  case 97: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1887
  case 98: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1888
  case 99: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1889
  case 100: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1890
  case 101: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1891
  case 102: {
    php_dom_throw_error((PHP_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1892
  case 103: {
    php_dom_throw_error((PHP_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1893
  case 104: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1894
  case 105: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1895
  case 106: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1896
  case 107: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1897
  case 108: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1898
  case 109: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1899
  case 110: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1900
  case 111: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1901
  case 112: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1902
  case 113: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1903
  case 114: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1904
  case 115: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1905
  case 116: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1906
  case 117: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1907
  case 118: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1908
  case 119: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1909
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1910
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1911
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1912
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1913
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1914
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1915
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1916
  case 127: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1917
  case 128: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1918
  case 129: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1919
  case 130: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1920
  case 131: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1921
  case 132: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1922
  case 133: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1923
  case 134: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1924
  case 135: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1925
  case 136: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1926
  case 137: {
    xmlInitParser();
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1927
  case 138: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1928
  case 139: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1929
  case 140: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1930
  case 141: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1931
  case 142: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1932
  case 143: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1933
  case 144: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1934
  case 145: {
    zend_restore_error_handling(&error_handling);
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1935
  case 146: {
    zval_unset_isref_p((id));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1936
  case 147: {
    zval_unset_isref_p((return_value));
    docp = xmlNewDoc(version);

    break;
  }
#endif
#ifdef COMPILE_1937
  case 148: {
    zval_unset_isref_p((this_ptr));
    docp = xmlNewDoc(version);

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID13")) {
  case 0: {
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#ifdef COMPILE_1938
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1939
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1940
  case 3: {
    (docp) = xmlNewDoc(version);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1941
  case 4: {
    (docp)->_private = ((void *)0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1942
  case 5: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1943
  case 6: {
    (encoding)++;
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1944
  case 7: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1945
  case 8: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1946
  case 9: {
    (intern)->document = ((void *)0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1947
  case 10: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1948
  case 11: {
    (olddoc) = xmlNewDoc(version);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1949
  case 12: {
    (olddoc)->_private = ((void *)0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1950
  case 13: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1951
  case 14: {
    (version)++;
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1952
  case 15: {
    _convert_to_string(((id)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1953
  case 16: {
    _convert_to_string(((return_value)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1954
  case 17: {
    _convert_to_string(((this_ptr)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1955
  case 18: {
    _efree(((id)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1956
  case 19: {
    _efree(((return_value)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1957
  case 20: {
    _efree(((this_ptr)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1958
  case 21: {
    _zval_copy_ctor_func((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1959
  case 22: {
    _zval_copy_ctor_func((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1960
  case 23: {
    _zval_copy_ctor_func((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1961
  case 24: {
    _zval_dtor(((id)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1962
  case 25: {
    _zval_dtor(((return_value)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1963
  case 26: {
    _zval_dtor(((this_ptr)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1964
  case 27: {
    _zval_dtor_func((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1965
  case 28: {
    _zval_dtor_func((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1966
  case 29: {
    _zval_dtor_func((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1967
  case 30: {
    _zval_ptr_dtor((&(id)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1968
  case 31: {
    _zval_ptr_dtor((&(return_value)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1969
  case 32: {
    _zval_ptr_dtor((&(this_ptr)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1970
  case 33: {
    convert_to_boolean((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1971
  case 34: {
    convert_to_boolean((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1972
  case 35: {
    convert_to_boolean((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1973
  case 36: {
    convert_to_long((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1974
  case 37: {
    convert_to_long((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1975
  case 38: {
    convert_to_long((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1976
  case 39: {
    docp = xmlNewDoc((encoding));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1977
  case 40: {
    docp = xmlNewDoc((version));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1978
  case 41: {
    docp = xmlNewDoc(version);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1979
  case 42: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1980
  case 43: {
    exit(1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1981
  case 44: {
    gc_remove_zval_from_buffer((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1982
  case 45: {
    gc_remove_zval_from_buffer((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1983
  case 46: {
    gc_remove_zval_from_buffer((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1984
  case 47: {
    gc_zval_check_possible_root(((id)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1985
  case 48: {
    gc_zval_check_possible_root(((return_value)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1986
  case 49: {
    gc_zval_check_possible_root(((this_ptr)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1987
  case 50: {
    gc_zval_possible_root((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1988
  case 51: {
    gc_zval_possible_root((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1989
  case 52: {
    gc_zval_possible_root((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1990
  case 53: {
    i_zval_ptr_dtor((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1991
  case 54: {
    i_zval_ptr_dtor((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1992
  case 55: {
    i_zval_ptr_dtor((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1993
  case 56: {
    if (!__is_neg("13-56", 4, (int *){encoding_len, ht, version_len, refcount},
                  0, 0, 10,
                  (void **){docp, return_value, version, encoding, this_ptr, id,
                            dom_document_class_entry, intern,
                            dom_domexception_class_entry, olddoc},
                  0, 0, 14, "docp", "return_value", "version", "encoding_len",
                  "encoding", "ht", "this_ptr", "id", "version_len",
                  "dom_document_class_entry", "intern",
                  "dom_domexception_class_entry", "olddoc", "refcount") &&
        (!docp)) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1994
  case 57: {
    if (!__is_neg("13-57", 4, (int *){encoding_len, ht, version_len, refcount},
                  0, 0, 10,
                  (void **){docp, return_value, version, encoding, this_ptr, id,
                            dom_document_class_entry, intern,
                            dom_domexception_class_entry, olddoc},
                  0, 0, 14, "docp", "return_value", "version", "encoding_len",
                  "encoding", "ht", "this_ptr", "id", "version_len",
                  "dom_document_class_entry", "intern",
                  "dom_domexception_class_entry", "olddoc", "refcount"))
      if (!docp) {
        php_dom_throw_error(INVALID_STATE_ERR, 1);
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

    break;
  }
#endif
#ifdef COMPILE_1995
  case 58: {
    if ((!docp) &&
        !__is_neg("13-58", 4, (int *){encoding_len, ht, version_len, refcount},
                  0, 0, 10,
                  (void **){docp, return_value, version, encoding, this_ptr, id,
                            dom_document_class_entry, intern,
                            dom_domexception_class_entry, olddoc},
                  0, 0, 14, "docp", "return_value", "version", "encoding_len",
                  "encoding", "ht", "this_ptr", "id", "version_len",
                  "dom_document_class_entry", "intern",
                  "dom_domexception_class_entry", "olddoc", "refcount")) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1996
  case 59: {
    if ((!docp) ||
        __is_neg("13-59", 4, (int *){encoding_len, ht, version_len, refcount},
                 0, 0, 10,
                 (void **){docp, return_value, version, encoding, this_ptr, id,
                           dom_document_class_entry, intern,
                           dom_domexception_class_entry, olddoc},
                 0, 0, 14, "docp", "return_value", "version", "encoding_len",
                 "encoding", "ht", "this_ptr", "id", "version_len",
                 "dom_document_class_entry", "intern",
                 "dom_domexception_class_entry", "olddoc", "refcount")) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1997
  case 60: {
    if (__is_neg("13-60", 4, (int *){encoding_len, ht, version_len, refcount},
                 0, 0, 10,
                 (void **){docp, return_value, version, encoding, this_ptr, id,
                           dom_document_class_entry, intern,
                           dom_domexception_class_entry, olddoc},
                 0, 0, 14, "docp", "return_value", "version", "encoding_len",
                 "encoding", "ht", "this_ptr", "id", "version_len",
                 "dom_document_class_entry", "intern",
                 "dom_domexception_class_entry", "olddoc", "refcount"))
      return;
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1998
  case 61: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_1999
  case 62: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2000
  case 63: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2001
  case 64: {
    intern = (dom_object *)zend_object_store_get_object(id);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2002
  case 65: {
    intern->document = ((void *)0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2003
  case 66: {
    memset(docp, 0, sizeof(*(docp)));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2004
  case 67: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2005
  case 68: {
    olddoc->_private = ((void *)0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2006
  case 69: {
    php_dom_create_implementation((return_value_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2007
  case 70: {
    php_dom_create_interator((id), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2008
  case 71: {
    php_dom_create_interator((return_value), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2009
  case 72: {
    php_dom_create_interator((this_ptr), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2010
  case 73: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2011
  case 74: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2012
  case 75: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2013
  case 76: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2014
  case 77: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2015
  case 78: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2016
  case 79: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2017
  case 80: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2018
  case 81: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2019
  case 82: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2020
  case 83: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2021
  case 84: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2022
  case 85: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2023
  case 86: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2024
  case 87: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2025
  case 88: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2026
  case 89: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2027
  case 90: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2028
  case 91: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2029
  case 92: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2030
  case 93: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2031
  case 94: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2032
  case 95: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2033
  case 96: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2034
  case 97: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2035
  case 98: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2036
  case 99: {
    php_dom_throw_error((PHP_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2037
  case 100: {
    php_dom_throw_error((PHP_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2038
  case 101: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2039
  case 102: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2040
  case 103: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2041
  case 104: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2042
  case 105: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2043
  case 106: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2044
  case 107: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2045
  case 108: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2046
  case 109: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2047
  case 110: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2048
  case 111: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2049
  case 112: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2050
  case 113: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2051
  case 114: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2052
  case 115: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2053
  case 116: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2054
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2055
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2056
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2057
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2058
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2059
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2060
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2061
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2062
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2063
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2064
  case 127: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2065
  case 128: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2066
  case 129: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2067
  case 130: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2068
  case 131: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2069
  case 132: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2070
  case 133: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2071
  case 134: {
    xmlInitParser();
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2072
  case 135: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2073
  case 136: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2074
  case 137: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2075
  case 138: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2076
  case 139: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2077
  case 140: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2078
  case 141: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2079
  case 142: {
    zend_restore_error_handling(&error_handling);
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2080
  case 143: {
    zval_unset_isref_p((id));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2081
  case 144: {
    zval_unset_isref_p((return_value));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
#ifdef COMPILE_2082
  case 145: {
    zval_unset_isref_p((this_ptr));
    if (!docp) {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID14")) {
  case 0: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#ifdef COMPILE_2083
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2084
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2085
  case 3: {
    (docp) = xmlNewDoc(version);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2086
  case 4: {
    (docp)->_private = ((void *)0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2087
  case 5: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2088
  case 6: {
    (encoding)++;
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2089
  case 7: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2090
  case 8: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2091
  case 9: {
    (intern)->document = ((void *)0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2092
  case 10: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2093
  case 11: {
    (olddoc) = xmlNewDoc(version);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2094
  case 12: {
    (olddoc)->_private = ((void *)0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2095
  case 13: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2096
  case 14: {
    (version)++;
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2097
  case 15: {
    _convert_to_string(((id)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2098
  case 16: {
    _convert_to_string(((return_value)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2099
  case 17: {
    _convert_to_string(((this_ptr)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2100
  case 18: {
    _efree(((id)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2101
  case 19: {
    _efree(((return_value)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2102
  case 20: {
    _efree(((this_ptr)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2103
  case 21: {
    _zval_copy_ctor_func((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2104
  case 22: {
    _zval_copy_ctor_func((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2105
  case 23: {
    _zval_copy_ctor_func((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2106
  case 24: {
    _zval_dtor(((id)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2107
  case 25: {
    _zval_dtor(((return_value)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2108
  case 26: {
    _zval_dtor(((this_ptr)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2109
  case 27: {
    _zval_dtor_func((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2110
  case 28: {
    _zval_dtor_func((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2111
  case 29: {
    _zval_dtor_func((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2112
  case 30: {
    _zval_ptr_dtor((&(id)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2113
  case 31: {
    _zval_ptr_dtor((&(return_value)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2114
  case 32: {
    _zval_ptr_dtor((&(this_ptr)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2115
  case 33: {
    convert_to_boolean((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2116
  case 34: {
    convert_to_boolean((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2117
  case 35: {
    convert_to_boolean((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2118
  case 36: {
    convert_to_long((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2119
  case 37: {
    convert_to_long((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2120
  case 38: {
    convert_to_long((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2121
  case 39: {
    docp = xmlNewDoc((encoding));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2122
  case 40: {
    docp = xmlNewDoc((version));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2123
  case 41: {
    docp = xmlNewDoc(version);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2124
  case 42: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2125
  case 43: {
    exit(1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2126
  case 44: {
    gc_remove_zval_from_buffer((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2127
  case 45: {
    gc_remove_zval_from_buffer((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2128
  case 46: {
    gc_remove_zval_from_buffer((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2129
  case 47: {
    gc_zval_check_possible_root(((id)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2130
  case 48: {
    gc_zval_check_possible_root(((return_value)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2131
  case 49: {
    gc_zval_check_possible_root(((this_ptr)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2132
  case 50: {
    gc_zval_possible_root((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2133
  case 51: {
    gc_zval_possible_root((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2134
  case 52: {
    gc_zval_possible_root((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2135
  case 53: {
    i_zval_ptr_dtor((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2136
  case 54: {
    i_zval_ptr_dtor((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2137
  case 55: {
    i_zval_ptr_dtor((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2138
  case 56: {
    if (!__is_neg("14-56", 4, (int *){encoding_len, refcount, ht, version_len},
                  0, 0, 10,
                  (void **){docp, encoding, return_value, id, intern, olddoc,
                            version, this_ptr, dom_document_class_entry,
                            dom_domexception_class_entry},
                  0, 0, 14, "encoding_len", "docp", "encoding", "return_value",
                  "id", "intern", "olddoc", "version", "refcount", "ht",
                  "this_ptr", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry") &&
        (encoding_len > 0)) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2139
  case 57: {
    if (!__is_neg("14-57", 4, (int *){encoding_len, refcount, ht, version_len},
                  0, 0, 10,
                  (void **){docp, encoding, return_value, id, intern, olddoc,
                            version, this_ptr, dom_document_class_entry,
                            dom_domexception_class_entry},
                  0, 0, 14, "encoding_len", "docp", "encoding", "return_value",
                  "id", "intern", "olddoc", "version", "refcount", "ht",
                  "this_ptr", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry"))
      if (encoding_len > 0) {
        docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      }

    break;
  }
#endif
#ifdef COMPILE_2140
  case 58: {
    if ((encoding_len > 0) &&
        !__is_neg("14-58", 4, (int *){encoding_len, refcount, ht, version_len},
                  0, 0, 10,
                  (void **){docp, encoding, return_value, id, intern, olddoc,
                            version, this_ptr, dom_document_class_entry,
                            dom_domexception_class_entry},
                  0, 0, 14, "encoding_len", "docp", "encoding", "return_value",
                  "id", "intern", "olddoc", "version", "refcount", "ht",
                  "this_ptr", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry")) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2141
  case 59: {
    if ((encoding_len > 0) ||
        __is_neg("14-59", 4, (int *){encoding_len, refcount, ht, version_len},
                 0, 0, 10,
                 (void **){docp, encoding, return_value, id, intern, olddoc,
                           version, this_ptr, dom_document_class_entry,
                           dom_domexception_class_entry},
                 0, 0, 14, "encoding_len", "docp", "encoding", "return_value",
                 "id", "intern", "olddoc", "version", "refcount", "ht",
                 "this_ptr", "version_len", "dom_document_class_entry",
                 "dom_domexception_class_entry")) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2142
  case 60: {
    if (__is_neg("14-60", 4, (int *){encoding_len, refcount, ht, version_len},
                 0, 0, 10,
                 (void **){docp, encoding, return_value, id, intern, olddoc,
                           version, this_ptr, dom_document_class_entry,
                           dom_domexception_class_entry},
                 0, 0, 14, "encoding_len", "docp", "encoding", "return_value",
                 "id", "intern", "olddoc", "version", "refcount", "ht",
                 "this_ptr", "version_len", "dom_document_class_entry",
                 "dom_domexception_class_entry"))
      return;
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2143
  case 61: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2144
  case 62: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2145
  case 63: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2146
  case 64: {
    intern = (dom_object *)zend_object_store_get_object(id);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2147
  case 65: {
    intern->document = ((void *)0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2148
  case 66: {
    memset(docp, 0, sizeof(*(docp)));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2149
  case 67: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2150
  case 68: {
    olddoc->_private = ((void *)0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2151
  case 69: {
    php_dom_create_implementation((return_value_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2152
  case 70: {
    php_dom_create_interator((id), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2153
  case 71: {
    php_dom_create_interator((return_value), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2154
  case 72: {
    php_dom_create_interator((this_ptr), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2155
  case 73: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2156
  case 74: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2157
  case 75: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2158
  case 76: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2159
  case 77: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2160
  case 78: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2161
  case 79: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2162
  case 80: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2163
  case 81: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2164
  case 82: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2165
  case 83: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2166
  case 84: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2167
  case 85: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2168
  case 86: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2169
  case 87: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2170
  case 88: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2171
  case 89: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2172
  case 90: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2173
  case 91: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2174
  case 92: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2175
  case 93: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2176
  case 94: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2177
  case 95: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2178
  case 96: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2179
  case 97: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2180
  case 98: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2181
  case 99: {
    php_dom_throw_error((PHP_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2182
  case 100: {
    php_dom_throw_error((PHP_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2183
  case 101: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2184
  case 102: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2185
  case 103: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2186
  case 104: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2187
  case 105: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2188
  case 106: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2189
  case 107: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2190
  case 108: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2191
  case 109: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2192
  case 110: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2193
  case 111: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2194
  case 112: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2195
  case 113: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2196
  case 114: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2197
  case 115: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2198
  case 116: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2199
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2200
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2201
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2202
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2203
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2204
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2205
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2206
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2207
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2208
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2209
  case 127: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2210
  case 128: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2211
  case 129: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2212
  case 130: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2213
  case 131: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2214
  case 132: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2215
  case 133: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2216
  case 134: {
    xmlInitParser();
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2217
  case 135: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2218
  case 136: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2219
  case 137: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2220
  case 138: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2221
  case 139: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2222
  case 140: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2223
  case 141: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2224
  case 142: {
    zend_restore_error_handling(&error_handling);
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2225
  case 143: {
    zval_unset_isref_p((id));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2226
  case 144: {
    zval_unset_isref_p((return_value));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
#ifdef COMPILE_2227
  case 145: {
    zval_unset_isref_p((this_ptr));
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }

    break;
  }
#endif
  }

  // prophet generated patch
  switch (__choose("__ID15")) {
  case 0: {
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#ifdef COMPILE_2228
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2229
  case 2: {
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2230
  case 3: {
    (docp) = xmlNewDoc(version);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2231
  case 4: {
    (docp)->_private = ((void *)0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2232
  case 5: {
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2233
  case 6: {
    (encoding)++;
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2234
  case 7: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2235
  case 8: {
    (intern) = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2236
  case 9: {
    (intern) = (dom_object *)zend_object_store_get_object(id);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2237
  case 10: {
    (intern)->document = ((void *)0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2238
  case 11: {
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2239
  case 12: {
    (olddoc) = xmlNewDoc(version);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2240
  case 13: {
    (olddoc)->_private = ((void *)0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2241
  case 14: {
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2242
  case 15: {
    (version)++;
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2243
  case 16: {
    _convert_to_string(((id)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2244
  case 17: {
    _convert_to_string(((return_value)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2245
  case 18: {
    _convert_to_string(((this_ptr)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2246
  case 19: {
    _efree(((id)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2247
  case 20: {
    _efree(((return_value)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2248
  case 21: {
    _efree(((this_ptr)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2249
  case 22: {
    _zval_copy_ctor_func((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2250
  case 23: {
    _zval_copy_ctor_func((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2251
  case 24: {
    _zval_copy_ctor_func((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2252
  case 25: {
    _zval_dtor(((id)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2253
  case 26: {
    _zval_dtor(((return_value)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2254
  case 27: {
    _zval_dtor(((this_ptr)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2255
  case 28: {
    _zval_dtor_func((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2256
  case 29: {
    _zval_dtor_func((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2257
  case 30: {
    _zval_dtor_func((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2258
  case 31: {
    _zval_ptr_dtor((&(id)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2259
  case 32: {
    _zval_ptr_dtor((&(return_value)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2260
  case 33: {
    _zval_ptr_dtor((&(this_ptr)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2261
  case 34: {
    convert_to_boolean((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2262
  case 35: {
    convert_to_boolean((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2263
  case 36: {
    convert_to_boolean((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2264
  case 37: {
    convert_to_long((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2265
  case 38: {
    convert_to_long((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2266
  case 39: {
    convert_to_long((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2267
  case 40: {
    docp = xmlNewDoc((encoding));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2268
  case 41: {
    docp = xmlNewDoc((version));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2269
  case 42: {
    docp = xmlNewDoc(version);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2270
  case 43: {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2271
  case 44: {
    exit(1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2272
  case 45: {
    gc_remove_zval_from_buffer((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2273
  case 46: {
    gc_remove_zval_from_buffer((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2274
  case 47: {
    gc_remove_zval_from_buffer((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2275
  case 48: {
    gc_zval_check_possible_root(((id)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2276
  case 49: {
    gc_zval_check_possible_root(((return_value)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2277
  case 50: {
    gc_zval_check_possible_root(((this_ptr)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2278
  case 51: {
    gc_zval_possible_root((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2279
  case 52: {
    gc_zval_possible_root((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2280
  case 53: {
    gc_zval_possible_root((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2281
  case 54: {
    i_zval_ptr_dtor((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2282
  case 55: {
    i_zval_ptr_dtor((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2283
  case 56: {
    i_zval_ptr_dtor((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2284
  case 57: {
    if (!__is_neg("15-57", 4, (int *){encoding_len, refcount, ht, version_len},
                  0, 0, 10,
                  (void **){id, intern, olddoc, docp, encoding, return_value,
                            version, this_ptr, dom_document_class_entry,
                            dom_domexception_class_entry},
                  0, 0, 14, "id", "intern", "olddoc", "docp", "encoding",
                  "encoding_len", "refcount", "return_value", "version", "ht",
                  "this_ptr", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry"))
      intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2285
  case 58: {
    if (__is_neg("15-58", 4, (int *){encoding_len, refcount, ht, version_len},
                 0, 0, 10,
                 (void **){id, intern, olddoc, docp, encoding, return_value,
                           version, this_ptr, dom_document_class_entry,
                           dom_domexception_class_entry},
                 0, 0, 14, "id", "intern", "olddoc", "docp", "encoding",
                 "encoding_len", "refcount", "return_value", "version", "ht",
                 "this_ptr", "version_len", "dom_document_class_entry",
                 "dom_domexception_class_entry"))
      return;
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2286
  case 59: {
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2287
  case 60: {
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2288
  case 61: {
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2289
  case 62: {
    intern = (dom_object *)zend_object_store_get_object(id);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2290
  case 63: {
    intern->document = ((void *)0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2291
  case 64: {
    memset(intern, 0, sizeof(*(intern)));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2292
  case 65: {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2293
  case 66: {
    olddoc->_private = ((void *)0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2294
  case 67: {
    php_dom_create_implementation((return_value_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2295
  case 68: {
    php_dom_create_interator((id), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2296
  case 69: {
    php_dom_create_interator((return_value), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2297
  case 70: {
    php_dom_create_interator((this_ptr), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2298
  case 71: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2299
  case 72: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2300
  case 73: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2301
  case 74: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2302
  case 75: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2303
  case 76: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2304
  case 77: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2305
  case 78: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2306
  case 79: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2307
  case 80: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2308
  case 81: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2309
  case 82: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2310
  case 83: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2311
  case 84: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2312
  case 85: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2313
  case 86: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2314
  case 87: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2315
  case 88: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2316
  case 89: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2317
  case 90: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2318
  case 91: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2319
  case 92: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2320
  case 93: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2321
  case 94: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2322
  case 95: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2323
  case 96: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2324
  case 97: {
    php_dom_throw_error((PHP_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2325
  case 98: {
    php_dom_throw_error((PHP_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2326
  case 99: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2327
  case 100: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2328
  case 101: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2329
  case 102: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2330
  case 103: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2331
  case 104: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2332
  case 105: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2333
  case 106: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2334
  case 107: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2335
  case 108: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2336
  case 109: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2337
  case 110: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2338
  case 111: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2339
  case 112: {
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2340
  case 113: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2341
  case 114: {
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2342
  case 115: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2343
  case 116: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2344
  case 117: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2345
  case 118: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2346
  case 119: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2347
  case 120: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2348
  case 121: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2349
  case 122: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2350
  case 123: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2351
  case 124: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2352
  case 125: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2353
  case 126: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2354
  case 127: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2355
  case 128: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2356
  case 129: {
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2357
  case 130: {
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2358
  case 131: {
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2359
  case 132: {
    xmlInitParser();
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2360
  case 133: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2361
  case 134: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2362
  case 135: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2363
  case 136: {
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2364
  case 137: {
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2365
  case 138: {
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2366
  case 139: {
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2367
  case 140: {
    zend_restore_error_handling(&error_handling);
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2368
  case 141: {
    zval_unset_isref_p((id));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2369
  case 142: {
    zval_unset_isref_p((return_value));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
#ifdef COMPILE_2370
  case 143: {
    zval_unset_isref_p((this_ptr));
    intern = (dom_object *)zend_object_store_get_object(id);

    break;
  }
#endif
  }
  if (intern != NULL) {
    // prophet generated patch
    switch (__choose("__ID16")) {
    case 0: {
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#ifdef COMPILE_2371
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2372
    case 2: {
      (docp) = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2373
    case 3: {
      (docp) = (xmlDocPtr)dom_object_get_node(intern);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2374
    case 4: {
      (docp) = xmlNewDoc(version);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2375
    case 5: {
      (docp)->_private = ((void *)0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2376
    case 6: {
      (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2377
    case 7: {
      (encoding)++;
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2378
    case 8: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2379
    case 9: {
      (intern) = (dom_object *)zend_object_store_get_object(id);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2380
    case 10: {
      (intern)->document = ((void *)0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2381
    case 11: {
      (olddoc) = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2382
    case 12: {
      (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2383
    case 13: {
      (olddoc) = xmlNewDoc(version);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2384
    case 14: {
      (olddoc)->_private = ((void *)0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2385
    case 15: {
      (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2386
    case 16: {
      (version)++;
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2387
    case 17: {
      _convert_to_string(((id)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2388
    case 18: {
      _convert_to_string(((return_value)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2389
    case 19: {
      _convert_to_string(((this_ptr)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2390
    case 20: {
      _efree(((id)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2391
    case 21: {
      _efree(((return_value)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2392
    case 22: {
      _efree(((this_ptr)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2393
    case 23: {
      _zval_copy_ctor_func((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2394
    case 24: {
      _zval_copy_ctor_func((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2395
    case 25: {
      _zval_copy_ctor_func((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2396
    case 26: {
      _zval_dtor(((id)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2397
    case 27: {
      _zval_dtor(((return_value)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2398
    case 28: {
      _zval_dtor(((this_ptr)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2399
    case 29: {
      _zval_dtor_func((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2400
    case 30: {
      _zval_dtor_func((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2401
    case 31: {
      _zval_dtor_func((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2402
    case 32: {
      _zval_ptr_dtor((&(id)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2403
    case 33: {
      _zval_ptr_dtor((&(return_value)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2404
    case 34: {
      _zval_ptr_dtor((&(this_ptr)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2405
    case 35: {
      convert_to_boolean((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2406
    case 36: {
      convert_to_boolean((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2407
    case 37: {
      convert_to_boolean((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2408
    case 38: {
      convert_to_long((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2409
    case 39: {
      convert_to_long((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2410
    case 40: {
      convert_to_long((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2411
    case 41: {
      docp = xmlNewDoc((encoding));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2412
    case 42: {
      docp = xmlNewDoc((version));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2413
    case 43: {
      docp = xmlNewDoc(version);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2414
    case 44: {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2415
    case 45: {
      exit(1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2416
    case 46: {
      gc_remove_zval_from_buffer((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2417
    case 47: {
      gc_remove_zval_from_buffer((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2418
    case 48: {
      gc_remove_zval_from_buffer((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2419
    case 49: {
      gc_zval_check_possible_root(((id)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2420
    case 50: {
      gc_zval_check_possible_root(((return_value)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2421
    case 51: {
      gc_zval_check_possible_root(((this_ptr)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2422
    case 52: {
      gc_zval_possible_root((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2423
    case 53: {
      gc_zval_possible_root((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2424
    case 54: {
      gc_zval_possible_root((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2425
    case 55: {
      i_zval_ptr_dtor((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2426
    case 56: {
      i_zval_ptr_dtor((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2427
    case 57: {
      i_zval_ptr_dtor((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2428
    case 58: {
      if (!__is_neg("16-58", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){olddoc, intern, id, docp, encoding, return_value,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "olddoc", "intern", "id", "refcount", "docp",
                    "encoding", "encoding_len", "return_value", "version", "ht",
                    "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry"))
        olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2429
    case 59: {
      if (__is_neg("16-59", 4, (int *){refcount, encoding_len, ht, version_len},
                   0, 0, 10,
                   (void **){olddoc, intern, id, docp, encoding, return_value,
                             version, this_ptr, dom_document_class_entry,
                             dom_domexception_class_entry},
                   0, 0, 14, "olddoc", "intern", "id", "refcount", "docp",
                   "encoding", "encoding_len", "return_value", "version", "ht",
                   "this_ptr", "version_len", "dom_document_class_entry",
                   "dom_domexception_class_entry"))
        return;
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2430
    case 60: {
      if (encoding_len > 0) {
        docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      }
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2431
    case 61: {
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2432
    case 62: {
      if (zend_parse_method_parameters(
              (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
              &version_len, &encoding, &encoding_len) == -1) {
        zend_restore_error_handling(&error_handling);
        return;
      }
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2433
    case 63: {
      intern = (dom_object *)zend_object_store_get_object(id);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2434
    case 64: {
      intern->document = ((void *)0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2435
    case 65: {
      memset(intern, 0, sizeof(*(intern)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2436
    case 66: {
      memset(olddoc, 0, sizeof(*(olddoc)));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2437
    case 67: {
      olddoc = (xmlDocPtr)dom_object_get_node(intern);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2438
    case 68: {
      olddoc->_private = ((void *)0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2439
    case 69: {
      php_dom_create_implementation((return_value_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2440
    case 70: {
      php_dom_create_interator((id), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2441
    case 71: {
      php_dom_create_interator((return_value), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2442
    case 72: {
      php_dom_create_interator((this_ptr), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2443
    case 73: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2444
    case 74: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2445
    case 75: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2446
    case 76: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2447
    case 77: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2448
    case 78: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2449
    case 79: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2450
    case 80: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2451
    case 81: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2452
    case 82: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2453
    case 83: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2454
    case 84: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2455
    case 85: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2456
    case 86: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2457
    case 87: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2458
    case 88: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2459
    case 89: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2460
    case 90: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2461
    case 91: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2462
    case 92: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2463
    case 93: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2464
    case 94: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2465
    case 95: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2466
    case 96: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2467
    case 97: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2468
    case 98: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2469
    case 99: {
      php_dom_throw_error((PHP_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2470
    case 100: {
      php_dom_throw_error((PHP_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2471
    case 101: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2472
    case 102: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2473
    case 103: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2474
    case 104: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2475
    case 105: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2476
    case 106: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2477
    case 107: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2478
    case 108: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2479
    case 109: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2480
    case 110: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2481
    case 111: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (encoding));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2482
    case 112: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (version));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2483
    case 113: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (encoding));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2484
    case 114: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (version));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2485
    case 115: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (encoding));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2486
    case 116: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (version));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2487
    case 117: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2488
    case 118: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2489
    case 119: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2490
    case 120: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2491
    case 121: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2492
    case 122: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2493
    case 123: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2494
    case 124: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2495
    case 125: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2496
    case 126: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2497
    case 127: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2498
    case 128: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2499
    case 129: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2500
    case 130: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2501
    case 131: {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2502
    case 132: {
      php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                    (xmlNodePtr)docp, (void *)intern);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2503
    case 133: {
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2504
    case 134: {
      xmlInitParser();
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2505
    case 135: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2506
    case 136: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2507
    case 137: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2508
    case 138: {
      zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                  &error_handling);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2509
    case 139: {
      zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                  &error_handling);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2510
    case 140: {
      zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                  &error_handling);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2511
    case 141: {
      zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                  &error_handling);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2512
    case 142: {
      zend_restore_error_handling(&error_handling);
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2513
    case 143: {
      zval_unset_isref_p((id));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2514
    case 144: {
      zval_unset_isref_p((return_value));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
#ifdef COMPILE_2515
    case 145: {
      zval_unset_isref_p((this_ptr));
      olddoc = (xmlDocPtr)dom_object_get_node(intern);

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID17")) {
    case 0: {
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#ifdef COMPILE_2516
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2517
    case 2: {
      (docp) = (xmlDocPtr)dom_object_get_node(intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2518
    case 3: {
      (docp) = xmlNewDoc(version);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2519
    case 4: {
      (docp)->_private = ((void *)0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2520
    case 5: {
      (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2521
    case 6: {
      (encoding)++;
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2522
    case 7: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2523
    case 8: {
      (intern) = (dom_object *)zend_object_store_get_object(id);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2524
    case 9: {
      (intern)->document = ((void *)0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2525
    case 10: {
      (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2526
    case 11: {
      (olddoc) = xmlNewDoc(version);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2527
    case 12: {
      (olddoc)->_private = ((void *)0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2528
    case 13: {
      (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2529
    case 14: {
      (version)++;
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2530
    case 15: {
      _convert_to_string(((id)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2531
    case 16: {
      _convert_to_string(((return_value)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2532
    case 17: {
      _convert_to_string(((this_ptr)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2533
    case 18: {
      _efree(((id)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2534
    case 19: {
      _efree(((return_value)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2535
    case 20: {
      _efree(((this_ptr)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2536
    case 21: {
      _zval_copy_ctor_func((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2537
    case 22: {
      _zval_copy_ctor_func((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2538
    case 23: {
      _zval_copy_ctor_func((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2539
    case 24: {
      _zval_dtor(((id)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2540
    case 25: {
      _zval_dtor(((return_value)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2541
    case 26: {
      _zval_dtor(((this_ptr)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2542
    case 27: {
      _zval_dtor_func((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2543
    case 28: {
      _zval_dtor_func((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2544
    case 29: {
      _zval_dtor_func((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2545
    case 30: {
      _zval_ptr_dtor((&(id)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2546
    case 31: {
      _zval_ptr_dtor((&(return_value)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2547
    case 32: {
      _zval_ptr_dtor((&(this_ptr)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2548
    case 33: {
      convert_to_boolean((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2549
    case 34: {
      convert_to_boolean((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2550
    case 35: {
      convert_to_boolean((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2551
    case 36: {
      convert_to_long((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2552
    case 37: {
      convert_to_long((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2553
    case 38: {
      convert_to_long((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2554
    case 39: {
      docp = xmlNewDoc((encoding));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2555
    case 40: {
      docp = xmlNewDoc((version));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2556
    case 41: {
      docp = xmlNewDoc(version);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2557
    case 42: {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2558
    case 43: {
      exit(1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2559
    case 44: {
      gc_remove_zval_from_buffer((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2560
    case 45: {
      gc_remove_zval_from_buffer((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2561
    case 46: {
      gc_remove_zval_from_buffer((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2562
    case 47: {
      gc_zval_check_possible_root(((id)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2563
    case 48: {
      gc_zval_check_possible_root(((return_value)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2564
    case 49: {
      gc_zval_check_possible_root(((this_ptr)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2565
    case 50: {
      gc_zval_possible_root((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2566
    case 51: {
      gc_zval_possible_root((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2567
    case 52: {
      gc_zval_possible_root((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2568
    case 53: {
      i_zval_ptr_dtor((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2569
    case 54: {
      i_zval_ptr_dtor((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2570
    case 55: {
      i_zval_ptr_dtor((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2571
    case 56: {
      if (!__is_neg("17-56", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){olddoc, intern, id, docp, encoding, return_value,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "olddoc", "intern", "refcount", "id", "docp",
                    "encoding", "encoding_len", "return_value", "version", "ht",
                    "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry") &&
          (olddoc != ((void *)0))) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2572
    case 57: {
      if (!__is_neg("17-57", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){olddoc, intern, id, docp, encoding, return_value,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "olddoc", "intern", "refcount", "id", "docp",
                    "encoding", "encoding_len", "return_value", "version", "ht",
                    "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry"))
        if (olddoc != ((void *)0)) {
          php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
          refcount =
              php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
          if (refcount != 0) {
            olddoc->_private = ((void *)0);
          }
        }

      break;
    }
#endif
#ifdef COMPILE_2573
    case 58: {
      if ((olddoc != ((void *)0)) &&
          !__is_neg("17-58", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){olddoc, intern, id, docp, encoding, return_value,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "olddoc", "intern", "refcount", "id", "docp",
                    "encoding", "encoding_len", "return_value", "version", "ht",
                    "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry")) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2574
    case 59: {
      if ((olddoc != ((void *)0)) ||
          __is_neg("17-59", 4, (int *){refcount, encoding_len, ht, version_len},
                   0, 0, 10,
                   (void **){olddoc, intern, id, docp, encoding, return_value,
                             version, this_ptr, dom_document_class_entry,
                             dom_domexception_class_entry},
                   0, 0, 14, "olddoc", "intern", "refcount", "id", "docp",
                   "encoding", "encoding_len", "return_value", "version", "ht",
                   "this_ptr", "version_len", "dom_document_class_entry",
                   "dom_domexception_class_entry")) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2575
    case 60: {
      if (__is_neg("17-60", 4, (int *){refcount, encoding_len, ht, version_len},
                   0, 0, 10,
                   (void **){olddoc, intern, id, docp, encoding, return_value,
                             version, this_ptr, dom_document_class_entry,
                             dom_domexception_class_entry},
                   0, 0, 14, "olddoc", "intern", "refcount", "id", "docp",
                   "encoding", "encoding_len", "return_value", "version", "ht",
                   "this_ptr", "version_len", "dom_document_class_entry",
                   "dom_domexception_class_entry"))
        return;
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2576
    case 61: {
      if (encoding_len > 0) {
        docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      }
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2577
    case 62: {
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2578
    case 63: {
      if (zend_parse_method_parameters(
              (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
              &version_len, &encoding, &encoding_len) == -1) {
        zend_restore_error_handling(&error_handling);
        return;
      }
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2579
    case 64: {
      intern = (dom_object *)zend_object_store_get_object(id);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2580
    case 65: {
      intern->document = ((void *)0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2581
    case 66: {
      memset(intern, 0, sizeof(*(intern)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2582
    case 67: {
      memset(olddoc, 0, sizeof(*(olddoc)));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2583
    case 68: {
      olddoc = (xmlDocPtr)dom_object_get_node(intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2584
    case 69: {
      olddoc->_private = ((void *)0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2585
    case 70: {
      php_dom_create_implementation((return_value_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2586
    case 71: {
      php_dom_create_interator((id), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2587
    case 72: {
      php_dom_create_interator((return_value), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2588
    case 73: {
      php_dom_create_interator((this_ptr), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2589
    case 74: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2590
    case 75: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2591
    case 76: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2592
    case 77: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2593
    case 78: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2594
    case 79: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2595
    case 80: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2596
    case 81: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2597
    case 82: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2598
    case 83: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2599
    case 84: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2600
    case 85: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2601
    case 86: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2602
    case 87: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2603
    case 88: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2604
    case 89: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2605
    case 90: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2606
    case 91: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2607
    case 92: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2608
    case 93: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2609
    case 94: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2610
    case 95: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2611
    case 96: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2612
    case 97: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2613
    case 98: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2614
    case 99: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2615
    case 100: {
      php_dom_throw_error((PHP_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2616
    case 101: {
      php_dom_throw_error((PHP_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2617
    case 102: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2618
    case 103: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2619
    case 104: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2620
    case 105: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2621
    case 106: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2622
    case 107: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2623
    case 108: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2624
    case 109: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2625
    case 110: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2626
    case 111: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2627
    case 112: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (encoding));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2628
    case 113: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (version));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2629
    case 114: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (encoding));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2630
    case 115: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (version));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2631
    case 116: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (encoding));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2632
    case 117: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (version));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2633
    case 118: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2634
    case 119: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2635
    case 120: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2636
    case 121: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2637
    case 122: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2638
    case 123: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2639
    case 124: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2640
    case 125: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2641
    case 126: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2642
    case 127: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2643
    case 128: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2644
    case 129: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2645
    case 130: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2646
    case 131: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2647
    case 132: {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2648
    case 133: {
      php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                    (xmlNodePtr)docp, (void *)intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2649
    case 134: {
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2650
    case 135: {
      xmlInitParser();
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2651
    case 136: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2652
    case 137: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2653
    case 138: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2654
    case 139: {
      zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                  &error_handling);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2655
    case 140: {
      zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                  &error_handling);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2656
    case 141: {
      zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                  &error_handling);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2657
    case 142: {
      zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                  &error_handling);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2658
    case 143: {
      zend_restore_error_handling(&error_handling);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2659
    case 144: {
      zval_unset_isref_p((id));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2660
    case 145: {
      zval_unset_isref_p((return_value));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
#ifdef COMPILE_2661
    case 146: {
      zval_unset_isref_p((this_ptr));
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID18")) {
    case 0: {
      intern->document = ((void *)0);

      break;
    }
#ifdef COMPILE_2662
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2663
    case 2: {
      (docp) = (xmlDocPtr)dom_object_get_node(intern);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2664
    case 3: {
      (docp) = xmlNewDoc(version);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2665
    case 4: {
      (docp)->_private = ((void *)0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2666
    case 5: {
      (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2667
    case 6: {
      (encoding)++;
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2668
    case 7: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2669
    case 8: {
      (intern) = (dom_object *)zend_object_store_get_object(id);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2670
    case 9: {
      (intern)->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2671
    case 10: {
      (intern)->document = ((void *)0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2672
    case 11: {
      (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2673
    case 12: {
      (olddoc) = xmlNewDoc(version);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2674
    case 13: {
      (olddoc)->_private = ((void *)0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2675
    case 14: {
      (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2676
    case 15: {
      (version)++;
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2677
    case 16: {
      _convert_to_string(((id)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2678
    case 17: {
      _convert_to_string(((return_value)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2679
    case 18: {
      _convert_to_string(((this_ptr)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2680
    case 19: {
      _efree(((id)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2681
    case 20: {
      _efree(((return_value)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2682
    case 21: {
      _efree(((this_ptr)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2683
    case 22: {
      _zval_copy_ctor_func((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2684
    case 23: {
      _zval_copy_ctor_func((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2685
    case 24: {
      _zval_copy_ctor_func((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2686
    case 25: {
      _zval_dtor(((id)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2687
    case 26: {
      _zval_dtor(((return_value)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2688
    case 27: {
      _zval_dtor(((this_ptr)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2689
    case 28: {
      _zval_dtor_func((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2690
    case 29: {
      _zval_dtor_func((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2691
    case 30: {
      _zval_dtor_func((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2692
    case 31: {
      _zval_ptr_dtor((&(id)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2693
    case 32: {
      _zval_ptr_dtor((&(return_value)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2694
    case 33: {
      _zval_ptr_dtor((&(this_ptr)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2695
    case 34: {
      convert_to_boolean((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2696
    case 35: {
      convert_to_boolean((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2697
    case 36: {
      convert_to_boolean((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2698
    case 37: {
      convert_to_long((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2699
    case 38: {
      convert_to_long((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2700
    case 39: {
      convert_to_long((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2701
    case 40: {
      docp = xmlNewDoc((encoding));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2702
    case 41: {
      docp = xmlNewDoc((version));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2703
    case 42: {
      docp = xmlNewDoc(version);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2704
    case 43: {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2705
    case 44: {
      exit(1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2706
    case 45: {
      gc_remove_zval_from_buffer((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2707
    case 46: {
      gc_remove_zval_from_buffer((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2708
    case 47: {
      gc_remove_zval_from_buffer((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2709
    case 48: {
      gc_zval_check_possible_root(((id)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2710
    case 49: {
      gc_zval_check_possible_root(((return_value)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2711
    case 50: {
      gc_zval_check_possible_root(((this_ptr)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2712
    case 51: {
      gc_zval_possible_root((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2713
    case 52: {
      gc_zval_possible_root((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2714
    case 53: {
      gc_zval_possible_root((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2715
    case 54: {
      i_zval_ptr_dtor((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2716
    case 55: {
      i_zval_ptr_dtor((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2717
    case 56: {
      i_zval_ptr_dtor((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2718
    case 57: {
      if (!__is_neg("18-57", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){intern, docp, return_value, olddoc, id, encoding,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "intern", "docp", "return_value", "olddoc",
                    "refcount", "id", "encoding", "encoding_len", "version",
                    "ht", "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry"))
        intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2719
    case 58: {
      if (__is_neg("18-58", 4, (int *){refcount, encoding_len, ht, version_len},
                   0, 0, 10,
                   (void **){intern, docp, return_value, olddoc, id, encoding,
                             version, this_ptr, dom_document_class_entry,
                             dom_domexception_class_entry},
                   0, 0, 14, "intern", "docp", "return_value", "olddoc",
                   "refcount", "id", "encoding", "encoding_len", "version",
                   "ht", "this_ptr", "version_len", "dom_document_class_entry",
                   "dom_domexception_class_entry"))
        return;
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2720
    case 59: {
      if (encoding_len > 0) {
        docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      }
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2721
    case 60: {
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2722
    case 61: {
      if (zend_parse_method_parameters(
              (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
              &version_len, &encoding, &encoding_len) == -1) {
        zend_restore_error_handling(&error_handling);
        return;
      }
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2723
    case 62: {
      intern = (dom_object *)zend_object_store_get_object(id);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2724
    case 63: {
      intern->document = ((void *)0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2725
    case 64: {
      memset(intern, 0, sizeof(*(intern)));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2726
    case 65: {
      olddoc = (xmlDocPtr)dom_object_get_node(intern);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2727
    case 66: {
      olddoc->_private = ((void *)0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2728
    case 67: {
      php_dom_create_implementation((return_value_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2729
    case 68: {
      php_dom_create_interator((id), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2730
    case 69: {
      php_dom_create_interator((return_value), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2731
    case 70: {
      php_dom_create_interator((this_ptr), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2732
    case 71: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2733
    case 72: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2734
    case 73: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2735
    case 74: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2736
    case 75: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2737
    case 76: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2738
    case 77: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2739
    case 78: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2740
    case 79: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2741
    case 80: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2742
    case 81: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2743
    case 82: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2744
    case 83: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2745
    case 84: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2746
    case 85: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2747
    case 86: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2748
    case 87: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2749
    case 88: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2750
    case 89: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2751
    case 90: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2752
    case 91: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2753
    case 92: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2754
    case 93: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2755
    case 94: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2756
    case 95: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2757
    case 96: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2758
    case 97: {
      php_dom_throw_error((PHP_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2759
    case 98: {
      php_dom_throw_error((PHP_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2760
    case 99: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2761
    case 100: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2762
    case 101: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2763
    case 102: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2764
    case 103: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2765
    case 104: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2766
    case 105: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2767
    case 106: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2768
    case 107: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2769
    case 108: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2770
    case 109: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (encoding));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2771
    case 110: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (version));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2772
    case 111: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (encoding));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2773
    case 112: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (version));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2774
    case 113: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (encoding));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2775
    case 114: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (version));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2776
    case 115: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2777
    case 116: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2778
    case 117: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2779
    case 118: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2780
    case 119: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2781
    case 120: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2782
    case 121: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2783
    case 122: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2784
    case 123: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2785
    case 124: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2786
    case 125: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2787
    case 126: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2788
    case 127: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2789
    case 128: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2790
    case 129: {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2791
    case 130: {
      php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                    (xmlNodePtr)docp, (void *)intern);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2792
    case 131: {
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2793
    case 132: {
      xmlInitParser();
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2794
    case 133: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2795
    case 134: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2796
    case 135: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2797
    case 136: {
      zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                  &error_handling);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2798
    case 137: {
      zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                  &error_handling);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2799
    case 138: {
      zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                  &error_handling);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2800
    case 139: {
      zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                  &error_handling);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2801
    case 140: {
      zend_restore_error_handling(&error_handling);
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2802
    case 141: {
      zval_unset_isref_p((id));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2803
    case 142: {
      zval_unset_isref_p((return_value));
      intern->document = ((void *)0);

      break;
    }
#endif
#ifdef COMPILE_2804
    case 143: {
      zval_unset_isref_p((this_ptr));
      intern->document = ((void *)0);

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID19")) {
    case 0: {
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#ifdef COMPILE_2805
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2806
    case 2: {
      (docp) = (xmlDocPtr)dom_object_get_node(intern);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2807
    case 3: {
      (docp) = xmlNewDoc(version);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2808
    case 4: {
      (docp)->_private = ((void *)0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2809
    case 5: {
      (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2810
    case 6: {
      (encoding)++;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2811
    case 7: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2812
    case 8: {
      (intern) = (dom_object *)zend_object_store_get_object(id);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2813
    case 9: {
      (intern)->document = ((void *)0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2814
    case 10: {
      (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2815
    case 11: {
      (olddoc) = xmlNewDoc(version);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2816
    case 12: {
      (olddoc)->_private = ((void *)0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2817
    case 13: {
      (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2818
    case 14: {
      (version)++;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2819
    case 15: {
      _convert_to_string(((id)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2820
    case 16: {
      _convert_to_string(((return_value)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2821
    case 17: {
      _convert_to_string(((this_ptr)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2822
    case 18: {
      _efree(((id)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2823
    case 19: {
      _efree(((return_value)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2824
    case 20: {
      _efree(((this_ptr)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2825
    case 21: {
      _zval_copy_ctor_func((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2826
    case 22: {
      _zval_copy_ctor_func((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2827
    case 23: {
      _zval_copy_ctor_func((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2828
    case 24: {
      _zval_dtor(((id)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2829
    case 25: {
      _zval_dtor(((return_value)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2830
    case 26: {
      _zval_dtor(((this_ptr)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2831
    case 27: {
      _zval_dtor_func((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2832
    case 28: {
      _zval_dtor_func((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2833
    case 29: {
      _zval_dtor_func((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2834
    case 30: {
      _zval_ptr_dtor((&(id)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2835
    case 31: {
      _zval_ptr_dtor((&(return_value)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2836
    case 32: {
      _zval_ptr_dtor((&(this_ptr)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2837
    case 33: {
      convert_to_boolean((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2838
    case 34: {
      convert_to_boolean((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2839
    case 35: {
      convert_to_boolean((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2840
    case 36: {
      convert_to_long((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2841
    case 37: {
      convert_to_long((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2842
    case 38: {
      convert_to_long((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2843
    case 39: {
      docp = xmlNewDoc((encoding));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2844
    case 40: {
      docp = xmlNewDoc((version));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2845
    case 41: {
      docp = xmlNewDoc(version);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2846
    case 42: {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2847
    case 43: {
      exit(1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2848
    case 44: {
      gc_remove_zval_from_buffer((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2849
    case 45: {
      gc_remove_zval_from_buffer((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2850
    case 46: {
      gc_remove_zval_from_buffer((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2851
    case 47: {
      gc_zval_check_possible_root(((id)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2852
    case 48: {
      gc_zval_check_possible_root(((return_value)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2853
    case 49: {
      gc_zval_check_possible_root(((this_ptr)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2854
    case 50: {
      gc_zval_possible_root((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2855
    case 51: {
      gc_zval_possible_root((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2856
    case 52: {
      gc_zval_possible_root((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2857
    case 53: {
      i_zval_ptr_dtor((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2858
    case 54: {
      i_zval_ptr_dtor((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2859
    case 55: {
      i_zval_ptr_dtor((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2860
    case 56: {
      if (!__is_neg("19-56", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){docp, intern, return_value, olddoc, id, encoding,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "docp", "intern", "return_value", "olddoc",
                    "refcount", "id", "encoding", "encoding_len", "version",
                    "ht", "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry") &&
          (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                        docp) == -1)) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2861
    case 57: {
      if (!__is_neg("19-57", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){docp, intern, return_value, olddoc, id, encoding,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "docp", "intern", "return_value", "olddoc",
                    "refcount", "id", "encoding", "encoding_len", "version",
                    "ht", "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry"))
        if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                         docp) == -1) {
          {
            do {
              zval *__z = (return_value);
              (*__z).value.lval = ((0) != 0);
              (*__z).type = 3;
            } while (0);
            return;
          };
        }

      break;
    }
#endif
#ifdef COMPILE_2862
    case 58: {
      if ((php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                        docp) == -1) &&
          !__is_neg("19-58", 4,
                    (int *){refcount, encoding_len, ht, version_len}, 0, 0, 10,
                    (void **){docp, intern, return_value, olddoc, id, encoding,
                              version, this_ptr, dom_document_class_entry,
                              dom_domexception_class_entry},
                    0, 0, 14, "docp", "intern", "return_value", "olddoc",
                    "refcount", "id", "encoding", "encoding_len", "version",
                    "ht", "this_ptr", "version_len", "dom_document_class_entry",
                    "dom_domexception_class_entry")) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2863
    case 59: {
      if ((php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                        docp) == -1) ||
          __is_neg("19-59", 4, (int *){refcount, encoding_len, ht, version_len},
                   0, 0, 10,
                   (void **){docp, intern, return_value, olddoc, id, encoding,
                             version, this_ptr, dom_document_class_entry,
                             dom_domexception_class_entry},
                   0, 0, 14, "docp", "intern", "return_value", "olddoc",
                   "refcount", "id", "encoding", "encoding_len", "version",
                   "ht", "this_ptr", "version_len", "dom_document_class_entry",
                   "dom_domexception_class_entry")) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2864
    case 60: {
      if (__is_neg("19-60", 4, (int *){refcount, encoding_len, ht, version_len},
                   0, 0, 10,
                   (void **){docp, intern, return_value, olddoc, id, encoding,
                             version, this_ptr, dom_document_class_entry,
                             dom_domexception_class_entry},
                   0, 0, 14, "docp", "intern", "return_value", "olddoc",
                   "refcount", "id", "encoding", "encoding_len", "version",
                   "ht", "this_ptr", "version_len", "dom_document_class_entry",
                   "dom_domexception_class_entry"))
        return;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2865
    case 61: {
      if (encoding_len > 0) {
        docp->encoding = (const xmlChar *)xmlStrdup(encoding);
      }
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2866
    case 62: {
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2867
    case 63: {
      if (zend_parse_method_parameters(
              (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
              &version_len, &encoding, &encoding_len) == -1) {
        zend_restore_error_handling(&error_handling);
        return;
      }
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2868
    case 64: {
      intern = (dom_object *)zend_object_store_get_object(id);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2869
    case 65: {
      intern->document = ((void *)0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2870
    case 66: {
      memset(docp, 0, sizeof(*(docp)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2871
    case 67: {
      memset(intern, 0, sizeof(*(intern)));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2872
    case 68: {
      olddoc = (xmlDocPtr)dom_object_get_node(intern);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2873
    case 69: {
      olddoc->_private = ((void *)0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2874
    case 70: {
      php_dom_create_implementation((return_value_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2875
    case 71: {
      php_dom_create_interator((id), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2876
    case 72: {
      php_dom_create_interator((return_value), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2877
    case 73: {
      php_dom_create_interator((this_ptr), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2878
    case 74: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2879
    case 75: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2880
    case 76: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2881
    case 77: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2882
    case 78: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2883
    case 79: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2884
    case 80: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2885
    case 81: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2886
    case 82: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2887
    case 83: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2888
    case 84: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2889
    case 85: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2890
    case 86: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2891
    case 87: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2892
    case 88: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2893
    case 89: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2894
    case 90: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2895
    case 91: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2896
    case 92: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2897
    case 93: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2898
    case 94: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2899
    case 95: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2900
    case 96: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2901
    case 97: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2902
    case 98: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2903
    case 99: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2904
    case 100: {
      php_dom_throw_error((PHP_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2905
    case 101: {
      php_dom_throw_error((PHP_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2906
    case 102: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2907
    case 103: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2908
    case 104: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2909
    case 105: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2910
    case 106: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2911
    case 107: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2912
    case 108: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2913
    case 109: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2914
    case 110: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2915
    case 111: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2916
    case 112: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (encoding));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2917
    case 113: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s could not be registered.", (version));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2918
    case 114: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (encoding));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2919
    case 115: {
      php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                        (version));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2920
    case 116: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (encoding));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2921
    case 117: {
      php_error_docref0(((void *)0), (1 << 0L),
                        "Class %s is not derived from DOMNode.", (version));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2922
    case 118: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2923
    case 119: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2924
    case 120: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2925
    case 121: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2926
    case 122: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2927
    case 123: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2928
    case 124: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2929
    case 125: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2930
    case 126: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2931
    case 127: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2932
    case 128: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2933
    case 129: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2934
    case 130: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2935
    case 131: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2936
    case 132: {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2937
    case 133: {
      php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                    (xmlNodePtr)docp, (void *)intern);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2938
    case 134: {
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2939
    case 135: {
      xmlInitParser();
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2940
    case 136: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2941
    case 137: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2942
    case 138: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2943
    case 139: {
      zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                  &error_handling);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2944
    case 140: {
      zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                  &error_handling);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2945
    case 141: {
      zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                  &error_handling);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2946
    case 142: {
      zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                  &error_handling);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2947
    case 143: {
      zend_restore_error_handling(&error_handling);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2948
    case 144: {
      zval_unset_isref_p((id));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2949
    case 145: {
      zval_unset_isref_p((return_value));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_2950
    case 146: {
      zval_unset_isref_p((this_ptr));
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern TSRMLS_CC);
  }
}
/* }}} end DOMDocument::__construct */

char *_dom_get_valid_file_path(char *source, char *resolved_path,
                               int resolved_path_len TSRMLS_DC) /* {{{ */
{
  xmlURI *uri;
  xmlChar *escsource;
  char *file_dest;
  int isFileUri = 0;

  uri = xmlCreateURI();
  escsource = xmlURIEscapeStr(source, ":");
  xmlParseURIReference(uri, escsource);
  xmlFree(escsource);

  if (uri->scheme != NULL) {
    /* absolute file uris - libxml only supports localhost or empty host */
    if (strncasecmp(source, "file:///", 8) == 0) {
      isFileUri = 1;
#ifdef PHP_WIN32
      source += 8;
#else
      source += 7;
#endif
    } else if (strncasecmp(source, "file://localhost/", 17) == 0) {
      isFileUri = 1;
#ifdef PHP_WIN32
      source += 17;
#else
      source += 16;
#endif
    }
  }

  file_dest = source;

  if ((uri->scheme == NULL || isFileUri)) {
    /* XXX possible buffer overflow if VCWD_REALPATH does not know size of
     * resolved_path */
    if (!VCWD_REALPATH(source, resolved_path) &&
        !expand_filepath(source, resolved_path TSRMLS_CC)) {
      xmlFreeURI(uri);
      return NULL;
    }
    file_dest = resolved_path;
  }

  xmlFreeURI(uri);

  return file_dest;
}
/* }}} */

static xmlDocPtr dom_document_parser(zval *id, int mode, char *source,
                                     int source_len,
                                     int options TSRMLS_DC) /* {{{ */
{
  xmlDocPtr ret;
  xmlParserCtxtPtr ctxt = NULL;
  dom_doc_propsptr doc_props;
  dom_object *intern;
  php_libxml_ref_obj *document = NULL;
  int validate, recover, resolve_externals, keep_blanks, substitute_ent;
  int resolved_path_len;
  int old_error_reporting = 0;
  char *directory = NULL, resolved_path[MAXPATHLEN];

  if (id != NULL) {
    intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
    document = intern->document;
  }

  doc_props = dom_get_doc_props(document);
  validate = doc_props->validateonparse;
  resolve_externals = doc_props->resolveexternals;
  keep_blanks = doc_props->preservewhitespace;
  substitute_ent = doc_props->substituteentities;
  recover = doc_props->recover;

  if (document == NULL) {
    efree(doc_props);
  }

  xmlInitParser();

  if (mode == DOM_LOAD_FILE) {
    char *file_dest =
        _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
    if (file_dest) {
      ctxt = xmlCreateFileParserCtxt(file_dest);
    }

  } else {
    ctxt = xmlCreateMemoryParserCtxt(source, source_len);
  }

  if (ctxt == NULL) {
    return (NULL);
  }

  /* If loading from memory, we need to set the base directory for the document
   */
  if (mode != DOM_LOAD_FILE) {
#if HAVE_GETCWD
    directory = VCWD_GETCWD(resolved_path, MAXPATHLEN);
#elif HAVE_GETWD
    directory = VCWD_GETWD(resolved_path);
#endif
    if (directory) {
      if (ctxt->directory != NULL) {
        xmlFree((char *)ctxt->directory);
      }
      resolved_path_len = strlen(resolved_path);
      if (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {
        resolved_path[resolved_path_len] = DEFAULT_SLASH;
        resolved_path[++resolved_path_len] = '\0';
      }
      ctxt->directory = (char *)xmlCanonicPath((const xmlChar *)resolved_path);
    }
  }

  ctxt->vctxt.error = php_libxml_ctx_error;
  ctxt->vctxt.warning = php_libxml_ctx_warning;

  if (ctxt->sax != NULL) {
    ctxt->sax->error = php_libxml_ctx_error;
    ctxt->sax->warning = php_libxml_ctx_warning;
  }

  if (validate && !(options & XML_PARSE_DTDVALID)) {
    options |= XML_PARSE_DTDVALID;
  }
  if (resolve_externals && !(options & XML_PARSE_DTDATTR)) {
    options |= XML_PARSE_DTDATTR;
  }
  if (substitute_ent && !(options & XML_PARSE_NOENT)) {
    options |= XML_PARSE_NOENT;
  }
  if (keep_blanks == 0 && !(options & XML_PARSE_NOBLANKS)) {
    options |= XML_PARSE_NOBLANKS;
  }

  xmlCtxtUseOptions(ctxt, options);

  ctxt->recovery = recover;
  if (recover) {
    old_error_reporting = EG(error_reporting);
    EG(error_reporting) = old_error_reporting | E_WARNING;
  }

  xmlParseDocument(ctxt);

  if (ctxt->wellFormed || recover) {
    ret = ctxt->myDoc;
    if (ctxt->recovery) {
      EG(error_reporting) = old_error_reporting;
    }
    /* If loading from memory, set the base reference uri for the document */
    if (ret && ret->URL == NULL && ctxt->directory != NULL) {
      ret->URL = xmlStrdup(ctxt->directory);
    }
  } else {
    ret = NULL;
    xmlFreeDoc(ctxt->myDoc);
    ctxt->myDoc = NULL;
  }

  xmlFreeParserCtxt(ctxt);

  return (ret);
}
/* }}} */

/* {{{ static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) */
static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) {
  zval *id, *rv = NULL;
  xmlDoc *docp = NULL, *newdoc;
  dom_doc_propsptr doc_prop;
  dom_object *intern;
  char *source;
  int source_len, refcount, ret;
  long options = 0;

  id = getThis();
  if (id != NULL &&
      !instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
    id = NULL;
  }

  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &source,
                            &source_len, &options) == FAILURE) {
    return;
  }

  if (!source_len) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Empty string supplied as input");
    RETURN_FALSE;
  }

  newdoc = dom_document_parser(id, mode, source, source_len, options TSRMLS_CC);

  if (!newdoc)
    RETURN_FALSE;

  if (id != NULL) {
    intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
    if (intern != NULL) {
      docp = (xmlDocPtr)dom_object_get_node(intern);
      doc_prop = NULL;
      if (docp != NULL) {
        php_libxml_decrement_node_ptr(
            (php_libxml_node_object *)intern TSRMLS_CC);
        doc_prop = intern->document->doc_props;
        intern->document->doc_props = NULL;
        refcount = php_libxml_decrement_doc_ref(
            (php_libxml_node_object *)intern TSRMLS_CC);
        if (refcount != 0) {
          docp->_private = NULL;
        }
      }
      intern->document = NULL;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       newdoc TSRMLS_CC) == -1) {
        RETURN_FALSE;
      }
      intern->document->doc_props = doc_prop;
    }

    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

    RETURN_TRUE;
  } else {
    DOM_RET_OBJ(rv, (xmlNodePtr)newdoc, &ret, NULL);
  }
}
/* }}} end dom_parser_document */

/* {{{ proto DOMNode dom_document_load(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-load
Since: DOM Level 3
*/
PHP_METHOD(domdocument, load) {
  dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load */

/* {{{ proto DOMNode dom_document_loadxml(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-loadXML
Since: DOM Level 3
*/
PHP_METHOD(domdocument, loadXML) {
  dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_loadxml */

/* {{{ proto int dom_document_save(string file);
Convenience method to save to file
*/
PHP_FUNCTION(dom_document_save) {
  zval *id;
  xmlDoc *docp;
  int file_len = 0, bytes, format, saveempty = 0;
  dom_object *intern;
  dom_doc_propsptr doc_props;
  char *file;
  long options = 0;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os|l",
                                   &id, dom_document_class_entry, &file,
                                   &file_len, &options) == FAILURE) {
    return;
  }

  if (file_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  /* encoding handled by property on doc */

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;
  if (options & LIBXML_SAVE_NOEMPTYTAG) {
    saveempty = xmlSaveNoEmptyTags;
    xmlSaveNoEmptyTags = 1;
  }
  bytes = xmlSaveFormatFileEnc(file, docp, NULL, format);
  if (options & LIBXML_SAVE_NOEMPTYTAG) {
    xmlSaveNoEmptyTags = saveempty;
  }
  if (bytes == -1) {
    RETURN_FALSE;
  }
  RETURN_LONG(bytes);
}
/* }}} end dom_document_save */

/* {{{ proto string dom_document_savexml([node n]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-saveXML
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_savexml) {
  zval *id, *nodep = NULL;
  xmlDoc *docp;
  xmlNode *node;
  xmlBufferPtr buf;
  xmlChar *mem;
  dom_object *intern, *nodeobj;
  dom_doc_propsptr doc_props;
  int size, format, saveempty = 0;
  long options = 0;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(),
                                   "O|O!l", &id, dom_document_class_entry,
                                   &nodep, dom_node_class_entry,
                                   &options) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;

  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      saveempty = xmlSaveNoEmptyTags;
      xmlSaveNoEmptyTags = 1;
    }
    xmlNodeDump(buf, docp, node, 0, format);
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      xmlSaveNoEmptyTags = saveempty;
    }
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      xmlBufferFree(buf);
      RETURN_FALSE;
    }
    RETVAL_STRING(mem, 1);
    xmlBufferFree(buf);
  } else {
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      saveempty = xmlSaveNoEmptyTags;
      xmlSaveNoEmptyTags = 1;
    }
    /* Encoding is handled from the encoding property set on the document */
    xmlDocDumpFormatMemory(docp, &mem, &size, format);
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      xmlSaveNoEmptyTags = saveempty;
    }
    if (!size) {
      RETURN_FALSE;
    }
    RETVAL_STRINGL(mem, size, 1);
    xmlFree(mem);
  }
}
/* }}} end dom_document_savexml */

static xmlNodePtr php_dom_free_xinclude_node(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
  xmlNodePtr xincnode;

  xincnode = cur;
  cur = cur->next;
  xmlUnlinkNode(xincnode);
  php_libxml_node_free_resource(xincnode TSRMLS_CC);

  return cur;
}
/* }}} */

static void php_dom_remove_xinclude_nodes(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
  while (cur) {
    if (cur->type == XML_XINCLUDE_START) {
      cur = php_dom_free_xinclude_node(cur TSRMLS_CC);

      /* XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START */
      while (cur && cur->type != XML_XINCLUDE_END) {
        /* remove xinclude processing nodes from recursive xincludes */
        if (cur->type == XML_ELEMENT_NODE) {
          php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
        }
        cur = cur->next;
      }

      if (cur && cur->type == XML_XINCLUDE_END) {
        cur = php_dom_free_xinclude_node(cur TSRMLS_CC);
      }
    } else {
      if (cur->type == XML_ELEMENT_NODE) {
        php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
      }
      cur = cur->next;
    }
  }
}
/* }}} */

/* {{{ proto int dom_document_xinclude([int options])
   Substitutues xincludes in a DomDocument */
PHP_FUNCTION(dom_document_xinclude) {
  zval *id;
  xmlDoc *docp;
  xmlNodePtr root;
  long flags = 0;
  int err;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|l",
                                   &id, dom_document_class_entry,
                                   &flags) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  err = xmlXIncludeProcessFlags(docp, flags);

  /* XML_XINCLUDE_START and XML_XINCLUDE_END nodes need to be removed as these
  are added via xmlXIncludeProcess to mark beginning and ending of xincluded
  document but are not wanted in resulting document - must be done even if err
  as it could fail after having processed some xincludes */
  root = (xmlNodePtr)docp->children;
  while (root && root->type != XML_ELEMENT_NODE &&
         root->type != XML_XINCLUDE_START) {
    root = root->next;
  }
  if (root) {
    php_dom_remove_xinclude_nodes(root TSRMLS_CC);
  }

  if (err) {
    RETVAL_LONG(err);
  } else {
    RETVAL_FALSE;
  }
}
/* }}} */

/* {{{ proto boolean dom_document_validate();
Since: DOM extended
*/
PHP_FUNCTION(dom_document_validate) {
  zval *id;
  xmlDoc *docp;
  dom_object *intern;
  xmlValidCtxt *cvp;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",
                                   &id, dom_document_class_entry) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  cvp = xmlNewValidCtxt();

  cvp->userData = NULL;
  cvp->error = (xmlValidityErrorFunc)php_libxml_error_handler;
  cvp->warning = (xmlValidityErrorFunc)php_libxml_error_handler;

  if (xmlValidateDocument(cvp, docp)) {
    RETVAL_TRUE;
  } else {
    RETVAL_FALSE;
  }

  xmlFreeValidCtxt(cvp);
}
/* }}} */

#if defined(LIBXML_SCHEMAS_ENABLED)
static void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS,
                                          int type) /* {{{ */
{
  zval *id;
  xmlDoc *docp;
  dom_object *intern;
  char *source = NULL, *valid_file = NULL;
  int source_len = 0;
  xmlSchemaParserCtxtPtr parser;
  xmlSchemaPtr sptr;
  xmlSchemaValidCtxtPtr vptr;
  int is_valid;
  char resolved_path[MAXPATHLEN + 1];

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &source,
                                   &source_len) == FAILURE) {
    return;
  }

  if (source_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema source");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  switch (type) {
  case DOM_LOAD_FILE:
    valid_file =
        _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
    if (!valid_file) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema file source");
      RETURN_FALSE;
    }
    parser = xmlSchemaNewParserCtxt(valid_file);
    break;
  case DOM_LOAD_STRING:
    parser = xmlSchemaNewMemParserCtxt(source, source_len);
    /* If loading from memory, we need to set the base directory for the
       document but it is not apparent how to do that for schema's */
    break;
  default:
    return;
  }

  xmlSchemaSetParserErrors(
      parser, (xmlSchemaValidityErrorFunc)php_libxml_error_handler,
      (xmlSchemaValidityWarningFunc)php_libxml_error_handler, parser);
  sptr = xmlSchemaParse(parser);
  xmlSchemaFreeParserCtxt(parser);
  if (!sptr) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema");
    RETURN_FALSE;
  }

  docp = (xmlDocPtr)dom_object_get_node(intern);

  vptr = xmlSchemaNewValidCtxt(sptr);
  if (!vptr) {
    xmlSchemaFree(sptr);
    php_error(E_ERROR, "Invalid Schema Validation Context");
    RETURN_FALSE;
  }

  xmlSchemaSetValidErrors(vptr, php_libxml_error_handler,
                          php_libxml_error_handler, vptr);
  is_valid = xmlSchemaValidateDoc(vptr, docp);
  xmlSchemaFree(sptr);
  xmlSchemaFreeValidCtxt(vptr);

  if (is_valid == 0) {
    RETURN_TRUE;
  } else {
    RETURN_FALSE;
  }
}
/* }}} */

/* {{{ proto boolean dom_document_schema_validate_file(string filename); */
PHP_FUNCTION(dom_document_schema_validate_file) {
  _dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                DOM_LOAD_FILE);
}
/* }}} end dom_document_schema_validate_file */

/* {{{ proto boolean dom_document_schema_validate(string source); */
PHP_FUNCTION(dom_document_schema_validate_xml) {
  _dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                DOM_LOAD_STRING);
}
/* }}} end dom_document_schema_validate */

static void _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAMETERS,
                                           int type) /* {{{ */
{
  zval *id;
  xmlDoc *docp;
  dom_object *intern;
  char *source = NULL, *valid_file = NULL;
  int source_len = 0;
  xmlRelaxNGParserCtxtPtr parser;
  xmlRelaxNGPtr sptr;
  xmlRelaxNGValidCtxtPtr vptr;
  int is_valid;
  char resolved_path[MAXPATHLEN + 1];

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &source,
                                   &source_len) == FAILURE) {
    return;
  }

  if (source_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema source");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  switch (type) {
  case DOM_LOAD_FILE:
    valid_file =
        _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
    if (!valid_file) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING,
                       "Invalid RelaxNG file source");
      RETURN_FALSE;
    }
    parser = xmlRelaxNGNewParserCtxt(valid_file);
    break;
  case DOM_LOAD_STRING:
    parser = xmlRelaxNGNewMemParserCtxt(source, source_len);
    /* If loading from memory, we need to set the base directory for the
       document but it is not apparent how to do that for schema's */
    break;
  default:
    return;
  }

  xmlRelaxNGSetParserErrors(
      parser, (xmlRelaxNGValidityErrorFunc)php_libxml_error_handler,
      (xmlRelaxNGValidityWarningFunc)php_libxml_error_handler, parser);
  sptr = xmlRelaxNGParse(parser);
  xmlRelaxNGFreeParserCtxt(parser);
  if (!sptr) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid RelaxNG");
    RETURN_FALSE;
  }

  docp = (xmlDocPtr)dom_object_get_node(intern);

  vptr = xmlRelaxNGNewValidCtxt(sptr);
  if (!vptr) {
    xmlRelaxNGFree(sptr);
    php_error(E_ERROR, "Invalid RelaxNG Validation Context");
    RETURN_FALSE;
  }

  xmlRelaxNGSetValidErrors(vptr, php_libxml_error_handler,
                           php_libxml_error_handler, vptr);
  is_valid = xmlRelaxNGValidateDoc(vptr, docp);
  xmlRelaxNGFree(sptr);
  xmlRelaxNGFreeValidCtxt(vptr);

  if (is_valid == 0) {
    RETURN_TRUE;
  } else {
    RETURN_FALSE;
  }
}
/* }}} */

/* {{{ proto boolean dom_document_relaxNG_validate_file(string filename); */
PHP_FUNCTION(dom_document_relaxNG_validate_file) {
  _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                 DOM_LOAD_FILE);
}
/* }}} end dom_document_relaxNG_validate_file */

/* {{{ proto boolean dom_document_relaxNG_validate_xml(string source); */
PHP_FUNCTION(dom_document_relaxNG_validate_xml) {
  _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                 DOM_LOAD_STRING);
}
/* }}} end dom_document_relaxNG_validate_xml */

#endif

#if defined(LIBXML_HTML_ENABLED)

static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
{
  zval *id, *rv = NULL;
  xmlDoc *docp = NULL, *newdoc;
  dom_object *intern;
  dom_doc_propsptr doc_prop;
  char *source;
  int source_len, refcount, ret;
  htmlParserCtxtPtr ctxt;

  id = getThis();

  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &source,
                            &source_len) == FAILURE) {
    return;
  }

  if (!source_len) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Empty string supplied as input");
    RETURN_FALSE;
  }

  if (mode == DOM_LOAD_FILE) {
    ctxt = htmlCreateFileParserCtxt(source, NULL);
  } else {
    source_len = xmlStrlen(source);
    ctxt = htmlCreateMemoryParserCtxt(source, source_len);
  }

  if (!ctxt) {
    RETURN_FALSE;
  }

  ctxt->vctxt.error = php_libxml_ctx_error;
  ctxt->vctxt.warning = php_libxml_ctx_warning;
  if (ctxt->sax != NULL) {
    ctxt->sax->error = php_libxml_ctx_error;
    ctxt->sax->warning = php_libxml_ctx_warning;
  }
  htmlParseDocument(ctxt);
  newdoc = ctxt->myDoc;
  htmlFreeParserCtxt(ctxt);

  if (!newdoc)
    RETURN_FALSE;

  if (id != NULL &&
      instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
    intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
    if (intern != NULL) {
      docp = (xmlDocPtr)dom_object_get_node(intern);
      doc_prop = NULL;
      if (docp != NULL) {
        php_libxml_decrement_node_ptr(
            (php_libxml_node_object *)intern TSRMLS_CC);
        doc_prop = intern->document->doc_props;
        intern->document->doc_props = NULL;
        refcount = php_libxml_decrement_doc_ref(
            (php_libxml_node_object *)intern TSRMLS_CC);
        if (refcount != 0) {
          docp->_private = NULL;
        }
      }
      intern->document = NULL;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       newdoc TSRMLS_CC) == -1) {
        RETURN_FALSE;
      }
      intern->document->doc_props = doc_prop;
    }

    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

    RETURN_TRUE;
  } else {
    DOM_RET_OBJ(rv, (xmlNodePtr)newdoc, &ret, NULL);
  }
}
/* }}} */

/* {{{ proto DOMNode dom_document_load_html_file(string source);
Since: DOM extended
*/
PHP_METHOD(domdocument, loadHTMLFile) {
  dom_load_html(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load_html_file */

/* {{{ proto DOMNode dom_document_load_html(string source);
Since: DOM extended
*/
PHP_METHOD(domdocument, loadHTML) {
  dom_load_html(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_load_html */

/* {{{ proto int dom_document_save_html_file(string file);
Convenience method to save to file as html
*/
PHP_FUNCTION(dom_document_save_html_file) {
  zval *id;
  xmlDoc *docp;
  int file_len, bytes, format;
  dom_object *intern;
  dom_doc_propsptr doc_props;
  char *file;
  const char *encoding;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &file,
                                   &file_len) == FAILURE) {
    return;
  }

  if (file_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  encoding = (const char *)htmlGetMetaEncoding(docp);

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;
  bytes = htmlSaveFileFormat(file, docp, encoding, format);

  if (bytes == -1) {
    RETURN_FALSE;
  }
  RETURN_LONG(bytes);
}
/* }}} end dom_document_save_html_file */

/* {{{ proto string dom_document_save_html();
Convenience method to output as html
*/
PHP_FUNCTION(dom_document_save_html) {
  zval *id, *nodep = NULL;
  xmlDoc *docp;
  xmlNode *node;
  xmlBufferPtr buf;
  dom_object *intern, *nodeobj;
  xmlChar *mem = NULL;
  int size, format;
  dom_doc_propsptr doc_props;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|O!",
                                   &id, dom_document_class_entry, &nodep,
                                   dom_node_class_entry) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;

  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlFree(mem);
  }
}
/* }}} end dom_document_save_html */

#endif /* defined(LIBXML_HTML_ENABLED) */

/* {{{ proto boolean DOMDocument::registerNodeClass(string baseclass, string
   extendedclass); Register extended class used to create base node type */
PHP_METHOD(domdocument, registerNodeClass) {
  zval *id;
  xmlDoc *docp;
  char *baseclass = NULL, *extendedclass = NULL;
  int baseclass_len = 0, extendedclass_len = 0;
  zend_class_entry *basece = NULL, *ce = NULL;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oss!",
                                   &id, dom_document_class_entry, &baseclass,
                                   &baseclass_len, &extendedclass,
                                   &extendedclass_len) == FAILURE) {
    return;
  }

  if (baseclass_len) {
    zend_class_entry **pce;
    if (zend_lookup_class(baseclass, baseclass_len, &pce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR, "Class %s does not exist",
                       baseclass);
      return;
    }
    basece = *pce;
  }

  if (basece == NULL ||
      !instanceof_function(basece, dom_node_class_entry TSRMLS_CC)) {
    php_error_docref(NULL TSRMLS_CC, E_ERROR,
                     "Class %s is not derived from DOMNode.", baseclass);
    return;
  }

  if (extendedclass_len) {
    zend_class_entry **pce;
    if (zend_lookup_class(extendedclass, extendedclass_len, &pce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR, "Class %s does not exist",
                       extendedclass);
    }
    ce = *pce;
  }

  if (ce == NULL || instanceof_function(ce, basece TSRMLS_CC)) {

    DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

    if (dom_set_doc_classmap(intern->document, basece, ce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR,
                       "Class %s could not be registered.", extendedclass);
    }
    RETURN_TRUE;
  } else {
    php_error_docref(NULL TSRMLS_CC, E_ERROR,
                     "Class %s is not derived from %s.", extendedclass,
                     baseclass);
  }

  RETURN_FALSE;
}
/* }}} */

#endif /* HAVE_LIBXML && HAVE_DOM */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
// prophet generated patch
switch (__choose("__ID20")) {
case 0: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#ifdef COMPILE_2951
case 1: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (*(__xmlSaveNoEmptyTags())) = 1;
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2952
case 2: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (docp) = (xmlDocPtr)dom_object_get_node(intern);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2953
case 3: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (docp) = xmlNewDoc(version);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2954
case 4: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (docp)->_private = ((void *)0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2955
case 5: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2956
case 6: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (encoding)++;
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2957
case 7: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2958
case 8: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (intern) = (dom_object *)zend_object_store_get_object(id);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2959
case 9: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (intern)->document = ((void *)0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2960
case 10: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2961
case 11: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (olddoc) = xmlNewDoc(version);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2962
case 12: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (olddoc)->_private = ((void *)0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2963
case 13: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2964
case 14: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    (version)++;
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2965
case 15: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    Debug((php_libxml_node_object *)intern, (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2966
case 16: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _convert_to_string(((id)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2967
case 17: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _convert_to_string(((return_value)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2968
case 18: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _convert_to_string(((this_ptr)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2969
case 19: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _efree(((id)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2970
case 20: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _efree(((return_value)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2971
case 21: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _efree(((this_ptr)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2972
case 22: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_copy_ctor_func((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2973
case 23: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_copy_ctor_func((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2974
case 24: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_copy_ctor_func((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2975
case 25: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_dtor(((id)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2976
case 26: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_dtor(((return_value)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2977
case 27: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_dtor(((this_ptr)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2978
case 28: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_dtor_func((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2979
case 29: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_dtor_func((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2980
case 30: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_dtor_func((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2981
case 31: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_ptr_dtor((&(id)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2982
case 32: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_ptr_dtor((&(return_value)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2983
case 33: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    _zval_ptr_dtor((&(this_ptr)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2984
case 34: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    convert_to_boolean((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2985
case 35: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    convert_to_boolean((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2986
case 36: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    convert_to_boolean((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2987
case 37: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    convert_to_long((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2988
case 38: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    convert_to_long((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2989
case 39: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    convert_to_long((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2990
case 40: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    docp = xmlNewDoc((encoding));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2991
case 41: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    docp = xmlNewDoc((version));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2992
case 42: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    docp = xmlNewDoc(version);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2993
case 43: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2994
case 44: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    exit(1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2995
case 45: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_remove_zval_from_buffer((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2996
case 46: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_remove_zval_from_buffer((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2997
case 47: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_remove_zval_from_buffer((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2998
case 48: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_zval_check_possible_root(((id)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_2999
case 49: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_zval_check_possible_root(((return_value)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3000
case 50: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_zval_check_possible_root(((this_ptr)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3001
case 51: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_zval_possible_root((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3002
case 52: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_zval_possible_root((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3003
case 53: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    gc_zval_possible_root((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3004
case 54: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    i_zval_ptr_dtor((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3005
case 55: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    i_zval_ptr_dtor((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3006
case 56: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    i_zval_ptr_dtor((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3007
case 57: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    if (!__is_neg("20-57", 4, (int *){refcount, encoding_len, ht, version_len},
                  0, 0, 10,
                  (void **){docp, intern, return_value, olddoc, id, encoding,
                            version, this_ptr, dom_document_class_entry,
                            dom_domexception_class_entry},
                  0, 0, 14, "docp", "intern", "return_value", "olddoc",
                  "refcount", "id", "encoding", "encoding_len", "version", "ht",
                  "this_ptr", "version_len", "dom_document_class_entry",
                  "dom_domexception_class_entry"))
      php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                    (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3008
case 58: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    if (__is_neg("20-58", 4, (int *){refcount, encoding_len, ht, version_len},
                 0, 0, 10,
                 (void **){docp, intern, return_value, olddoc, id, encoding,
                           version, this_ptr, dom_document_class_entry,
                           dom_domexception_class_entry},
                 0, 0, 14, "docp", "intern", "return_value", "olddoc",
                 "refcount", "id", "encoding", "encoding_len", "version", "ht",
                 "this_ptr", "version_len", "dom_document_class_entry",
                 "dom_domexception_class_entry"))
      return;
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3009
case 59: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    if (encoding_len > 0) {
      docp->encoding = (const xmlChar *)xmlStrdup(encoding);
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3010
case 60: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    if (refcount != 0) {
      olddoc->_private = ((void *)0);
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3011
case 61: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    if (zend_parse_method_parameters(
            (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
            &version_len, &encoding, &encoding_len) == -1) {
      zend_restore_error_handling(&error_handling);
      return;
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3012
case 62: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    intern = (dom_object *)zend_object_store_get_object(id);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3013
case 63: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    intern->document = ((void *)0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3014
case 64: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    memset(docp, 0, sizeof(*(docp)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3015
case 65: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    memset(intern, 0, sizeof(*(intern)));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3016
case 66: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3017
case 67: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    olddoc->_private = ((void *)0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3018
case 68: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_create_implementation((return_value_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3019
case 69: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_create_interator((id), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3020
case 70: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_create_interator((return_value), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3021
case 71: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_create_interator((this_ptr), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3022
case 72: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3023
case 73: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3024
case 74: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3025
case 75: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3026
case 76: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3027
case 77: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3028
case 78: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3029
case 79: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3030
case 80: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3031
case 81: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3032
case 82: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3033
case 83: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3034
case 84: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3035
case 85: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3036
case 86: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3037
case 87: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3038
case 88: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NAMESPACE_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3039
case 89: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NAMESPACE_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3040
case 90: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3041
case 91: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3042
case 92: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3043
case 93: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3044
case 94: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3045
case 95: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3046
case 96: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3047
case 97: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3048
case 98: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((PHP_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3049
case 99: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((PHP_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3050
case 100: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((SYNTAX_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3051
case 101: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((SYNTAX_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3052
case 102: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((VALIDATION_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3053
case 103: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((VALIDATION_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3054
case 104: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3055
case 105: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3056
case 106: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3057
case 107: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3058
case 108: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3059
case 109: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3060
case 110: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (encoding));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3061
case 111: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s could not be registered.", (version));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3062
case 112: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (encoding));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3063
case 113: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                      (version));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3064
case 114: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (encoding));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3065
case 115: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 0L),
                      "Class %s is not derived from DOMNode.", (version));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3066
case 116: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3067
case 117: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3068
case 118: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3069
case 119: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3070
case 120: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3071
case 121: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3072
case 122: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3073
case 123: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3074
case 124: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3075
case 125: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3076
case 126: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3077
case 127: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3078
case 128: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3079
case 129: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3080
case 130: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3081
case 131: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3082
case 132: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    php_printf((php_libxml_node_object *)intern, (xmlNodePtr)docp,
               (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3083
case 133: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    printf((php_libxml_node_object *)intern, (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3084
case 134: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3085
case 135: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    scanf((php_libxml_node_object *)intern, (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3086
case 136: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    xmlInitParser();
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3087
case 137: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3088
case 138: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3089
case 139: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3090
case 140: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                                &error_handling);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3091
case 141: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                                &error_handling);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3092
case 142: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                                &error_handling);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3093
case 143: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                                &error_handling);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3094
case 144: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zend_restore_error_handling(&error_handling);
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3095
case 145: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zval_unset_isref_p((id));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3096
case 146: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zval_unset_isref_p((return_value));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3097
case 147: {
  if (intern != NULL) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != NULL) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern TSRMLS_CC);
      refcount = php_libxml_decrement_doc_ref(
          (php_libxml_node_object *)intern TSRMLS_CC);
      if (refcount != 0) {
        olddoc->_private = NULL;
      }
    }
    intern->document = NULL;
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                     docp TSRMLS_CC) == -1) {
      RETURN_FALSE;
    }
    zval_unset_isref_p((this_ptr));
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3098
case 148: {
  (*(__xmlSaveNoEmptyTags())) = 1;
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3099
case 149: {
  (docp) = (xmlDocPtr)dom_object_get_node(intern);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3100
case 150: {
  (docp) = xmlNewDoc(version);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3101
case 151: {
  (docp)->_private = ((void *)0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3102
case 152: {
  (docp)->encoding = (const xmlChar *)xmlStrdup(encoding);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3103
case 153: {
  (encoding)++;
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3104
case 154: {
  (executor_globals.argument_stack) =
      zend_vm_stack_new_page(((16 * 1024) - 16));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3105
case 155: {
  (intern) = (dom_object *)zend_object_store_get_object(id);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3106
case 156: {
  (intern)->document = ((void *)0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3107
case 157: {
  (olddoc) = (xmlDocPtr)dom_object_get_node(intern);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3108
case 158: {
  (olddoc) = xmlNewDoc(version);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3109
case 159: {
  (olddoc)->_private = ((void *)0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3110
case 160: {
  (olddoc)->encoding = (const xmlChar *)xmlStrdup(encoding);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3111
case 161: {
  (version)++;
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3112
case 162: {
  _convert_to_string(((id)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3113
case 163: {
  _convert_to_string(((return_value)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3114
case 164: {
  _convert_to_string(((this_ptr)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3115
case 165: {
  _efree(((id)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3116
case 166: {
  _efree(((return_value)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3117
case 167: {
  _efree(((this_ptr)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3118
case 168: {
  _zval_copy_ctor_func((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3119
case 169: {
  _zval_copy_ctor_func((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3120
case 170: {
  _zval_copy_ctor_func((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3121
case 171: {
  _zval_dtor(((id)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3122
case 172: {
  _zval_dtor(((return_value)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3123
case 173: {
  _zval_dtor(((this_ptr)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3124
case 174: {
  _zval_dtor_func((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3125
case 175: {
  _zval_dtor_func((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3126
case 176: {
  _zval_dtor_func((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3127
case 177: {
  _zval_ptr_dtor((&(id)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3128
case 178: {
  _zval_ptr_dtor((&(return_value)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3129
case 179: {
  _zval_ptr_dtor((&(this_ptr)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3130
case 180: {
  convert_to_boolean((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3131
case 181: {
  convert_to_boolean((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3132
case 182: {
  convert_to_boolean((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3133
case 183: {
  convert_to_long((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3134
case 184: {
  convert_to_long((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3135
case 185: {
  convert_to_long((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3136
case 186: {
  docp = xmlNewDoc((encoding));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3137
case 187: {
  docp = xmlNewDoc((version));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3138
case 188: {
  docp = xmlNewDoc(version);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3139
case 189: {
  docp->encoding = (const xmlChar *)xmlStrdup(encoding);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3140
case 190: {
  exit(1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3141
case 191: {
  gc_remove_zval_from_buffer((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3142
case 192: {
  gc_remove_zval_from_buffer((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3143
case 193: {
  gc_remove_zval_from_buffer((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3144
case 194: {
  gc_zval_check_possible_root(((id)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3145
case 195: {
  gc_zval_check_possible_root(((return_value)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3146
case 196: {
  gc_zval_check_possible_root(((this_ptr)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3147
case 197: {
  gc_zval_possible_root((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3148
case 198: {
  gc_zval_possible_root((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3149
case 199: {
  gc_zval_possible_root((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3150
case 200: {
  i_zval_ptr_dtor((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3151
case 201: {
  i_zval_ptr_dtor((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3152
case 202: {
  i_zval_ptr_dtor((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3153
case 203: {
  if (!__is_neg("20-203", 4, (int *){refcount, encoding_len, ht, version_len},
                0, 0, 10,
                (void **){intern, id, olddoc, docp, encoding, return_value,
                          version, this_ptr, dom_document_class_entry,
                          dom_domexception_class_entry},
                0, 0, 14, "intern", "id", "olddoc", "docp", "encoding",
                "refcount", "encoding_len", "return_value", "version", "ht",
                "this_ptr", "version_len", "dom_document_class_entry",
                "dom_domexception_class_entry") &&
      (intern != ((void *)0))) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3154
case 204: {
  if (!__is_neg("20-204", 4, (int *){refcount, encoding_len, ht, version_len},
                0, 0, 10,
                (void **){intern, id, olddoc, docp, encoding, return_value,
                          version, this_ptr, dom_document_class_entry,
                          dom_domexception_class_entry},
                0, 0, 14, "intern", "id", "olddoc", "docp", "encoding",
                "refcount", "encoding_len", "return_value", "version", "ht",
                "this_ptr", "version_len", "dom_document_class_entry",
                "dom_domexception_class_entry"))
    if (intern != ((void *)0)) {
      olddoc = (xmlDocPtr)dom_object_get_node(intern);
      if (olddoc != ((void *)0)) {
        php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
        refcount =
            php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
        if (refcount != 0) {
          olddoc->_private = ((void *)0);
        }
      }
      intern->document = ((void *)0);
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       docp) == -1) {
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }
      php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                    (xmlNodePtr)docp, (void *)intern);
    }

  break;
}
#endif
#ifdef COMPILE_3155
case 205: {
  if ((intern != ((void *)0)) &&
      !__is_neg("20-205", 4, (int *){refcount, encoding_len, ht, version_len},
                0, 0, 10,
                (void **){intern, id, olddoc, docp, encoding, return_value,
                          version, this_ptr, dom_document_class_entry,
                          dom_domexception_class_entry},
                0, 0, 14, "intern", "id", "olddoc", "docp", "encoding",
                "refcount", "encoding_len", "return_value", "version", "ht",
                "this_ptr", "version_len", "dom_document_class_entry",
                "dom_domexception_class_entry")) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3156
case 206: {
  if ((intern != ((void *)0)) ||
      __is_neg("20-206", 4, (int *){refcount, encoding_len, ht, version_len}, 0,
               0, 10,
               (void **){intern, id, olddoc, docp, encoding, return_value,
                         version, this_ptr, dom_document_class_entry,
                         dom_domexception_class_entry},
               0, 0, 14, "intern", "id", "olddoc", "docp", "encoding",
               "refcount", "encoding_len", "return_value", "version", "ht",
               "this_ptr", "version_len", "dom_document_class_entry",
               "dom_domexception_class_entry")) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3157
case 207: {
  if (__is_neg("20-207", 4, (int *){refcount, encoding_len, ht, version_len}, 0,
               0, 10,
               (void **){intern, id, olddoc, docp, encoding, return_value,
                         version, this_ptr, dom_document_class_entry,
                         dom_domexception_class_entry},
               0, 0, 14, "intern", "id", "olddoc", "docp", "encoding",
               "refcount", "encoding_len", "return_value", "version", "ht",
               "this_ptr", "version_len", "dom_document_class_entry",
               "dom_domexception_class_entry"))
    return;
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3158
case 208: {
  if (encoding_len > 0) {
    docp->encoding = (const xmlChar *)xmlStrdup(encoding);
  }
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3159
case 209: {
  if (refcount != 0) {
    olddoc->_private = ((void *)0);
  }
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3160
case 210: {
  if (zend_parse_method_parameters(
          (ht), (this_ptr), "O|ss", &id, dom_document_class_entry, &version,
          &version_len, &encoding, &encoding_len) == -1) {
    zend_restore_error_handling(&error_handling);
    return;
  }
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3161
case 211: {
  intern = (dom_object *)zend_object_store_get_object(id);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3162
case 212: {
  intern->document = ((void *)0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3163
case 213: {
  memset(docp, 0, sizeof(*(docp)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3164
case 214: {
  memset(intern, 0, sizeof(*(intern)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3165
case 215: {
  memset(olddoc, 0, sizeof(*(olddoc)));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3166
case 216: {
  olddoc = (xmlDocPtr)dom_object_get_node(intern);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3167
case 217: {
  olddoc->_private = ((void *)0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3168
case 218: {
  php_dom_create_implementation((return_value_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3169
case 219: {
  php_dom_create_interator((id), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3170
case 220: {
  php_dom_create_interator((return_value), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3171
case 221: {
  php_dom_create_interator((this_ptr), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3172
case 222: {
  php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3173
case 223: {
  php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3174
case 224: {
  php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3175
case 225: {
  php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3176
case 226: {
  php_dom_throw_error((INDEX_SIZE_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3177
case 227: {
  php_dom_throw_error((INDEX_SIZE_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3178
case 228: {
  php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3179
case 229: {
  php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3180
case 230: {
  php_dom_throw_error((INVALID_ACCESS_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3181
case 231: {
  php_dom_throw_error((INVALID_ACCESS_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3182
case 232: {
  php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3183
case 233: {
  php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3184
case 234: {
  php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3185
case 235: {
  php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3186
case 236: {
  php_dom_throw_error((INVALID_STATE_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3187
case 237: {
  php_dom_throw_error((INVALID_STATE_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3188
case 238: {
  php_dom_throw_error((NAMESPACE_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3189
case 239: {
  php_dom_throw_error((NAMESPACE_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3190
case 240: {
  php_dom_throw_error((NOT_FOUND_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3191
case 241: {
  php_dom_throw_error((NOT_FOUND_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3192
case 242: {
  php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3193
case 243: {
  php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3194
case 244: {
  php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3195
case 245: {
  php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3196
case 246: {
  php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3197
case 247: {
  php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3198
case 248: {
  php_dom_throw_error((PHP_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3199
case 249: {
  php_dom_throw_error((PHP_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3200
case 250: {
  php_dom_throw_error((SYNTAX_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3201
case 251: {
  php_dom_throw_error((SYNTAX_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3202
case 252: {
  php_dom_throw_error((VALIDATION_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3203
case 253: {
  php_dom_throw_error((VALIDATION_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3204
case 254: {
  php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3205
case 255: {
  php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3206
case 256: {
  php_dom_throw_error(INVALID_CHARACTER_ERR,
                      dom_get_strict_error((intern)->document));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3207
case 257: {
  php_dom_throw_error(INVALID_STATE_ERR, 0);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3208
case 258: {
  php_dom_throw_error(INVALID_STATE_ERR, 1);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3209
case 259: {
  php_dom_throw_error(WRONG_DOCUMENT_ERR,
                      dom_get_strict_error((intern)->document));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3210
case 260: {
  php_error_docref0(((void *)0), (1 << 0L), "Class %s could not be registered.",
                    (encoding));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3211
case 261: {
  php_error_docref0(((void *)0), (1 << 0L), "Class %s could not be registered.",
                    (version));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3212
case 262: {
  php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                    (encoding));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3213
case 263: {
  php_error_docref0(((void *)0), (1 << 0L), "Class %s does not exist",
                    (version));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3214
case 264: {
  php_error_docref0(((void *)0), (1 << 0L),
                    "Class %s is not derived from DOMNode.", (encoding));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3215
case 265: {
  php_error_docref0(((void *)0), (1 << 0L),
                    "Class %s is not derived from DOMNode.", (version));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3216
case 266: {
  php_error_docref0(((void *)0), (1 << 1L),
                    "Cannot create required DOM object");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3217
case 267: {
  php_error_docref0(((void *)0), (1 << 1L),
                    "Cannot import: Node Type Not Supported");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3218
case 268: {
  php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3219
case 269: {
  php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                    (intern)->std.ce->name);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3220
case 270: {
  php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3221
case 271: {
  php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3222
case 272: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3223
case 273: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3224
case 274: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3225
case 275: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3226
case 276: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3227
case 277: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3228
case 278: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3229
case 279: {
  php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3230
case 280: {
  php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3231
case 281: {
  php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                (xmlNodePtr)docp, (void *)intern);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3232
case 282: {
  refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3233
case 283: {
  xmlInitParser();
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3234
case 284: {
  zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3235
case 285: {
  zend_error((1 << 0L), "Invalid Schema Validation Context");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3236
case 286: {
  zend_error((1 << 3L), "A non well formed numeric value encountered");
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3237
case 287: {
  zend_replace_error_handling((EH_NORMAL), dom_domexception_class_entry,
                              &error_handling);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3238
case 288: {
  zend_replace_error_handling((EH_SUPPRESS), dom_domexception_class_entry,
                              &error_handling);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3239
case 289: {
  zend_replace_error_handling((EH_THROW), dom_domexception_class_entry,
                              &error_handling);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3240
case 290: {
  zend_replace_error_handling(EH_THROW, dom_domexception_class_entry,
                              &error_handling);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3241
case 291: {
  zend_restore_error_handling(&error_handling);
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3242
case 292: {
  zval_unset_isref_p((id));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3243
case 293: {
  zval_unset_isref_p((return_value));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
#ifdef COMPILE_3244
case 294: {
  zval_unset_isref_p((this_ptr));
  if (intern != ((void *)0)) {
    olddoc = (xmlDocPtr)dom_object_get_node(intern);
    if (olddoc != ((void *)0)) {
      php_libxml_decrement_node_ptr((php_libxml_node_object *)intern);
      refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern);
      if (refcount != 0) {
        olddoc->_private = ((void *)0);
      }
    }
    intern->document = ((void *)0);
    if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, docp) ==
        -1) {
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)docp, (void *)intern);
  }

  break;
}
#endif
}
}
/* }}} end DOMDocument::__construct */

char *_dom_get_valid_file_path(char *source, char *resolved_path,
                               int resolved_path_len TSRMLS_DC) /* {{{ */
{
  xmlURI *uri;
  xmlChar *escsource;
  char *file_dest;
  int isFileUri = 0;

  uri = xmlCreateURI();
  escsource = xmlURIEscapeStr(source, ":");
  xmlParseURIReference(uri, escsource);
  xmlFree(escsource);

  if (uri->scheme != NULL) {
    /* absolute file uris - libxml only supports localhost or empty host */
    if (strncasecmp(source, "file:///", 8) == 0) {
      isFileUri = 1;
#ifdef PHP_WIN32
      source += 8;
#else
      source += 7;
#endif
    } else if (strncasecmp(source, "file://localhost/", 17) == 0) {
      isFileUri = 1;
#ifdef PHP_WIN32
      source += 17;
#else
      source += 16;
#endif
    }
  }

  file_dest = source;

  if ((uri->scheme == NULL || isFileUri)) {
    /* XXX possible buffer overflow if VCWD_REALPATH does not know size of
     * resolved_path */
    if (!VCWD_REALPATH(source, resolved_path) &&
        !expand_filepath(source, resolved_path TSRMLS_CC)) {
      xmlFreeURI(uri);
      return NULL;
    }
    file_dest = resolved_path;
  }

  xmlFreeURI(uri);

  return file_dest;
}
/* }}} */

static xmlDocPtr dom_document_parser(zval *id, int mode, char *source,
                                     int source_len,
                                     int options TSRMLS_DC) /* {{{ */
{
  xmlDocPtr ret;
  xmlParserCtxtPtr ctxt = NULL;
  dom_doc_propsptr doc_props;
  dom_object *intern;
  php_libxml_ref_obj *document = NULL;
  int validate, recover, resolve_externals, keep_blanks, substitute_ent;
  int resolved_path_len;
  int old_error_reporting = 0;
  char *directory = NULL, resolved_path[MAXPATHLEN];

  if (id != NULL) {
    intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
    document = intern->document;
  }

  doc_props = dom_get_doc_props(document);
  validate = doc_props->validateonparse;
  resolve_externals = doc_props->resolveexternals;
  keep_blanks = doc_props->preservewhitespace;
  substitute_ent = doc_props->substituteentities;
  recover = doc_props->recover;

  if (document == NULL) {
    efree(doc_props);
  }

  xmlInitParser();

  if (mode == DOM_LOAD_FILE) {
    char *file_dest =
        _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
    if (file_dest) {
      ctxt = xmlCreateFileParserCtxt(file_dest);
    }

  } else {
    ctxt = xmlCreateMemoryParserCtxt(source, source_len);
  }

  if (ctxt == NULL) {
    return (NULL);
  }

  /* If loading from memory, we need to set the base directory for the document
   */
  if (mode != DOM_LOAD_FILE) {
#if HAVE_GETCWD
    directory = VCWD_GETCWD(resolved_path, MAXPATHLEN);
#elif HAVE_GETWD
    directory = VCWD_GETWD(resolved_path);
#endif
    if (directory) {
      if (ctxt->directory != NULL) {
        xmlFree((char *)ctxt->directory);
      }
      resolved_path_len = strlen(resolved_path);
      if (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {
        resolved_path[resolved_path_len] = DEFAULT_SLASH;
        resolved_path[++resolved_path_len] = '\0';
      }
      ctxt->directory = (char *)xmlCanonicPath((const xmlChar *)resolved_path);
    }
  }

  ctxt->vctxt.error = php_libxml_ctx_error;
  ctxt->vctxt.warning = php_libxml_ctx_warning;

  if (ctxt->sax != NULL) {
    ctxt->sax->error = php_libxml_ctx_error;
    ctxt->sax->warning = php_libxml_ctx_warning;
  }

  if (validate && !(options & XML_PARSE_DTDVALID)) {
    options |= XML_PARSE_DTDVALID;
  }
  if (resolve_externals && !(options & XML_PARSE_DTDATTR)) {
    options |= XML_PARSE_DTDATTR;
  }
  if (substitute_ent && !(options & XML_PARSE_NOENT)) {
    options |= XML_PARSE_NOENT;
  }
  if (keep_blanks == 0 && !(options & XML_PARSE_NOBLANKS)) {
    options |= XML_PARSE_NOBLANKS;
  }

  xmlCtxtUseOptions(ctxt, options);

  ctxt->recovery = recover;
  if (recover) {
    old_error_reporting = EG(error_reporting);
    EG(error_reporting) = old_error_reporting | E_WARNING;
  }

  xmlParseDocument(ctxt);

  if (ctxt->wellFormed || recover) {
    ret = ctxt->myDoc;
    if (ctxt->recovery) {
      EG(error_reporting) = old_error_reporting;
    }
    /* If loading from memory, set the base reference uri for the document */
    if (ret && ret->URL == NULL && ctxt->directory != NULL) {
      ret->URL = xmlStrdup(ctxt->directory);
    }
  } else {
    ret = NULL;
    xmlFreeDoc(ctxt->myDoc);
    ctxt->myDoc = NULL;
  }

  xmlFreeParserCtxt(ctxt);

  return (ret);
}
/* }}} */

/* {{{ static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) */
static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) {
  zval *id, *rv = NULL;
  xmlDoc *docp = NULL, *newdoc;
  dom_doc_propsptr doc_prop;
  dom_object *intern;
  char *source;
  int source_len, refcount, ret;
  long options = 0;

  id = getThis();
  if (id != NULL &&
      !instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
    id = NULL;
  }

  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &source,
                            &source_len, &options) == FAILURE) {
    return;
  }

  if (!source_len) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Empty string supplied as input");
    RETURN_FALSE;
  }

  newdoc = dom_document_parser(id, mode, source, source_len, options TSRMLS_CC);

  if (!newdoc)
    RETURN_FALSE;

  if (id != NULL) {
    intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
    if (intern != NULL) {
      docp = (xmlDocPtr)dom_object_get_node(intern);
      doc_prop = NULL;
      if (docp != NULL) {
        php_libxml_decrement_node_ptr(
            (php_libxml_node_object *)intern TSRMLS_CC);
        doc_prop = intern->document->doc_props;
        intern->document->doc_props = NULL;
        refcount = php_libxml_decrement_doc_ref(
            (php_libxml_node_object *)intern TSRMLS_CC);
        if (refcount != 0) {
          docp->_private = NULL;
        }
      }
      intern->document = NULL;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       newdoc TSRMLS_CC) == -1) {
        RETURN_FALSE;
      }
      intern->document->doc_props = doc_prop;
    }

    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

    RETURN_TRUE;
  } else {
    DOM_RET_OBJ(rv, (xmlNodePtr)newdoc, &ret, NULL);
  }
}
/* }}} end dom_parser_document */

/* {{{ proto DOMNode dom_document_load(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-load
Since: DOM Level 3
*/
PHP_METHOD(domdocument, load) {
  dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load */

/* {{{ proto DOMNode dom_document_loadxml(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-loadXML
Since: DOM Level 3
*/
PHP_METHOD(domdocument, loadXML) {
  dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_loadxml */

/* {{{ proto int dom_document_save(string file);
Convenience method to save to file
*/
PHP_FUNCTION(dom_document_save) {
  zval *id;
  xmlDoc *docp;
  int file_len = 0, bytes, format, saveempty = 0;
  dom_object *intern;
  dom_doc_propsptr doc_props;
  char *file;
  long options = 0;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os|l",
                                   &id, dom_document_class_entry, &file,
                                   &file_len, &options) == FAILURE) {
    return;
  }

  if (file_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  /* encoding handled by property on doc */

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;
  if (options & LIBXML_SAVE_NOEMPTYTAG) {
    saveempty = xmlSaveNoEmptyTags;
    xmlSaveNoEmptyTags = 1;
  }
  bytes = xmlSaveFormatFileEnc(file, docp, NULL, format);
  if (options & LIBXML_SAVE_NOEMPTYTAG) {
    xmlSaveNoEmptyTags = saveempty;
  }
  if (bytes == -1) {
    RETURN_FALSE;
  }
  RETURN_LONG(bytes);
}
/* }}} end dom_document_save */

/* {{{ proto string dom_document_savexml([node n]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-saveXML
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_savexml) {
  zval *id, *nodep = NULL;
  xmlDoc *docp;
  xmlNode *node;
  xmlBufferPtr buf;
  xmlChar *mem;
  dom_object *intern, *nodeobj;
  dom_doc_propsptr doc_props;
  int size, format, saveempty = 0;
  long options = 0;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(),
                                   "O|O!l", &id, dom_document_class_entry,
                                   &nodep, dom_node_class_entry,
                                   &options) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;

  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      saveempty = xmlSaveNoEmptyTags;
      xmlSaveNoEmptyTags = 1;
    }
    xmlNodeDump(buf, docp, node, 0, format);
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      xmlSaveNoEmptyTags = saveempty;
    }
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      xmlBufferFree(buf);
      RETURN_FALSE;
    }
    RETVAL_STRING(mem, 1);
    xmlBufferFree(buf);
  } else {
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      saveempty = xmlSaveNoEmptyTags;
      xmlSaveNoEmptyTags = 1;
    }
    /* Encoding is handled from the encoding property set on the document */
    xmlDocDumpFormatMemory(docp, &mem, &size, format);
    if (options & LIBXML_SAVE_NOEMPTYTAG) {
      xmlSaveNoEmptyTags = saveempty;
    }
    if (!size) {
      RETURN_FALSE;
    }
    RETVAL_STRINGL(mem, size, 1);
    xmlFree(mem);
  }
}
/* }}} end dom_document_savexml */

static xmlNodePtr php_dom_free_xinclude_node(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
  xmlNodePtr xincnode;

  xincnode = cur;
  cur = cur->next;
  xmlUnlinkNode(xincnode);
  php_libxml_node_free_resource(xincnode TSRMLS_CC);

  return cur;
}
/* }}} */

static void php_dom_remove_xinclude_nodes(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
  while (cur) {
    if (cur->type == XML_XINCLUDE_START) {
      cur = php_dom_free_xinclude_node(cur TSRMLS_CC);

      /* XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START */
      while (cur && cur->type != XML_XINCLUDE_END) {
        /* remove xinclude processing nodes from recursive xincludes */
        if (cur->type == XML_ELEMENT_NODE) {
          php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
        }
        cur = cur->next;
      }

      if (cur && cur->type == XML_XINCLUDE_END) {
        cur = php_dom_free_xinclude_node(cur TSRMLS_CC);
      }
    } else {
      if (cur->type == XML_ELEMENT_NODE) {
        php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
      }
      cur = cur->next;
    }
  }
}
/* }}} */

/* {{{ proto int dom_document_xinclude([int options])
   Substitutues xincludes in a DomDocument */
PHP_FUNCTION(dom_document_xinclude) {
  zval *id;
  xmlDoc *docp;
  xmlNodePtr root;
  long flags = 0;
  int err;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|l",
                                   &id, dom_document_class_entry,
                                   &flags) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  err = xmlXIncludeProcessFlags(docp, flags);

  /* XML_XINCLUDE_START and XML_XINCLUDE_END nodes need to be removed as these
  are added via xmlXIncludeProcess to mark beginning and ending of xincluded
  document but are not wanted in resulting document - must be done even if err
  as it could fail after having processed some xincludes */
  root = (xmlNodePtr)docp->children;
  while (root && root->type != XML_ELEMENT_NODE &&
         root->type != XML_XINCLUDE_START) {
    root = root->next;
  }
  if (root) {
    php_dom_remove_xinclude_nodes(root TSRMLS_CC);
  }

  if (err) {
    RETVAL_LONG(err);
  } else {
    RETVAL_FALSE;
  }
}
/* }}} */

/* {{{ proto boolean dom_document_validate();
Since: DOM extended
*/
PHP_FUNCTION(dom_document_validate) {
  zval *id;
  xmlDoc *docp;
  dom_object *intern;
  xmlValidCtxt *cvp;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",
                                   &id, dom_document_class_entry) == FAILURE) {
    return;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  cvp = xmlNewValidCtxt();

  cvp->userData = NULL;
  cvp->error = (xmlValidityErrorFunc)php_libxml_error_handler;
  cvp->warning = (xmlValidityErrorFunc)php_libxml_error_handler;

  if (xmlValidateDocument(cvp, docp)) {
    RETVAL_TRUE;
  } else {
    RETVAL_FALSE;
  }

  xmlFreeValidCtxt(cvp);
}
/* }}} */

#if defined(LIBXML_SCHEMAS_ENABLED)
static void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS,
                                          int type) /* {{{ */
{
  zval *id;
  xmlDoc *docp;
  dom_object *intern;
  char *source = NULL, *valid_file = NULL;
  int source_len = 0;
  xmlSchemaParserCtxtPtr parser;
  xmlSchemaPtr sptr;
  xmlSchemaValidCtxtPtr vptr;
  int is_valid;
  char resolved_path[MAXPATHLEN + 1];

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &source,
                                   &source_len) == FAILURE) {
    return;
  }

  if (source_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema source");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  switch (type) {
  case DOM_LOAD_FILE:
    valid_file =
        _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
    if (!valid_file) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema file source");
      RETURN_FALSE;
    }
    parser = xmlSchemaNewParserCtxt(valid_file);
    break;
  case DOM_LOAD_STRING:
    parser = xmlSchemaNewMemParserCtxt(source, source_len);
    /* If loading from memory, we need to set the base directory for the
       document but it is not apparent how to do that for schema's */
    break;
  default:
    return;
  }

  xmlSchemaSetParserErrors(
      parser, (xmlSchemaValidityErrorFunc)php_libxml_error_handler,
      (xmlSchemaValidityWarningFunc)php_libxml_error_handler, parser);
  sptr = xmlSchemaParse(parser);
  xmlSchemaFreeParserCtxt(parser);
  if (!sptr) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema");
    RETURN_FALSE;
  }

  docp = (xmlDocPtr)dom_object_get_node(intern);

  vptr = xmlSchemaNewValidCtxt(sptr);
  if (!vptr) {
    xmlSchemaFree(sptr);
    php_error(E_ERROR, "Invalid Schema Validation Context");
    RETURN_FALSE;
  }

  xmlSchemaSetValidErrors(vptr, php_libxml_error_handler,
                          php_libxml_error_handler, vptr);
  is_valid = xmlSchemaValidateDoc(vptr, docp);
  xmlSchemaFree(sptr);
  xmlSchemaFreeValidCtxt(vptr);

  if (is_valid == 0) {
    RETURN_TRUE;
  } else {
    RETURN_FALSE;
  }
}
/* }}} */

/* {{{ proto boolean dom_document_schema_validate_file(string filename); */
PHP_FUNCTION(dom_document_schema_validate_file) {
  _dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                DOM_LOAD_FILE);
}
/* }}} end dom_document_schema_validate_file */

/* {{{ proto boolean dom_document_schema_validate(string source); */
PHP_FUNCTION(dom_document_schema_validate_xml) {
  _dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                DOM_LOAD_STRING);
}
/* }}} end dom_document_schema_validate */

static void _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAMETERS,
                                           int type) /* {{{ */
{
  zval *id;
  xmlDoc *docp;
  dom_object *intern;
  char *source = NULL, *valid_file = NULL;
  int source_len = 0;
  xmlRelaxNGParserCtxtPtr parser;
  xmlRelaxNGPtr sptr;
  xmlRelaxNGValidCtxtPtr vptr;
  int is_valid;
  char resolved_path[MAXPATHLEN + 1];

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &source,
                                   &source_len) == FAILURE) {
    return;
  }

  if (source_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Schema source");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  switch (type) {
  case DOM_LOAD_FILE:
    valid_file =
        _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
    if (!valid_file) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING,
                       "Invalid RelaxNG file source");
      RETURN_FALSE;
    }
    parser = xmlRelaxNGNewParserCtxt(valid_file);
    break;
  case DOM_LOAD_STRING:
    parser = xmlRelaxNGNewMemParserCtxt(source, source_len);
    /* If loading from memory, we need to set the base directory for the
       document but it is not apparent how to do that for schema's */
    break;
  default:
    return;
  }

  xmlRelaxNGSetParserErrors(
      parser, (xmlRelaxNGValidityErrorFunc)php_libxml_error_handler,
      (xmlRelaxNGValidityWarningFunc)php_libxml_error_handler, parser);
  sptr = xmlRelaxNGParse(parser);
  xmlRelaxNGFreeParserCtxt(parser);
  if (!sptr) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid RelaxNG");
    RETURN_FALSE;
  }

  docp = (xmlDocPtr)dom_object_get_node(intern);

  vptr = xmlRelaxNGNewValidCtxt(sptr);
  if (!vptr) {
    xmlRelaxNGFree(sptr);
    php_error(E_ERROR, "Invalid RelaxNG Validation Context");
    RETURN_FALSE;
  }

  xmlRelaxNGSetValidErrors(vptr, php_libxml_error_handler,
                           php_libxml_error_handler, vptr);
  is_valid = xmlRelaxNGValidateDoc(vptr, docp);
  xmlRelaxNGFree(sptr);
  xmlRelaxNGFreeValidCtxt(vptr);

  if (is_valid == 0) {
    RETURN_TRUE;
  } else {
    RETURN_FALSE;
  }
}
/* }}} */

/* {{{ proto boolean dom_document_relaxNG_validate_file(string filename); */
PHP_FUNCTION(dom_document_relaxNG_validate_file) {
  _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                 DOM_LOAD_FILE);
}
/* }}} end dom_document_relaxNG_validate_file */

/* {{{ proto boolean dom_document_relaxNG_validate_xml(string source); */
PHP_FUNCTION(dom_document_relaxNG_validate_xml) {
  _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU,
                                 DOM_LOAD_STRING);
}
/* }}} end dom_document_relaxNG_validate_xml */

#endif

#if defined(LIBXML_HTML_ENABLED)

static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
{
  zval *id, *rv = NULL;
  xmlDoc *docp = NULL, *newdoc;
  dom_object *intern;
  dom_doc_propsptr doc_prop;
  char *source;
  int source_len, refcount, ret;
  htmlParserCtxtPtr ctxt;

  id = getThis();

  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &source,
                            &source_len) == FAILURE) {
    return;
  }

  if (!source_len) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING,
                     "Empty string supplied as input");
    RETURN_FALSE;
  }

  if (mode == DOM_LOAD_FILE) {
    ctxt = htmlCreateFileParserCtxt(source, NULL);
  } else {
    source_len = xmlStrlen(source);
    ctxt = htmlCreateMemoryParserCtxt(source, source_len);
  }

  if (!ctxt) {
    RETURN_FALSE;
  }

  ctxt->vctxt.error = php_libxml_ctx_error;
  ctxt->vctxt.warning = php_libxml_ctx_warning;
  if (ctxt->sax != NULL) {
    ctxt->sax->error = php_libxml_ctx_error;
    ctxt->sax->warning = php_libxml_ctx_warning;
  }
  htmlParseDocument(ctxt);
  newdoc = ctxt->myDoc;
  htmlFreeParserCtxt(ctxt);

  if (!newdoc)
    RETURN_FALSE;

  if (id != NULL &&
      instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
    intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
    if (intern != NULL) {
      docp = (xmlDocPtr)dom_object_get_node(intern);
      doc_prop = NULL;
      if (docp != NULL) {
        php_libxml_decrement_node_ptr(
            (php_libxml_node_object *)intern TSRMLS_CC);
        doc_prop = intern->document->doc_props;
        intern->document->doc_props = NULL;
        refcount = php_libxml_decrement_doc_ref(
            (php_libxml_node_object *)intern TSRMLS_CC);
        if (refcount != 0) {
          docp->_private = NULL;
        }
      }
      intern->document = NULL;
      if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern,
                                       newdoc TSRMLS_CC) == -1) {
        RETURN_FALSE;
      }
      intern->document->doc_props = doc_prop;
    }

    php_libxml_increment_node_ptr((php_libxml_node_object *)intern,
                                  (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

    RETURN_TRUE;
  } else {
    DOM_RET_OBJ(rv, (xmlNodePtr)newdoc, &ret, NULL);
  }
}
/* }}} */

/* {{{ proto DOMNode dom_document_load_html_file(string source);
Since: DOM extended
*/
PHP_METHOD(domdocument, loadHTMLFile) {
  dom_load_html(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load_html_file */

/* {{{ proto DOMNode dom_document_load_html(string source);
Since: DOM extended
*/
PHP_METHOD(domdocument, loadHTML) {
  dom_load_html(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_load_html */

/* {{{ proto int dom_document_save_html_file(string file);
Convenience method to save to file as html
*/
PHP_FUNCTION(dom_document_save_html_file) {
  zval *id;
  xmlDoc *docp;
  int file_len, bytes, format;
  dom_object *intern;
  dom_doc_propsptr doc_props;
  char *file;
  const char *encoding;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",
                                   &id, dom_document_class_entry, &file,
                                   &file_len) == FAILURE) {
    return;
  }

  if (file_len == 0) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid Filename");
    RETURN_FALSE;
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  encoding = (const char *)htmlGetMetaEncoding(docp);

  doc_props = dom_get_doc_props(intern->document);
  format = doc_props->formatoutput;
  bytes = htmlSaveFileFormat(file, docp, encoding, format);

  if (bytes == -1) {
    RETURN_FALSE;
  }
  RETURN_LONG(bytes);
}
/* }}} end dom_document_save_html_file */

/* {{{ proto string dom_document_save_html();
Convenience method to output as html
*/
PHP_FUNCTION(dom_document_save_html) {
  zval *id, *nodep = NULL;
  xmlDoc *docp;
  xmlNode *node;
  xmlBufferPtr buf;
  dom_object *intern, *nodeobj;
  xmlChar *mem = NULL;
  int size, format;
  dom_doc_propsptr doc_props;

  // prophet generated patch
  switch (__choose("__ID21")) {
  case 0: {
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#ifdef COMPILE_3245
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3246
  case 2: {
    (buf) = xmlBufferCreate();
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3247
  case 3: {
    (doc_props) = dom_get_doc_props(intern->document);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3248
  case 4: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3249
  case 5: {
    (mem) = (xmlChar *)xmlBufferContent(buf);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3250
  case 6: {
    _convert_to_string(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3251
  case 7: {
    _convert_to_string(((nodep)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3252
  case 8: {
    _convert_to_string(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3253
  case 9: {
    _convert_to_string(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3254
  case 10: {
    _efree(((doc_props)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3255
  case 11: {
    _efree(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3256
  case 12: {
    _efree(((nodep)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3257
  case 13: {
    _efree(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3258
  case 14: {
    _efree(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3259
  case 15: {
    _zval_copy_ctor_func((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3260
  case 16: {
    _zval_copy_ctor_func((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3261
  case 17: {
    _zval_copy_ctor_func((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3262
  case 18: {
    _zval_copy_ctor_func((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3263
  case 19: {
    _zval_dtor(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3264
  case 20: {
    _zval_dtor(((nodep)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3265
  case 21: {
    _zval_dtor(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3266
  case 22: {
    _zval_dtor(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3267
  case 23: {
    _zval_dtor_func((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3268
  case 24: {
    _zval_dtor_func((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3269
  case 25: {
    _zval_dtor_func((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3270
  case 26: {
    _zval_dtor_func((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3271
  case 27: {
    _zval_ptr_dtor((&(id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3272
  case 28: {
    _zval_ptr_dtor((&(nodep)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3273
  case 29: {
    _zval_ptr_dtor((&(return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3274
  case 30: {
    _zval_ptr_dtor((&(this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3275
  case 31: {
    buf = xmlBufferCreate();
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3276
  case 32: {
    convert_to_boolean((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3277
  case 33: {
    convert_to_boolean((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3278
  case 34: {
    convert_to_boolean((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3279
  case 35: {
    convert_to_boolean((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3280
  case 36: {
    convert_to_long((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3281
  case 37: {
    convert_to_long((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3282
  case 38: {
    convert_to_long((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3283
  case 39: {
    convert_to_long((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3284
  case 40: {
    doc_props = dom_get_doc_props((intern)->document);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3285
  case 41: {
    doc_props = dom_get_doc_props((nodeobj)->document);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3286
  case 42: {
    doc_props = dom_get_doc_props(intern->document);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3287
  case 43: {
    exit(1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3288
  case 44: {
    format = (doc_props)->formatoutput;
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3289
  case 45: {
    format = doc_props->formatoutput;
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3290
  case 46: {
    gc_remove_zval_from_buffer((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3291
  case 47: {
    gc_remove_zval_from_buffer((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3292
  case 48: {
    gc_remove_zval_from_buffer((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3293
  case 49: {
    gc_remove_zval_from_buffer((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3294
  case 50: {
    gc_zval_check_possible_root(((id)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3295
  case 51: {
    gc_zval_check_possible_root(((nodep)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3296
  case 52: {
    gc_zval_check_possible_root(((return_value)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3297
  case 53: {
    gc_zval_check_possible_root(((this_ptr)));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3298
  case 54: {
    gc_zval_possible_root((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3299
  case 55: {
    gc_zval_possible_root((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3300
  case 56: {
    gc_zval_possible_root((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3301
  case 57: {
    gc_zval_possible_root((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3302
  case 58: {
    htmlDocDumpMemoryFormat((docp), &mem, &size, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3303
  case 59: {
    htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3304
  case 60: {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3305
  case 61: {
    htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3306
  case 62: {
    htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3307
  case 63: {
    htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3308
  case 64: {
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3309
  case 65: {
    i_zval_ptr_dtor((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3310
  case 66: {
    i_zval_ptr_dtor((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3311
  case 67: {
    i_zval_ptr_dtor((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3312
  case 68: {
    i_zval_ptr_dtor((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3313
  case 69: {
    if (!__is_neg("21-69", 3, (int *){ht, format, size}, 0, 0, 13,
                  (void **){this_ptr, id, nodep, dom_node_class_entry,
                            dom_document_class_entry, return_value, docp,
                            intern, doc_props, node, nodeobj, buf, mem},
                  0, 0, 16, "ht", "this_ptr", "id", "nodep",
                  "dom_node_class_entry", "dom_document_class_entry",
                  "return_value", "docp", "intern", "doc_props", "format",
                  "node", "nodeobj", "buf", "mem", "size") &&
        (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                      dom_document_class_entry, &nodep,
                                      dom_node_class_entry) == -1)) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3314
  case 70: {
    if (!__is_neg("21-70", 3, (int *){ht, format, size}, 0, 0, 13,
                  (void **){this_ptr, id, nodep, dom_node_class_entry,
                            dom_document_class_entry, return_value, docp,
                            intern, doc_props, node, nodeobj, buf, mem},
                  0, 0, 16, "ht", "this_ptr", "id", "nodep",
                  "dom_node_class_entry", "dom_document_class_entry",
                  "return_value", "docp", "intern", "doc_props", "format",
                  "node", "nodeobj", "buf", "mem", "size"))
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }

    break;
  }
#endif
#ifdef COMPILE_3315
  case 71: {
    if ((zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                      dom_document_class_entry, &nodep,
                                      dom_node_class_entry) == -1) &&
        !__is_neg("21-71", 3, (int *){ht, format, size}, 0, 0, 13,
                  (void **){id, nodep, dom_node_class_entry,
                            dom_document_class_entry, this_ptr, return_value,
                            docp, intern, doc_props, node, nodeobj, buf, mem},
                  0, 0, 16, "id", "nodep", "dom_node_class_entry",
                  "dom_document_class_entry", "ht", "this_ptr", "return_value",
                  "docp", "intern", "doc_props", "format", "node", "nodeobj",
                  "buf", "mem", "size")) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3316
  case 72: {
    if ((zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                      dom_document_class_entry, &nodep,
                                      dom_node_class_entry) == -1) ||
        __is_neg("21-72", 3, (int *){ht, format, size}, 0, 0, 13,
                 (void **){id, nodep, dom_node_class_entry,
                           dom_document_class_entry, this_ptr, return_value,
                           docp, intern, doc_props, node, nodeobj, buf, mem},
                 0, 0, 16, "id", "nodep", "dom_node_class_entry",
                 "dom_document_class_entry", "ht", "this_ptr", "return_value",
                 "docp", "intern", "doc_props", "format", "node", "nodeobj",
                 "buf", "mem", "size")) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3317
  case 73: {
    if (__is_neg("21-73", 3, (int *){ht, format, size}, 0, 0, 13,
                 (void **){this_ptr, id, nodep, dom_node_class_entry,
                           dom_document_class_entry, return_value, docp, intern,
                           doc_props, node, nodeobj, buf, mem},
                 0, 0, 16, "ht", "this_ptr", "id", "nodep",
                 "dom_node_class_entry", "dom_document_class_entry",
                 "return_value", "docp", "intern", "doc_props", "format",
                 "node", "nodeobj", "buf", "mem", "size"))
      return;
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3318
  case 74: {
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3319
  case 75: {
    mem = (xmlChar *)xmlBufferContent(buf);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3320
  case 76: {
    php_dom_create_implementation((return_value_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3321
  case 77: {
    php_dom_create_interator((id), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3322
  case 78: {
    php_dom_create_interator((nodep), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3323
  case 79: {
    php_dom_create_interator((return_value), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3324
  case 80: {
    php_dom_create_interator((this_ptr), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3325
  case 81: {
    php_dom_remove_xinclude_nodes((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3326
  case 82: {
    php_dom_remove_xinclude_nodes((node)->children);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3327
  case 83: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3328
  case 84: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3329
  case 85: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3330
  case 86: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3331
  case 87: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3332
  case 88: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3333
  case 89: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3334
  case 90: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3335
  case 91: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3336
  case 92: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3337
  case 93: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3338
  case 94: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3339
  case 95: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3340
  case 96: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3341
  case 97: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3342
  case 98: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3343
  case 99: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3344
  case 100: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3345
  case 101: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3346
  case 102: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3347
  case 103: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3348
  case 104: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3349
  case 105: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3350
  case 106: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3351
  case 107: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3352
  case 108: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3353
  case 109: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3354
  case 110: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3355
  case 111: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3356
  case 112: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3357
  case 113: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3358
  case 114: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3359
  case 115: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3360
  case 116: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3361
  case 117: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3362
  case 118: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3363
  case 119: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3364
  case 120: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3365
  case 121: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3366
  case 122: {
    php_dom_throw_error((PHP_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3367
  case 123: {
    php_dom_throw_error((PHP_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3368
  case 124: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3369
  case 125: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3370
  case 126: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3371
  case 127: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3372
  case 128: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3373
  case 129: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3374
  case 130: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3375
  case 131: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3376
  case 132: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3377
  case 133: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3378
  case 134: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3379
  case 135: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((nodeobj)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3380
  case 136: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3381
  case 137: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3382
  case 138: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3383
  case 139: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((nodeobj)->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3384
  case 140: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error(intern->document));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3385
  case 141: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3386
  case 142: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3387
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3388
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3389
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (nodeobj)->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3390
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3391
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      nodeobj->std.ce->name);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3392
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3393
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3394
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3395
  case 151: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3396
  case 152: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3397
  case 153: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3398
  case 154: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3399
  case 155: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3400
  case 156: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3401
  case 157: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3402
  case 158: {
    php_libxml_node_free_resource((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3403
  case 159: {
    xmlBufferFree((buf));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3404
  case 160: {
    xmlBufferFree(buf);
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3405
  case 161: {
    xmlFreeNode((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3406
  case 162: {
    xmlInitParser();
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3407
  case 163: {
    xmlUnlinkNode((node));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3408
  case 164: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3409
  case 165: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3410
  case 166: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3411
  case 167: {
    zval_unset_isref_p((id));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3412
  case 168: {
    zval_unset_isref_p((nodep));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3413
  case 169: {
    zval_unset_isref_p((return_value));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
#ifdef COMPILE_3414
  case 170: {
    zval_unset_isref_p((this_ptr));
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }

    break;
  }
#endif
  }

  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

  // prophet generated patch
  switch (__choose("__ID22")) {
  case 0: {
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#ifdef COMPILE_3415
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3416
  case 2: {
    (buf) = xmlBufferCreate();
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3417
  case 3: {
    (doc_props) = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3418
  case 4: {
    (doc_props) = dom_get_doc_props(intern->document);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3419
  case 5: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3420
  case 6: {
    (mem) = (xmlChar *)xmlBufferContent(buf);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3421
  case 7: {
    _convert_to_string(((id)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3422
  case 8: {
    _convert_to_string(((nodep)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3423
  case 9: {
    _convert_to_string(((return_value)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3424
  case 10: {
    _convert_to_string(((this_ptr)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3425
  case 11: {
    _efree(((doc_props)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3426
  case 12: {
    _efree(((id)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3427
  case 13: {
    _efree(((nodep)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3428
  case 14: {
    _efree(((return_value)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3429
  case 15: {
    _efree(((this_ptr)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3430
  case 16: {
    _zval_copy_ctor_func((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3431
  case 17: {
    _zval_copy_ctor_func((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3432
  case 18: {
    _zval_copy_ctor_func((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3433
  case 19: {
    _zval_copy_ctor_func((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3434
  case 20: {
    _zval_dtor(((id)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3435
  case 21: {
    _zval_dtor(((nodep)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3436
  case 22: {
    _zval_dtor(((return_value)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3437
  case 23: {
    _zval_dtor(((this_ptr)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3438
  case 24: {
    _zval_dtor_func((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3439
  case 25: {
    _zval_dtor_func((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3440
  case 26: {
    _zval_dtor_func((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3441
  case 27: {
    _zval_dtor_func((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3442
  case 28: {
    _zval_ptr_dtor((&(id)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3443
  case 29: {
    _zval_ptr_dtor((&(nodep)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3444
  case 30: {
    _zval_ptr_dtor((&(return_value)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3445
  case 31: {
    _zval_ptr_dtor((&(this_ptr)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3446
  case 32: {
    buf = xmlBufferCreate();
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3447
  case 33: {
    convert_to_boolean((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3448
  case 34: {
    convert_to_boolean((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3449
  case 35: {
    convert_to_boolean((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3450
  case 36: {
    convert_to_boolean((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3451
  case 37: {
    convert_to_long((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3452
  case 38: {
    convert_to_long((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3453
  case 39: {
    convert_to_long((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3454
  case 40: {
    convert_to_long((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3455
  case 41: {
    doc_props = dom_get_doc_props((intern)->document);

    break;
  }
#endif
#ifdef COMPILE_3456
  case 42: {
    doc_props = dom_get_doc_props((intern)->document);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3457
  case 43: {
    doc_props = dom_get_doc_props((nodeobj)->document);

    break;
  }
#endif
#ifdef COMPILE_3458
  case 44: {
    doc_props = dom_get_doc_props((nodeobj)->document);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3459
  case 45: {
    doc_props = dom_get_doc_props(intern->document);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3460
  case 46: {
    exit(1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3461
  case 47: {
    format = (doc_props)->formatoutput;
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3462
  case 48: {
    format = doc_props->formatoutput;
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3463
  case 49: {
    gc_remove_zval_from_buffer((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3464
  case 50: {
    gc_remove_zval_from_buffer((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3465
  case 51: {
    gc_remove_zval_from_buffer((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3466
  case 52: {
    gc_remove_zval_from_buffer((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3467
  case 53: {
    gc_zval_check_possible_root(((id)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3468
  case 54: {
    gc_zval_check_possible_root(((nodep)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3469
  case 55: {
    gc_zval_check_possible_root(((return_value)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3470
  case 56: {
    gc_zval_check_possible_root(((this_ptr)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3471
  case 57: {
    gc_zval_possible_root((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3472
  case 58: {
    gc_zval_possible_root((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3473
  case 59: {
    gc_zval_possible_root((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3474
  case 60: {
    gc_zval_possible_root((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3475
  case 61: {
    htmlDocDumpMemoryFormat((docp), &mem, &size, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3476
  case 62: {
    htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3477
  case 63: {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3478
  case 64: {
    htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3479
  case 65: {
    htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3480
  case 66: {
    htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3481
  case 67: {
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3482
  case 68: {
    i_zval_ptr_dtor((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3483
  case 69: {
    i_zval_ptr_dtor((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3484
  case 70: {
    i_zval_ptr_dtor((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3485
  case 71: {
    i_zval_ptr_dtor((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3486
  case 72: {
    if (!__is_neg("22-72", 3, (int *){format, ht, size}, 0, 0, 13,
                  (void **){intern, doc_props, return_value, id, docp, nodep,
                            node, nodeobj, dom_node_class_entry,
                            dom_document_class_entry, this_ptr, buf, mem},
                  0, 0, 16, "intern", "doc_props", "format", "return_value",
                  "id", "docp", "nodep", "node", "nodeobj",
                  "dom_node_class_entry", "dom_document_class_entry", "ht",
                  "this_ptr", "buf", "mem", "size"))
      doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3487
  case 73: {
    if (__is_neg("22-73", 3, (int *){format, ht, size}, 0, 0, 13,
                 (void **){intern, doc_props, return_value, id, docp, nodep,
                           node, nodeobj, dom_node_class_entry,
                           dom_document_class_entry, this_ptr, buf, mem},
                 0, 0, 16, "intern", "doc_props", "format", "return_value",
                 "id", "docp", "nodep", "node", "nodeobj",
                 "dom_node_class_entry", "dom_document_class_entry", "ht",
                 "this_ptr", "buf", "mem", "size"))
      return;
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3488
  case 74: {
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3489
  case 75: {
    mem = (xmlChar *)xmlBufferContent(buf);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3490
  case 76: {
    memset(doc_props, 0, sizeof(*(doc_props)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3491
  case 77: {
    memset(intern, 0, sizeof(*(intern)));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3492
  case 78: {
    php_dom_create_implementation((return_value_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3493
  case 79: {
    php_dom_create_interator((id), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3494
  case 80: {
    php_dom_create_interator((nodep), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3495
  case 81: {
    php_dom_create_interator((return_value), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3496
  case 82: {
    php_dom_create_interator((this_ptr), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3497
  case 83: {
    php_dom_remove_xinclude_nodes((node));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3498
  case 84: {
    php_dom_remove_xinclude_nodes((node)->children);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3499
  case 85: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3500
  case 86: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3501
  case 87: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3502
  case 88: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3503
  case 89: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3504
  case 90: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3505
  case 91: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3506
  case 92: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3507
  case 93: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3508
  case 94: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3509
  case 95: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3510
  case 96: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3511
  case 97: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3512
  case 98: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3513
  case 99: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3514
  case 100: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3515
  case 101: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3516
  case 102: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3517
  case 103: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3518
  case 104: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3519
  case 105: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3520
  case 106: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3521
  case 107: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3522
  case 108: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3523
  case 109: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3524
  case 110: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3525
  case 111: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3526
  case 112: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3527
  case 113: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3528
  case 114: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3529
  case 115: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3530
  case 116: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3531
  case 117: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3532
  case 118: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3533
  case 119: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3534
  case 120: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3535
  case 121: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3536
  case 122: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3537
  case 123: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3538
  case 124: {
    php_dom_throw_error((PHP_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3539
  case 125: {
    php_dom_throw_error((PHP_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3540
  case 126: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3541
  case 127: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3542
  case 128: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3543
  case 129: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3544
  case 130: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3545
  case 131: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3546
  case 132: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3547
  case 133: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3548
  case 134: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3549
  case 135: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3550
  case 136: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3551
  case 137: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((nodeobj)->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3552
  case 138: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3553
  case 139: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3554
  case 140: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3555
  case 141: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((nodeobj)->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3556
  case 142: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error(intern->document));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3557
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3558
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3559
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3560
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3561
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (nodeobj)->std.ce->name);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3562
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3563
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      nodeobj->std.ce->name);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3564
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3565
  case 151: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3566
  case 152: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3567
  case 153: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3568
  case 154: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3569
  case 155: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3570
  case 156: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3571
  case 157: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3572
  case 158: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3573
  case 159: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3574
  case 160: {
    php_libxml_node_free_resource((node));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3575
  case 161: {
    xmlBufferFree((buf));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3576
  case 162: {
    xmlBufferFree(buf);
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3577
  case 163: {
    xmlFreeNode((node));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3578
  case 164: {
    xmlInitParser();
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3579
  case 165: {
    xmlUnlinkNode((node));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3580
  case 166: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3581
  case 167: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3582
  case 168: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3583
  case 169: {
    zval_unset_isref_p((id));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3584
  case 170: {
    zval_unset_isref_p((nodep));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3585
  case 171: {
    zval_unset_isref_p((return_value));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
#ifdef COMPILE_3586
  case 172: {
    zval_unset_isref_p((this_ptr));
    doc_props = dom_get_doc_props(intern->document);

    break;
  }
#endif
  }
  // prophet generated patch
  switch (__choose("__ID23")) {
  case 0: {
    format = doc_props->formatoutput;

    break;
  }
#ifdef COMPILE_3587
  case 1: {
    (*(__xmlSaveNoEmptyTags())) = 1;
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3588
  case 2: {
    (buf) = xmlBufferCreate();
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3589
  case 3: {
    (doc_props) = dom_get_doc_props(intern->document);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3590
  case 4: {
    (executor_globals.argument_stack) =
        zend_vm_stack_new_page(((16 * 1024) - 16));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3591
  case 5: {
    (mem) = (xmlChar *)xmlBufferContent(buf);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3592
  case 6: {
    _convert_to_string(((id)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3593
  case 7: {
    _convert_to_string(((nodep)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3594
  case 8: {
    _convert_to_string(((return_value)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3595
  case 9: {
    _convert_to_string(((this_ptr)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3596
  case 10: {
    _efree(((doc_props)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3597
  case 11: {
    _efree(((id)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3598
  case 12: {
    _efree(((nodep)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3599
  case 13: {
    _efree(((return_value)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3600
  case 14: {
    _efree(((this_ptr)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3601
  case 15: {
    _zval_copy_ctor_func((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3602
  case 16: {
    _zval_copy_ctor_func((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3603
  case 17: {
    _zval_copy_ctor_func((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3604
  case 18: {
    _zval_copy_ctor_func((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3605
  case 19: {
    _zval_dtor(((id)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3606
  case 20: {
    _zval_dtor(((nodep)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3607
  case 21: {
    _zval_dtor(((return_value)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3608
  case 22: {
    _zval_dtor(((this_ptr)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3609
  case 23: {
    _zval_dtor_func((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3610
  case 24: {
    _zval_dtor_func((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3611
  case 25: {
    _zval_dtor_func((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3612
  case 26: {
    _zval_dtor_func((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3613
  case 27: {
    _zval_ptr_dtor((&(id)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3614
  case 28: {
    _zval_ptr_dtor((&(nodep)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3615
  case 29: {
    _zval_ptr_dtor((&(return_value)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3616
  case 30: {
    _zval_ptr_dtor((&(this_ptr)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3617
  case 31: {
    buf = xmlBufferCreate();
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3618
  case 32: {
    convert_to_boolean((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3619
  case 33: {
    convert_to_boolean((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3620
  case 34: {
    convert_to_boolean((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3621
  case 35: {
    convert_to_boolean((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3622
  case 36: {
    convert_to_long((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3623
  case 37: {
    convert_to_long((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3624
  case 38: {
    convert_to_long((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3625
  case 39: {
    convert_to_long((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3626
  case 40: {
    doc_props = dom_get_doc_props((intern)->document);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3627
  case 41: {
    doc_props = dom_get_doc_props((nodeobj)->document);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3628
  case 42: {
    doc_props = dom_get_doc_props(intern->document);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3629
  case 43: {
    exit(1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3630
  case 44: {
    format = (doc_props)->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3631
  case 45: {
    format = (doc_props)->formatoutput;
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3632
  case 46: {
    format = doc_props->formatoutput;
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3633
  case 47: {
    gc_remove_zval_from_buffer((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3634
  case 48: {
    gc_remove_zval_from_buffer((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3635
  case 49: {
    gc_remove_zval_from_buffer((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3636
  case 50: {
    gc_remove_zval_from_buffer((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3637
  case 51: {
    gc_zval_check_possible_root(((id)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3638
  case 52: {
    gc_zval_check_possible_root(((nodep)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3639
  case 53: {
    gc_zval_check_possible_root(((return_value)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3640
  case 54: {
    gc_zval_check_possible_root(((this_ptr)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3641
  case 55: {
    gc_zval_possible_root((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3642
  case 56: {
    gc_zval_possible_root((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3643
  case 57: {
    gc_zval_possible_root((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3644
  case 58: {
    gc_zval_possible_root((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3645
  case 59: {
    htmlDocDumpMemoryFormat((docp), &mem, &size, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3646
  case 60: {
    htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3647
  case 61: {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3648
  case 62: {
    htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3649
  case 63: {
    htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3650
  case 64: {
    htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3651
  case 65: {
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3652
  case 66: {
    i_zval_ptr_dtor((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3653
  case 67: {
    i_zval_ptr_dtor((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3654
  case 68: {
    i_zval_ptr_dtor((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3655
  case 69: {
    i_zval_ptr_dtor((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3656
  case 70: {
    if (!__is_neg("23-70", 3, (int *){format, ht, size}, 0, 0, 13,
                  (void **){doc_props, intern, nodep, return_value, id, docp,
                            node, nodeobj, dom_node_class_entry,
                            dom_document_class_entry, this_ptr, buf, mem},
                  0, 0, 16, "format", "doc_props", "intern", "nodep",
                  "return_value", "id", "docp", "node", "nodeobj",
                  "dom_node_class_entry", "dom_document_class_entry", "ht",
                  "this_ptr", "buf", "mem", "size"))
      format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3657
  case 71: {
    if (__is_neg("23-71", 3, (int *){format, ht, size}, 0, 0, 13,
                 (void **){doc_props, intern, nodep, return_value, id, docp,
                           node, nodeobj, dom_node_class_entry,
                           dom_document_class_entry, this_ptr, buf, mem},
                 0, 0, 16, "format", "doc_props", "intern", "nodep",
                 "return_value", "id", "docp", "node", "nodeobj",
                 "dom_node_class_entry", "dom_document_class_entry", "ht",
                 "this_ptr", "buf", "mem", "size"))
      return;
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3658
  case 72: {
    if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                     dom_document_class_entry, &nodep,
                                     dom_node_class_entry) == -1) {
      return;
    }
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3659
  case 73: {
    mem = (xmlChar *)xmlBufferContent(buf);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3660
  case 74: {
    memset(doc_props, 0, sizeof(*(doc_props)));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3661
  case 75: {
    php_dom_create_implementation((return_value_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3662
  case 76: {
    php_dom_create_interator((id), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3663
  case 77: {
    php_dom_create_interator((nodep), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3664
  case 78: {
    php_dom_create_interator((return_value), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3665
  case 79: {
    php_dom_create_interator((this_ptr), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3666
  case 80: {
    php_dom_remove_xinclude_nodes((node));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3667
  case 81: {
    php_dom_remove_xinclude_nodes((node)->children);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3668
  case 82: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3669
  case 83: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3670
  case 84: {
    php_dom_throw_error((DOMSTRING_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3671
  case 85: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3672
  case 86: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3673
  case 87: {
    php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3674
  case 88: {
    php_dom_throw_error((INDEX_SIZE_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3675
  case 89: {
    php_dom_throw_error((INDEX_SIZE_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3676
  case 90: {
    php_dom_throw_error((INDEX_SIZE_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3677
  case 91: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3678
  case 92: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3679
  case 93: {
    php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3680
  case 94: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3681
  case 95: {
    php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3682
  case 96: {
    php_dom_throw_error((INVALID_ACCESS_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3683
  case 97: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3684
  case 98: {
    php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3685
  case 99: {
    php_dom_throw_error((INVALID_CHARACTER_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3686
  case 100: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3687
  case 101: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3688
  case 102: {
    php_dom_throw_error((INVALID_MODIFICATION_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3689
  case 103: {
    php_dom_throw_error((INVALID_STATE_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3690
  case 104: {
    php_dom_throw_error((INVALID_STATE_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3691
  case 105: {
    php_dom_throw_error((INVALID_STATE_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3692
  case 106: {
    php_dom_throw_error((NAMESPACE_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3693
  case 107: {
    php_dom_throw_error((NAMESPACE_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3694
  case 108: {
    php_dom_throw_error((NAMESPACE_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3695
  case 109: {
    php_dom_throw_error((NOT_FOUND_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3696
  case 110: {
    php_dom_throw_error((NOT_FOUND_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3697
  case 111: {
    php_dom_throw_error((NOT_FOUND_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3698
  case 112: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3699
  case 113: {
    php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3700
  case 114: {
    php_dom_throw_error((NOT_SUPPORTED_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3701
  case 115: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3702
  case 116: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3703
  case 117: {
    php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3704
  case 118: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3705
  case 119: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3706
  case 120: {
    php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3707
  case 121: {
    php_dom_throw_error((PHP_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3708
  case 122: {
    php_dom_throw_error((PHP_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3709
  case 123: {
    php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3710
  case 124: {
    php_dom_throw_error((SYNTAX_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3711
  case 125: {
    php_dom_throw_error((SYNTAX_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3712
  case 126: {
    php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3713
  case 127: {
    php_dom_throw_error((VALIDATION_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3714
  case 128: {
    php_dom_throw_error((VALIDATION_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3715
  case 129: {
    php_dom_throw_error((VALIDATION_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3716
  case 130: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3717
  case 131: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3718
  case 132: {
    php_dom_throw_error((WRONG_DOCUMENT_ERR),
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3719
  case 133: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((intern)->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3720
  case 134: {
    php_dom_throw_error(INVALID_CHARACTER_ERR,
                        dom_get_strict_error((nodeobj)->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3721
  case 135: {
    php_dom_throw_error(INVALID_STATE_ERR, 0);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3722
  case 136: {
    php_dom_throw_error(INVALID_STATE_ERR, 1);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3723
  case 137: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((intern)->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3724
  case 138: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error((nodeobj)->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3725
  case 139: {
    php_dom_throw_error(WRONG_DOCUMENT_ERR,
                        dom_get_strict_error(intern->document));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3726
  case 140: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot create required DOM object");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3727
  case 141: {
    php_error_docref0(((void *)0), (1 << 1L),
                      "Cannot import: Node Type Not Supported");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3728
  case 142: {
    php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3729
  case 143: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (intern)->std.ce->name);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3730
  case 144: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      (nodeobj)->std.ce->name);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3731
  case 145: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      intern->std.ce->name);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3732
  case 146: {
    php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                      nodeobj->std.ce->name);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3733
  case 147: {
    php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3734
  case 148: {
    php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3735
  case 149: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3736
  case 150: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3737
  case 151: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3738
  case 152: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3739
  case 153: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3740
  case 154: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3741
  case 155: {
    php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3742
  case 156: {
    php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3743
  case 157: {
    php_libxml_node_free_resource((node));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3744
  case 158: {
    xmlBufferFree((buf));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3745
  case 159: {
    xmlBufferFree(buf);
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3746
  case 160: {
    xmlFreeNode((node));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3747
  case 161: {
    xmlInitParser();
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3748
  case 162: {
    xmlUnlinkNode((node));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3749
  case 163: {
    zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3750
  case 164: {
    zend_error((1 << 0L), "Invalid Schema Validation Context");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3751
  case 165: {
    zend_error((1 << 3L), "A non well formed numeric value encountered");
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3752
  case 166: {
    zval_unset_isref_p((id));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3753
  case 167: {
    zval_unset_isref_p((nodep));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3754
  case 168: {
    zval_unset_isref_p((return_value));
    format = doc_props->formatoutput;

    break;
  }
#endif
#ifdef COMPILE_3755
  case 169: {
    zval_unset_isref_p((this_ptr));
    format = doc_props->formatoutput;

    break;
  }
#endif
  }

  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    // prophet generated patch
    switch (__choose("__ID24")) {
    case 0: {
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#ifdef COMPILE_3756
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3757
    case 2: {
      (buf) = xmlBufferCreate();
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3758
    case 3: {
      (doc_props) = dom_get_doc_props(intern->document);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3759
    case 4: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3760
    case 5: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3761
    case 6: {
      _convert_to_string(((id)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3762
    case 7: {
      _convert_to_string(((nodep)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3763
    case 8: {
      _convert_to_string(((return_value)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3764
    case 9: {
      _convert_to_string(((this_ptr)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3765
    case 10: {
      _efree(((doc_props)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3766
    case 11: {
      _efree(((id)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3767
    case 12: {
      _efree(((nodep)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3768
    case 13: {
      _efree(((return_value)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3769
    case 14: {
      _efree(((this_ptr)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3770
    case 15: {
      _zval_copy_ctor_func((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3771
    case 16: {
      _zval_copy_ctor_func((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3772
    case 17: {
      _zval_copy_ctor_func((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3773
    case 18: {
      _zval_copy_ctor_func((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3774
    case 19: {
      _zval_dtor(((id)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3775
    case 20: {
      _zval_dtor(((nodep)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3776
    case 21: {
      _zval_dtor(((return_value)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3777
    case 22: {
      _zval_dtor(((this_ptr)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3778
    case 23: {
      _zval_dtor_func((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3779
    case 24: {
      _zval_dtor_func((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3780
    case 25: {
      _zval_dtor_func((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3781
    case 26: {
      _zval_dtor_func((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3782
    case 27: {
      _zval_ptr_dtor((&(id)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3783
    case 28: {
      _zval_ptr_dtor((&(nodep)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3784
    case 29: {
      _zval_ptr_dtor((&(return_value)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3785
    case 30: {
      _zval_ptr_dtor((&(this_ptr)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3786
    case 31: {
      buf = xmlBufferCreate();
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3787
    case 32: {
      convert_to_boolean((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3788
    case 33: {
      convert_to_boolean((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3789
    case 34: {
      convert_to_boolean((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3790
    case 35: {
      convert_to_boolean((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3791
    case 36: {
      convert_to_long((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3792
    case 37: {
      convert_to_long((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3793
    case 38: {
      convert_to_long((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3794
    case 39: {
      convert_to_long((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3795
    case 40: {
      doc_props = dom_get_doc_props((intern)->document);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3796
    case 41: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3797
    case 42: {
      doc_props = dom_get_doc_props(intern->document);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3798
    case 43: {
      exit(1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3799
    case 44: {
      format = (doc_props)->formatoutput;
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3800
    case 45: {
      format = doc_props->formatoutput;
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3801
    case 46: {
      gc_remove_zval_from_buffer((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3802
    case 47: {
      gc_remove_zval_from_buffer((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3803
    case 48: {
      gc_remove_zval_from_buffer((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3804
    case 49: {
      gc_remove_zval_from_buffer((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3805
    case 50: {
      gc_zval_check_possible_root(((id)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3806
    case 51: {
      gc_zval_check_possible_root(((nodep)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3807
    case 52: {
      gc_zval_check_possible_root(((return_value)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3808
    case 53: {
      gc_zval_check_possible_root(((this_ptr)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3809
    case 54: {
      gc_zval_possible_root((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3810
    case 55: {
      gc_zval_possible_root((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3811
    case 56: {
      gc_zval_possible_root((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3812
    case 57: {
      gc_zval_possible_root((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3813
    case 58: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3814
    case 59: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3815
    case 60: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3816
    case 61: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3817
    case 62: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3818
    case 63: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3819
    case 64: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3820
    case 65: {
      i_zval_ptr_dtor((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3821
    case 66: {
      i_zval_ptr_dtor((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3822
    case 67: {
      i_zval_ptr_dtor((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3823
    case 68: {
      i_zval_ptr_dtor((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3824
    case 69: {
      if (!__is_neg("24-69", 3, (int *){format, ht, size}, 0, 0, 13,
                    (void **){docp, node, return_value, nodep, intern, nodeobj,
                              buf, doc_props, id, mem, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "docp", "node", "return_value", "nodep", "intern",
                    "nodeobj", "buf", "format", "doc_props", "id", "mem",
                    "dom_node_class_entry", "dom_document_class_entry", "ht",
                    "this_ptr", "size") &&
          (node->doc != docp)) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3825
    case 70: {
      if (!__is_neg("24-70", 3, (int *){format, ht, size}, 0, 0, 13,
                    (void **){docp, node, return_value, nodep, intern, nodeobj,
                              buf, doc_props, id, mem, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "docp", "node", "return_value", "nodep", "intern",
                    "nodeobj", "buf", "format", "doc_props", "id", "mem",
                    "dom_node_class_entry", "dom_document_class_entry", "ht",
                    "this_ptr", "size"))
        if (node->doc != docp) {
          php_dom_throw_error(WRONG_DOCUMENT_ERR,
                              dom_get_strict_error(intern->document));
          {
            do {
              zval *__z = (return_value);
              (*__z).value.lval = ((0) != 0);
              (*__z).type = 3;
            } while (0);
            return;
          };
        }

      break;
    }
#endif
#ifdef COMPILE_3826
    case 71: {
      if ((node->doc != docp) &&
          !__is_neg("24-71", 3, (int *){format, ht, size}, 0, 0, 13,
                    (void **){docp, node, return_value, nodep, intern, nodeobj,
                              buf, doc_props, id, mem, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "docp", "node", "return_value", "nodep", "intern",
                    "nodeobj", "buf", "format", "doc_props", "id", "mem",
                    "dom_node_class_entry", "dom_document_class_entry", "ht",
                    "this_ptr", "size")) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3827
    case 72: {
      if ((node->doc != docp) ||
          __is_neg("24-72", 3, (int *){format, ht, size}, 0, 0, 13,
                   (void **){docp, node, return_value, nodep, intern, nodeobj,
                             buf, doc_props, id, mem, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "docp", "node", "return_value", "nodep", "intern",
                   "nodeobj", "buf", "format", "doc_props", "id", "mem",
                   "dom_node_class_entry", "dom_document_class_entry", "ht",
                   "this_ptr", "size")) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3828
    case 73: {
      if (__is_neg("24-73", 3, (int *){format, ht, size}, 0, 0, 13,
                   (void **){docp, node, return_value, nodep, intern, nodeobj,
                             buf, doc_props, id, mem, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "docp", "node", "return_value", "nodep", "intern",
                   "nodeobj", "buf", "format", "doc_props", "id", "mem",
                   "dom_node_class_entry", "dom_document_class_entry", "ht",
                   "this_ptr", "size"))
        return;
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3829
    case 74: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3830
    case 75: {
      mem = (xmlChar *)xmlBufferContent(buf);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3831
    case 76: {
      memset(intern, 0, sizeof(*(intern)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3832
    case 77: {
      memset(node, 0, sizeof(*(node)));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3833
    case 78: {
      php_dom_create_implementation((return_value_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3834
    case 79: {
      php_dom_create_interator((id), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3835
    case 80: {
      php_dom_create_interator((nodep), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3836
    case 81: {
      php_dom_create_interator((return_value), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3837
    case 82: {
      php_dom_create_interator((this_ptr), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3838
    case 83: {
      php_dom_remove_xinclude_nodes((node));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3839
    case 84: {
      php_dom_remove_xinclude_nodes((node)->children);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3840
    case 85: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3841
    case 86: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3842
    case 87: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3843
    case 88: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3844
    case 89: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3845
    case 90: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3846
    case 91: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3847
    case 92: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3848
    case 93: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3849
    case 94: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3850
    case 95: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3851
    case 96: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3852
    case 97: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3853
    case 98: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3854
    case 99: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3855
    case 100: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3856
    case 101: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3857
    case 102: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3858
    case 103: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3859
    case 104: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3860
    case 105: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3861
    case 106: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3862
    case 107: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3863
    case 108: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3864
    case 109: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3865
    case 110: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3866
    case 111: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3867
    case 112: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3868
    case 113: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3869
    case 114: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3870
    case 115: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3871
    case 116: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3872
    case 117: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3873
    case 118: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3874
    case 119: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3875
    case 120: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3876
    case 121: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3877
    case 122: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3878
    case 123: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3879
    case 124: {
      php_dom_throw_error((PHP_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3880
    case 125: {
      php_dom_throw_error((PHP_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3881
    case 126: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3882
    case 127: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3883
    case 128: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3884
    case 129: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3885
    case 130: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3886
    case 131: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3887
    case 132: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3888
    case 133: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3889
    case 134: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3890
    case 135: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3891
    case 136: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3892
    case 137: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3893
    case 138: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3894
    case 139: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3895
    case 140: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3896
    case 141: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3897
    case 142: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3898
    case 143: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3899
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3900
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3901
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3902
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3903
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3904
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3905
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3906
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3907
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3908
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3909
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3910
    case 155: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3911
    case 156: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3912
    case 157: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3913
    case 158: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3914
    case 159: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3915
    case 160: {
      php_libxml_node_free_resource((node));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3916
    case 161: {
      xmlBufferFree((buf));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3917
    case 162: {
      xmlBufferFree(buf);
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3918
    case 163: {
      xmlFreeNode((node));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3919
    case 164: {
      xmlInitParser();
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3920
    case 165: {
      xmlUnlinkNode((node));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3921
    case 166: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3922
    case 167: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3923
    case 168: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3924
    case 169: {
      zval_unset_isref_p((id));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3925
    case 170: {
      zval_unset_isref_p((nodep));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3926
    case 171: {
      zval_unset_isref_p((return_value));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_3927
    case 172: {
      zval_unset_isref_p((this_ptr));
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
    }

    // prophet generated patch
    switch (__choose("__ID25")) {
    case 0: {
      buf = xmlBufferCreate();

      break;
    }
#ifdef COMPILE_3928
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3929
    case 2: {
      (buf) = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3930
    case 3: {
      (buf) = xmlBufferCreate();
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3931
    case 4: {
      (doc_props) = dom_get_doc_props(intern->document);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3932
    case 5: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3933
    case 6: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3934
    case 7: {
      _convert_to_string(((id)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3935
    case 8: {
      _convert_to_string(((nodep)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3936
    case 9: {
      _convert_to_string(((return_value)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3937
    case 10: {
      _convert_to_string(((this_ptr)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3938
    case 11: {
      _efree(((doc_props)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3939
    case 12: {
      _efree(((id)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3940
    case 13: {
      _efree(((nodep)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3941
    case 14: {
      _efree(((return_value)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3942
    case 15: {
      _efree(((this_ptr)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3943
    case 16: {
      _zval_copy_ctor_func((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3944
    case 17: {
      _zval_copy_ctor_func((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3945
    case 18: {
      _zval_copy_ctor_func((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3946
    case 19: {
      _zval_copy_ctor_func((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3947
    case 20: {
      _zval_dtor(((id)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3948
    case 21: {
      _zval_dtor(((nodep)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3949
    case 22: {
      _zval_dtor(((return_value)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3950
    case 23: {
      _zval_dtor(((this_ptr)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3951
    case 24: {
      _zval_dtor_func((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3952
    case 25: {
      _zval_dtor_func((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3953
    case 26: {
      _zval_dtor_func((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3954
    case 27: {
      _zval_dtor_func((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3955
    case 28: {
      _zval_ptr_dtor((&(id)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3956
    case 29: {
      _zval_ptr_dtor((&(nodep)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3957
    case 30: {
      _zval_ptr_dtor((&(return_value)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3958
    case 31: {
      _zval_ptr_dtor((&(this_ptr)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3959
    case 32: {
      buf = xmlBufferCreate();
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3960
    case 33: {
      convert_to_boolean((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3961
    case 34: {
      convert_to_boolean((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3962
    case 35: {
      convert_to_boolean((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3963
    case 36: {
      convert_to_boolean((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3964
    case 37: {
      convert_to_long((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3965
    case 38: {
      convert_to_long((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3966
    case 39: {
      convert_to_long((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3967
    case 40: {
      convert_to_long((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3968
    case 41: {
      doc_props = dom_get_doc_props((intern)->document);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3969
    case 42: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3970
    case 43: {
      doc_props = dom_get_doc_props(intern->document);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3971
    case 44: {
      exit(1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3972
    case 45: {
      format = (doc_props)->formatoutput;
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3973
    case 46: {
      format = doc_props->formatoutput;
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3974
    case 47: {
      gc_remove_zval_from_buffer((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3975
    case 48: {
      gc_remove_zval_from_buffer((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3976
    case 49: {
      gc_remove_zval_from_buffer((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3977
    case 50: {
      gc_remove_zval_from_buffer((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3978
    case 51: {
      gc_zval_check_possible_root(((id)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3979
    case 52: {
      gc_zval_check_possible_root(((nodep)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3980
    case 53: {
      gc_zval_check_possible_root(((return_value)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3981
    case 54: {
      gc_zval_check_possible_root(((this_ptr)));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3982
    case 55: {
      gc_zval_possible_root((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3983
    case 56: {
      gc_zval_possible_root((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3984
    case 57: {
      gc_zval_possible_root((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3985
    case 58: {
      gc_zval_possible_root((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3986
    case 59: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3987
    case 60: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3988
    case 61: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3989
    case 62: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3990
    case 63: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3991
    case 64: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3992
    case 65: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3993
    case 66: {
      i_zval_ptr_dtor((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3994
    case 67: {
      i_zval_ptr_dtor((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3995
    case 68: {
      i_zval_ptr_dtor((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3996
    case 69: {
      i_zval_ptr_dtor((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3997
    case 70: {
      if (!__is_neg("25-70", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){buf, return_value, intern, docp, node, nodep,
                              nodeobj, mem, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "buf", "return_value", "intern", "docp", "node",
                    "nodep", "nodeobj", "format", "mem", "doc_props", "id",
                    "size", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3998
    case 71: {
      if (__is_neg("25-71", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){buf, return_value, intern, docp, node, nodep,
                             nodeobj, mem, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "buf", "return_value", "intern", "docp", "node",
                   "nodep", "nodeobj", "format", "mem", "doc_props", "id",
                   "size", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_3999
    case 72: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4000
    case 73: {
      mem = (xmlChar *)xmlBufferContent(buf);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4001
    case 74: {
      php_dom_create_implementation((return_value_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4002
    case 75: {
      php_dom_create_interator((id), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4003
    case 76: {
      php_dom_create_interator((nodep), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4004
    case 77: {
      php_dom_create_interator((return_value), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4005
    case 78: {
      php_dom_create_interator((this_ptr), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4006
    case 79: {
      php_dom_remove_xinclude_nodes((node));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4007
    case 80: {
      php_dom_remove_xinclude_nodes((node)->children);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4008
    case 81: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4009
    case 82: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4010
    case 83: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4011
    case 84: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4012
    case 85: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4013
    case 86: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4014
    case 87: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4015
    case 88: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4016
    case 89: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4017
    case 90: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4018
    case 91: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4019
    case 92: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4020
    case 93: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4021
    case 94: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4022
    case 95: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4023
    case 96: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4024
    case 97: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4025
    case 98: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4026
    case 99: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4027
    case 100: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4028
    case 101: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4029
    case 102: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4030
    case 103: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4031
    case 104: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4032
    case 105: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4033
    case 106: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4034
    case 107: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4035
    case 108: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4036
    case 109: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4037
    case 110: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4038
    case 111: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4039
    case 112: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4040
    case 113: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4041
    case 114: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4042
    case 115: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4043
    case 116: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4044
    case 117: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4045
    case 118: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4046
    case 119: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4047
    case 120: {
      php_dom_throw_error((PHP_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4048
    case 121: {
      php_dom_throw_error((PHP_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4049
    case 122: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4050
    case 123: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4051
    case 124: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4052
    case 125: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4053
    case 126: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4054
    case 127: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4055
    case 128: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4056
    case 129: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4057
    case 130: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4058
    case 131: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4059
    case 132: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4060
    case 133: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4061
    case 134: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4062
    case 135: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4063
    case 136: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4064
    case 137: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4065
    case 138: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4066
    case 139: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4067
    case 140: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4068
    case 141: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4069
    case 142: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4070
    case 143: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4071
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4072
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4073
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4074
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4075
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4076
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4077
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4078
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4079
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4080
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4081
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4082
    case 155: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4083
    case 156: {
      php_libxml_node_free_resource((node));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4084
    case 157: {
      xmlBufferFree((buf));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4085
    case 158: {
      xmlBufferFree(buf);
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4086
    case 159: {
      xmlFreeNode((node));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4087
    case 160: {
      xmlInitParser();
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4088
    case 161: {
      xmlUnlinkNode((node));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4089
    case 162: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4090
    case 163: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4091
    case 164: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4092
    case 165: {
      zval_unset_isref_p((id));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4093
    case 166: {
      zval_unset_isref_p((nodep));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4094
    case 167: {
      zval_unset_isref_p((return_value));
      buf = xmlBufferCreate();

      break;
    }
#endif
#ifdef COMPILE_4095
    case 168: {
      zval_unset_isref_p((this_ptr));
      buf = xmlBufferCreate();

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID26")) {
    case 0: {
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#ifdef COMPILE_4096
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4097
    case 2: {
      (buf) = xmlBufferCreate();
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4098
    case 3: {
      (doc_props) = dom_get_doc_props(intern->document);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4099
    case 4: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4100
    case 5: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4101
    case 6: {
      _convert_to_string(((id)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4102
    case 7: {
      _convert_to_string(((nodep)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4103
    case 8: {
      _convert_to_string(((return_value)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4104
    case 9: {
      _convert_to_string(((this_ptr)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4105
    case 10: {
      _efree(((doc_props)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4106
    case 11: {
      _efree(((id)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4107
    case 12: {
      _efree(((nodep)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4108
    case 13: {
      _efree(((return_value)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4109
    case 14: {
      _efree(((this_ptr)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4110
    case 15: {
      _zval_copy_ctor_func((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4111
    case 16: {
      _zval_copy_ctor_func((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4112
    case 17: {
      _zval_copy_ctor_func((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4113
    case 18: {
      _zval_copy_ctor_func((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4114
    case 19: {
      _zval_dtor(((id)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4115
    case 20: {
      _zval_dtor(((nodep)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4116
    case 21: {
      _zval_dtor(((return_value)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4117
    case 22: {
      _zval_dtor(((this_ptr)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4118
    case 23: {
      _zval_dtor_func((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4119
    case 24: {
      _zval_dtor_func((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4120
    case 25: {
      _zval_dtor_func((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4121
    case 26: {
      _zval_dtor_func((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4122
    case 27: {
      _zval_ptr_dtor((&(id)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4123
    case 28: {
      _zval_ptr_dtor((&(nodep)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4124
    case 29: {
      _zval_ptr_dtor((&(return_value)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4125
    case 30: {
      _zval_ptr_dtor((&(this_ptr)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4126
    case 31: {
      buf = xmlBufferCreate();
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4127
    case 32: {
      convert_to_boolean((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4128
    case 33: {
      convert_to_boolean((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4129
    case 34: {
      convert_to_boolean((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4130
    case 35: {
      convert_to_boolean((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4131
    case 36: {
      convert_to_long((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4132
    case 37: {
      convert_to_long((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4133
    case 38: {
      convert_to_long((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4134
    case 39: {
      convert_to_long((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4135
    case 40: {
      doc_props = dom_get_doc_props((intern)->document);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4136
    case 41: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4137
    case 42: {
      doc_props = dom_get_doc_props(intern->document);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4138
    case 43: {
      exit(1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4139
    case 44: {
      format = (doc_props)->formatoutput;
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4140
    case 45: {
      format = doc_props->formatoutput;
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4141
    case 46: {
      gc_remove_zval_from_buffer((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4142
    case 47: {
      gc_remove_zval_from_buffer((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4143
    case 48: {
      gc_remove_zval_from_buffer((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4144
    case 49: {
      gc_remove_zval_from_buffer((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4145
    case 50: {
      gc_zval_check_possible_root(((id)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4146
    case 51: {
      gc_zval_check_possible_root(((nodep)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4147
    case 52: {
      gc_zval_check_possible_root(((return_value)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4148
    case 53: {
      gc_zval_check_possible_root(((this_ptr)));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4149
    case 54: {
      gc_zval_possible_root((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4150
    case 55: {
      gc_zval_possible_root((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4151
    case 56: {
      gc_zval_possible_root((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4152
    case 57: {
      gc_zval_possible_root((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4153
    case 58: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4154
    case 59: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4155
    case 60: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4156
    case 61: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4157
    case 62: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4158
    case 63: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4159
    case 64: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4160
    case 65: {
      i_zval_ptr_dtor((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4161
    case 66: {
      i_zval_ptr_dtor((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4162
    case 67: {
      i_zval_ptr_dtor((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4163
    case 68: {
      i_zval_ptr_dtor((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4164
    case 69: {
      if (!__is_neg("26-69", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){buf, return_value, docp, node, intern, mem, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "buf", "return_value", "docp", "node", "intern",
                    "format", "mem", "nodep", "nodeobj", "doc_props", "id",
                    "size", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr") &&
          (!buf)) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4165
    case 70: {
      if (!__is_neg("26-70", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){buf, return_value, docp, node, intern, mem, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "buf", "return_value", "docp", "node", "intern",
                    "format", "mem", "nodep", "nodeobj", "doc_props", "id",
                    "size", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        if (!buf) {
          php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
          {
            do {
              zval *__z = (return_value);
              (*__z).value.lval = ((0) != 0);
              (*__z).type = 3;
            } while (0);
            return;
          };
        }

      break;
    }
#endif
#ifdef COMPILE_4166
    case 71: {
      if ((!buf) &&
          !__is_neg("26-71", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){buf, return_value, docp, node, intern, mem, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "buf", "return_value", "docp", "node", "intern",
                    "format", "mem", "nodep", "nodeobj", "doc_props", "id",
                    "size", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr")) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4167
    case 72: {
      if ((!buf) ||
          __is_neg("26-72", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){buf, return_value, docp, node, intern, mem, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "buf", "return_value", "docp", "node", "intern",
                   "format", "mem", "nodep", "nodeobj", "doc_props", "id",
                   "size", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr")) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4168
    case 73: {
      if (__is_neg("26-73", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){buf, return_value, docp, node, intern, mem, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "buf", "return_value", "docp", "node", "intern",
                   "format", "mem", "nodep", "nodeobj", "doc_props", "id",
                   "size", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4169
    case 74: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4170
    case 75: {
      mem = (xmlChar *)xmlBufferContent(buf);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4171
    case 76: {
      php_dom_create_implementation((return_value_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4172
    case 77: {
      php_dom_create_interator((id), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4173
    case 78: {
      php_dom_create_interator((nodep), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4174
    case 79: {
      php_dom_create_interator((return_value), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4175
    case 80: {
      php_dom_create_interator((this_ptr), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4176
    case 81: {
      php_dom_remove_xinclude_nodes((node));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4177
    case 82: {
      php_dom_remove_xinclude_nodes((node)->children);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4178
    case 83: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4179
    case 84: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4180
    case 85: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4181
    case 86: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4182
    case 87: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4183
    case 88: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4184
    case 89: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4185
    case 90: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4186
    case 91: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4187
    case 92: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4188
    case 93: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4189
    case 94: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4190
    case 95: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4191
    case 96: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4192
    case 97: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4193
    case 98: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4194
    case 99: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4195
    case 100: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4196
    case 101: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4197
    case 102: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4198
    case 103: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4199
    case 104: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4200
    case 105: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4201
    case 106: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4202
    case 107: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4203
    case 108: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4204
    case 109: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4205
    case 110: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4206
    case 111: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4207
    case 112: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4208
    case 113: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4209
    case 114: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4210
    case 115: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4211
    case 116: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4212
    case 117: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4213
    case 118: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4214
    case 119: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4215
    case 120: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4216
    case 121: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4217
    case 122: {
      php_dom_throw_error((PHP_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4218
    case 123: {
      php_dom_throw_error((PHP_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4219
    case 124: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4220
    case 125: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4221
    case 126: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4222
    case 127: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4223
    case 128: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4224
    case 129: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4225
    case 130: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4226
    case 131: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4227
    case 132: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4228
    case 133: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4229
    case 134: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4230
    case 135: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4231
    case 136: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4232
    case 137: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4233
    case 138: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4234
    case 139: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4235
    case 140: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4236
    case 141: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4237
    case 142: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4238
    case 143: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4239
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4240
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4241
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4242
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4243
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4244
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4245
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4246
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4247
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4248
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4249
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4250
    case 155: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4251
    case 156: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4252
    case 157: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4253
    case 158: {
      php_libxml_node_free_resource((node));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4254
    case 159: {
      xmlBufferFree((buf));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4255
    case 160: {
      xmlBufferFree(buf);
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4256
    case 161: {
      xmlFreeNode((node));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4257
    case 162: {
      xmlInitParser();
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4258
    case 163: {
      xmlUnlinkNode((node));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4259
    case 164: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4260
    case 165: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4261
    case 166: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4262
    case 167: {
      zval_unset_isref_p((id));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4263
    case 168: {
      zval_unset_isref_p((nodep));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4264
    case 169: {
      zval_unset_isref_p((return_value));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
#ifdef COMPILE_4265
    case 170: {
      zval_unset_isref_p((this_ptr));
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }

      break;
    }
#endif
    }

    // prophet generated patch
    switch (__choose("__ID27")) {
    case 0: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#ifdef COMPILE_4266
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4267
    case 2: {
      (buf) = xmlBufferCreate();
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4268
    case 3: {
      (doc_props) = dom_get_doc_props(intern->document);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4269
    case 4: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4270
    case 5: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4271
    case 6: {
      Debug(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4272
    case 7: {
      _convert_to_string(((id)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4273
    case 8: {
      _convert_to_string(((nodep)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4274
    case 9: {
      _convert_to_string(((return_value)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4275
    case 10: {
      _convert_to_string(((this_ptr)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4276
    case 11: {
      _efree(((doc_props)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4277
    case 12: {
      _efree(((id)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4278
    case 13: {
      _efree(((nodep)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4279
    case 14: {
      _efree(((return_value)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4280
    case 15: {
      _efree(((this_ptr)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4281
    case 16: {
      _zval_copy_ctor_func((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4282
    case 17: {
      _zval_copy_ctor_func((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4283
    case 18: {
      _zval_copy_ctor_func((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4284
    case 19: {
      _zval_copy_ctor_func((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4285
    case 20: {
      _zval_dtor(((id)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4286
    case 21: {
      _zval_dtor(((nodep)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4287
    case 22: {
      _zval_dtor(((return_value)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4288
    case 23: {
      _zval_dtor(((this_ptr)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4289
    case 24: {
      _zval_dtor_func((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4290
    case 25: {
      _zval_dtor_func((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4291
    case 26: {
      _zval_dtor_func((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4292
    case 27: {
      _zval_dtor_func((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4293
    case 28: {
      _zval_ptr_dtor((&(id)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4294
    case 29: {
      _zval_ptr_dtor((&(nodep)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4295
    case 30: {
      _zval_ptr_dtor((&(return_value)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4296
    case 31: {
      _zval_ptr_dtor((&(this_ptr)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4297
    case 32: {
      buf = xmlBufferCreate();
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4298
    case 33: {
      convert_to_boolean((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4299
    case 34: {
      convert_to_boolean((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4300
    case 35: {
      convert_to_boolean((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4301
    case 36: {
      convert_to_boolean((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4302
    case 37: {
      convert_to_long((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4303
    case 38: {
      convert_to_long((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4304
    case 39: {
      convert_to_long((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4305
    case 40: {
      convert_to_long((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4306
    case 41: {
      doc_props = dom_get_doc_props((intern)->document);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4307
    case 42: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4308
    case 43: {
      doc_props = dom_get_doc_props(intern->document);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4309
    case 44: {
      exit(1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4310
    case 45: {
      format = (doc_props)->formatoutput;
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4311
    case 46: {
      format = doc_props->formatoutput;
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4312
    case 47: {
      gc_remove_zval_from_buffer((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4313
    case 48: {
      gc_remove_zval_from_buffer((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4314
    case 49: {
      gc_remove_zval_from_buffer((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4315
    case 50: {
      gc_remove_zval_from_buffer((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4316
    case 51: {
      gc_zval_check_possible_root(((id)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4317
    case 52: {
      gc_zval_check_possible_root(((nodep)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4318
    case 53: {
      gc_zval_check_possible_root(((return_value)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4319
    case 54: {
      gc_zval_check_possible_root(((this_ptr)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4320
    case 55: {
      gc_zval_possible_root((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4321
    case 56: {
      gc_zval_possible_root((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4322
    case 57: {
      gc_zval_possible_root((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4323
    case 58: {
      gc_zval_possible_root((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4324
    case 59: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4325
    case 60: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4326
    case 61: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4327
    case 62: {
      htmlNodeDumpFileFormat(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4328
    case 63: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4329
    case 64: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4330
    case 65: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4331
    case 66: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4332
    case 67: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);

      break;
    }
#endif
#ifdef COMPILE_4333
    case 68: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4334
    case 69: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4335
    case 70: {
      i_zval_ptr_dtor((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4336
    case 71: {
      i_zval_ptr_dtor((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4337
    case 72: {
      i_zval_ptr_dtor((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4338
    case 73: {
      i_zval_ptr_dtor((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4339
    case 74: {
      if (!__is_neg("27-74", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){docp, node, buf, mem, return_value, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "docp", "node", "buf", "format", "mem",
                    "return_value", "intern", "size", "nodep", "nodeobj",
                    "doc_props", "id", "dom_node_class_entry",
                    "dom_document_class_entry", "ht", "this_ptr"))
        htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4340
    case 75: {
      if (__is_neg("27-75", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){docp, node, buf, mem, return_value, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "docp", "node", "buf", "format", "mem",
                   "return_value", "intern", "size", "nodep", "nodeobj",
                   "doc_props", "id", "dom_node_class_entry",
                   "dom_document_class_entry", "ht", "this_ptr"))
        return;
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4341
    case 76: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4342
    case 77: {
      mem = (xmlChar *)xmlBufferContent(buf);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4343
    case 78: {
      memset(node, 0, sizeof(*(node)));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4344
    case 79: {
      php_dom_create_implementation((return_value_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4345
    case 80: {
      php_dom_create_interator((id), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4346
    case 81: {
      php_dom_create_interator((nodep), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4347
    case 82: {
      php_dom_create_interator((return_value), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4348
    case 83: {
      php_dom_create_interator((this_ptr), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4349
    case 84: {
      php_dom_remove_xinclude_nodes((node));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4350
    case 85: {
      php_dom_remove_xinclude_nodes((node)->children);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4351
    case 86: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4352
    case 87: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4353
    case 88: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4354
    case 89: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4355
    case 90: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4356
    case 91: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4357
    case 92: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4358
    case 93: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4359
    case 94: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4360
    case 95: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4361
    case 96: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4362
    case 97: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4363
    case 98: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4364
    case 99: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4365
    case 100: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4366
    case 101: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4367
    case 102: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4368
    case 103: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4369
    case 104: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4370
    case 105: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4371
    case 106: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4372
    case 107: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4373
    case 108: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4374
    case 109: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4375
    case 110: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4376
    case 111: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4377
    case 112: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4378
    case 113: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4379
    case 114: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4380
    case 115: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4381
    case 116: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4382
    case 117: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4383
    case 118: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4384
    case 119: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4385
    case 120: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4386
    case 121: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4387
    case 122: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4388
    case 123: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4389
    case 124: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4390
    case 125: {
      php_dom_throw_error((PHP_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4391
    case 126: {
      php_dom_throw_error((PHP_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4392
    case 127: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4393
    case 128: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4394
    case 129: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4395
    case 130: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4396
    case 131: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4397
    case 132: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4398
    case 133: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4399
    case 134: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4400
    case 135: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4401
    case 136: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4402
    case 137: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4403
    case 138: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4404
    case 139: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4405
    case 140: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4406
    case 141: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4407
    case 142: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4408
    case 143: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4409
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4410
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4411
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4412
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4413
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4414
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4415
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4416
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4417
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4418
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4419
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4420
    case 155: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4421
    case 156: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4422
    case 157: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4423
    case 158: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4424
    case 159: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4425
    case 160: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4426
    case 161: {
      php_libxml_node_free_resource((node));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4427
    case 162: {
      php_printf(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4428
    case 163: {
      printf(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4429
    case 164: {
      scanf(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4430
    case 165: {
      xmlBufferFree((buf));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4431
    case 166: {
      xmlBufferFree(buf);
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4432
    case 167: {
      xmlFreeNode((node));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4433
    case 168: {
      xmlInitParser();
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4434
    case 169: {
      xmlNodeDump(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4435
    case 170: {
      xmlUnlinkNode((node));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4436
    case 171: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4437
    case 172: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4438
    case 173: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4439
    case 174: {
      zval_unset_isref_p((id));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4440
    case 175: {
      zval_unset_isref_p((nodep));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4441
    case 176: {
      zval_unset_isref_p((return_value));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
#ifdef COMPILE_4442
    case 177: {
      zval_unset_isref_p((this_ptr));
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID28")) {
    case 0: {
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#ifdef COMPILE_4443
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4444
    case 2: {
      (buf) = xmlBufferCreate();
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4445
    case 3: {
      (doc_props) = dom_get_doc_props(intern->document);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4446
    case 4: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4447
    case 5: {
      (mem) = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4448
    case 6: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4449
    case 7: {
      _convert_to_string(((id)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4450
    case 8: {
      _convert_to_string(((nodep)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4451
    case 9: {
      _convert_to_string(((return_value)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4452
    case 10: {
      _convert_to_string(((this_ptr)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4453
    case 11: {
      _efree(((doc_props)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4454
    case 12: {
      _efree(((id)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4455
    case 13: {
      _efree(((nodep)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4456
    case 14: {
      _efree(((return_value)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4457
    case 15: {
      _efree(((this_ptr)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4458
    case 16: {
      _zval_copy_ctor_func((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4459
    case 17: {
      _zval_copy_ctor_func((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4460
    case 18: {
      _zval_copy_ctor_func((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4461
    case 19: {
      _zval_copy_ctor_func((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4462
    case 20: {
      _zval_dtor(((id)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4463
    case 21: {
      _zval_dtor(((nodep)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4464
    case 22: {
      _zval_dtor(((return_value)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4465
    case 23: {
      _zval_dtor(((this_ptr)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4466
    case 24: {
      _zval_dtor_func((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4467
    case 25: {
      _zval_dtor_func((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4468
    case 26: {
      _zval_dtor_func((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4469
    case 27: {
      _zval_dtor_func((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4470
    case 28: {
      _zval_ptr_dtor((&(id)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4471
    case 29: {
      _zval_ptr_dtor((&(nodep)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4472
    case 30: {
      _zval_ptr_dtor((&(return_value)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4473
    case 31: {
      _zval_ptr_dtor((&(this_ptr)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4474
    case 32: {
      buf = xmlBufferCreate();
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4475
    case 33: {
      convert_to_boolean((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4476
    case 34: {
      convert_to_boolean((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4477
    case 35: {
      convert_to_boolean((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4478
    case 36: {
      convert_to_boolean((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4479
    case 37: {
      convert_to_long((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4480
    case 38: {
      convert_to_long((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4481
    case 39: {
      convert_to_long((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4482
    case 40: {
      convert_to_long((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4483
    case 41: {
      doc_props = dom_get_doc_props((intern)->document);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4484
    case 42: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4485
    case 43: {
      doc_props = dom_get_doc_props(intern->document);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4486
    case 44: {
      exit(1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4487
    case 45: {
      format = (doc_props)->formatoutput;
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4488
    case 46: {
      format = doc_props->formatoutput;
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4489
    case 47: {
      gc_remove_zval_from_buffer((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4490
    case 48: {
      gc_remove_zval_from_buffer((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4491
    case 49: {
      gc_remove_zval_from_buffer((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4492
    case 50: {
      gc_remove_zval_from_buffer((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4493
    case 51: {
      gc_zval_check_possible_root(((id)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4494
    case 52: {
      gc_zval_check_possible_root(((nodep)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4495
    case 53: {
      gc_zval_check_possible_root(((return_value)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4496
    case 54: {
      gc_zval_check_possible_root(((this_ptr)));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4497
    case 55: {
      gc_zval_possible_root((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4498
    case 56: {
      gc_zval_possible_root((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4499
    case 57: {
      gc_zval_possible_root((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4500
    case 58: {
      gc_zval_possible_root((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4501
    case 59: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4502
    case 60: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4503
    case 61: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4504
    case 62: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4505
    case 63: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4506
    case 64: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4507
    case 65: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4508
    case 66: {
      i_zval_ptr_dtor((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4509
    case 67: {
      i_zval_ptr_dtor((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4510
    case 68: {
      i_zval_ptr_dtor((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4511
    case 69: {
      i_zval_ptr_dtor((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4512
    case 70: {
      if (!__is_neg("28-70", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){buf, mem, docp, node, return_value, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "buf", "mem", "docp", "node", "format",
                    "return_value", "size", "intern", "nodep", "nodeobj",
                    "doc_props", "id", "dom_node_class_entry",
                    "dom_document_class_entry", "ht", "this_ptr"))
        mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4513
    case 71: {
      if (__is_neg("28-71", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){buf, mem, docp, node, return_value, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "buf", "mem", "docp", "node", "format",
                   "return_value", "size", "intern", "nodep", "nodeobj",
                   "doc_props", "id", "dom_node_class_entry",
                   "dom_document_class_entry", "ht", "this_ptr"))
        return;
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4514
    case 72: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4515
    case 73: {
      mem = (xmlChar *)xmlBufferContent(buf);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4516
    case 74: {
      php_dom_create_implementation((return_value_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4517
    case 75: {
      php_dom_create_interator((id), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4518
    case 76: {
      php_dom_create_interator((nodep), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4519
    case 77: {
      php_dom_create_interator((return_value), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4520
    case 78: {
      php_dom_create_interator((this_ptr), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4521
    case 79: {
      php_dom_remove_xinclude_nodes((node));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4522
    case 80: {
      php_dom_remove_xinclude_nodes((node)->children);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4523
    case 81: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4524
    case 82: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4525
    case 83: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4526
    case 84: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4527
    case 85: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4528
    case 86: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4529
    case 87: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4530
    case 88: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4531
    case 89: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4532
    case 90: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4533
    case 91: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4534
    case 92: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4535
    case 93: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4536
    case 94: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4537
    case 95: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4538
    case 96: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4539
    case 97: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4540
    case 98: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4541
    case 99: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4542
    case 100: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4543
    case 101: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4544
    case 102: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4545
    case 103: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4546
    case 104: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4547
    case 105: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4548
    case 106: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4549
    case 107: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4550
    case 108: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4551
    case 109: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4552
    case 110: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4553
    case 111: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4554
    case 112: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4555
    case 113: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4556
    case 114: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4557
    case 115: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4558
    case 116: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4559
    case 117: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4560
    case 118: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4561
    case 119: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4562
    case 120: {
      php_dom_throw_error((PHP_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4563
    case 121: {
      php_dom_throw_error((PHP_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4564
    case 122: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4565
    case 123: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4566
    case 124: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4567
    case 125: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4568
    case 126: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4569
    case 127: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4570
    case 128: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4571
    case 129: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4572
    case 130: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4573
    case 131: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4574
    case 132: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4575
    case 133: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4576
    case 134: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4577
    case 135: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4578
    case 136: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4579
    case 137: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4580
    case 138: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4581
    case 139: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4582
    case 140: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4583
    case 141: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4584
    case 142: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4585
    case 143: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4586
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4587
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4588
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4589
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4590
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4591
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4592
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4593
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4594
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4595
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4596
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4597
    case 155: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4598
    case 156: {
      php_libxml_node_free_resource((node));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4599
    case 157: {
      xmlBufferFree((buf));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4600
    case 158: {
      xmlBufferFree(buf);
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4601
    case 159: {
      xmlFreeNode((node));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4602
    case 160: {
      xmlInitParser();
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4603
    case 161: {
      xmlUnlinkNode((node));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4604
    case 162: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4605
    case 163: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4606
    case 164: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4607
    case 165: {
      zval_unset_isref_p((id));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4608
    case 166: {
      zval_unset_isref_p((nodep));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4609
    case 167: {
      zval_unset_isref_p((return_value));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_4610
    case 168: {
      zval_unset_isref_p((this_ptr));
      mem = (xmlChar *)xmlBufferContent(buf);

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID29")) {
    case 0: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#ifdef COMPILE_4611
    case 1: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        (*(__xmlSaveNoEmptyTags())) = 1;
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4612
    case 2: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        (buf) = xmlBufferCreate();
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4613
    case 3: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        (doc_props) = dom_get_doc_props(intern->document);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4614
    case 4: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        (executor_globals.argument_stack) =
            zend_vm_stack_new_page(((16 * 1024) - 16));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4615
    case 5: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        (mem) = (xmlChar *)xmlBufferContent(buf);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4616
    case 6: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((id)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4617
    case 7: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((nodep)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4618
    case 8: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((return_value)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4619
    case 9: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((this_ptr)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4620
    case 10: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _efree(((doc_props)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4621
    case 11: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _efree(((id)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4622
    case 12: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _efree(((nodep)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4623
    case 13: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _efree(((return_value)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4624
    case 14: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _efree(((this_ptr)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4625
    case 15: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4626
    case 16: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4627
    case 17: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4628
    case 18: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4629
    case 19: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((id)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4630
    case 20: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((nodep)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4631
    case 21: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((return_value)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4632
    case 22: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((this_ptr)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4633
    case 23: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4634
    case 24: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4635
    case 25: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4636
    case 26: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4637
    case 27: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(id)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4638
    case 28: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(nodep)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4639
    case 29: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(return_value)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4640
    case 30: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(this_ptr)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4641
    case 31: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        buf = xmlBufferCreate();
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4642
    case 32: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4643
    case 33: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4644
    case 34: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4645
    case 35: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4646
    case 36: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_long((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4647
    case 37: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_long((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4648
    case 38: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_long((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4649
    case 39: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        convert_to_long((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4650
    case 40: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        doc_props = dom_get_doc_props((intern)->document);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4651
    case 41: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        doc_props = dom_get_doc_props((nodeobj)->document);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4652
    case 42: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        doc_props = dom_get_doc_props(intern->document);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4653
    case 43: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        exit(1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4654
    case 44: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        format = (doc_props)->formatoutput;
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4655
    case 45: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        format = doc_props->formatoutput;
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4656
    case 46: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4657
    case 47: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4658
    case 48: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4659
    case 49: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4660
    case 50: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((id)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4661
    case 51: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((nodep)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4662
    case 52: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((return_value)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4663
    case 53: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((this_ptr)));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4664
    case 54: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4665
    case 55: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4666
    case 56: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4667
    case 57: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4668
    case 58: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlDocDumpMemoryFormat((docp), &mem, &size, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4669
    case 59: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4670
    case 60: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlDocDumpMemoryFormat(docp, &mem, &size, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4671
    case 61: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4672
    case 62: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4673
    case 63: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4674
    case 64: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4675
    case 65: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4676
    case 66: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4677
    case 67: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4678
    case 68: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4679
    case 69: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        if (!__is_neg("29-69", 3, (int *){size, format, ht}, 0, 0, 13,
                      (void **){return_value, mem, buf, docp, node, intern,
                                nodep, nodeobj, doc_props, id,
                                dom_node_class_entry, dom_document_class_entry,
                                this_ptr},
                      0, 0, 16, "return_value", "mem", "buf", "docp", "node",
                      "size", "format", "intern", "nodep", "nodeobj",
                      "doc_props", "id", "dom_node_class_entry",
                      "dom_document_class_entry", "ht", "this_ptr"))
          do {
            const char *__s = (mem);
            zval *__z = (return_value);
            (*__z).value.str.len = strlen(__s);
            (*__z).value.str.val =
                (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
            (*__z).type = 6;
          } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4680
    case 70: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        if (__is_neg("29-70", 3, (int *){size, format, ht}, 0, 0, 13,
                     (void **){return_value, mem, buf, docp, node, intern,
                               nodep, nodeobj, doc_props, id,
                               dom_node_class_entry, dom_document_class_entry,
                               this_ptr},
                     0, 0, 16, "return_value", "mem", "buf", "docp", "node",
                     "size", "format", "intern", "nodep", "nodeobj",
                     "doc_props", "id", "dom_node_class_entry",
                     "dom_document_class_entry", "ht", "this_ptr"))
          return;
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4681
    case 71: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                         dom_document_class_entry, &nodep,
                                         dom_node_class_entry) == -1) {
          return;
        }
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4682
    case 72: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        mem = (xmlChar *)xmlBufferContent(buf);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4683
    case 73: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_create_implementation((return_value_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4684
    case 74: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((id), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4685
    case 75: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((nodep), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4686
    case 76: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((return_value), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4687
    case 77: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((this_ptr), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4688
    case 78: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_remove_xinclude_nodes((node));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4689
    case 79: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_remove_xinclude_nodes((node)->children);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4690
    case 80: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4691
    case 81: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4692
    case 82: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((DOMSTRING_SIZE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4693
    case 83: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4694
    case 84: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4695
    case 85: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4696
    case 86: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INDEX_SIZE_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4697
    case 87: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INDEX_SIZE_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4698
    case 88: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INDEX_SIZE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4699
    case 89: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4700
    case 90: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4701
    case 91: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4702
    case 92: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_ACCESS_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4703
    case 93: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_ACCESS_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4704
    case 94: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_ACCESS_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4705
    case 95: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4706
    case 96: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4707
    case 97: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_CHARACTER_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4708
    case 98: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4709
    case 99: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4710
    case 100: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_MODIFICATION_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4711
    case 101: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_STATE_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4712
    case 102: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_STATE_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4713
    case 103: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_STATE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4714
    case 104: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NAMESPACE_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4715
    case 105: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NAMESPACE_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4716
    case 106: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NAMESPACE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4717
    case 107: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_FOUND_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4718
    case 108: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_FOUND_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4719
    case 109: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_FOUND_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4720
    case 110: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4721
    case 111: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4722
    case 112: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_SUPPORTED_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4723
    case 113: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4724
    case 114: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4725
    case 115: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4726
    case 116: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4727
    case 117: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4728
    case 118: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4729
    case 119: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((PHP_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4730
    case 120: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((PHP_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4731
    case 121: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4732
    case 122: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((SYNTAX_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4733
    case 123: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((SYNTAX_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4734
    case 124: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((SYNTAX_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4735
    case 125: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((VALIDATION_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4736
    case 126: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((VALIDATION_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4737
    case 127: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((VALIDATION_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4738
    case 128: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4739
    case 129: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4740
    case 130: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((WRONG_DOCUMENT_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4741
    case 131: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_CHARACTER_ERR,
                            dom_get_strict_error((intern)->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4742
    case 132: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_CHARACTER_ERR,
                            dom_get_strict_error((nodeobj)->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4743
    case 133: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_STATE_ERR, 0);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4744
    case 134: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_STATE_ERR, 1);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4745
    case 135: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error((intern)->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4746
    case 136: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error((nodeobj)->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4747
    case 137: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4748
    case 138: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Cannot create required DOM object");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4749
    case 139: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Cannot import: Node Type Not Supported");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4750
    case 140: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4751
    case 141: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          (intern)->std.ce->name);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4752
    case 142: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          (nodeobj)->std.ce->name);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4753
    case 143: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          intern->std.ce->name);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4754
    case 144: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4755
    case 145: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Document Missing Root Element");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4756
    case 146: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Empty string supplied as input");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4757
    case 147: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4758
    case 148: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4759
    case 149: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Invalid RelaxNG file source");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4760
    case 150: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4761
    case 151: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4762
    case 152: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4763
    case 153: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4764
    case 154: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4765
    case 155: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        php_libxml_node_free_resource((node));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4766
    case 156: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        xmlBufferFree((buf));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4767
    case 157: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        xmlBufferFree(buf);
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4768
    case 158: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        xmlFreeNode((node));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4769
    case 159: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        xmlInitParser();
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4770
    case 160: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        xmlUnlinkNode((node));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4771
    case 161: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4772
    case 162: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zend_error((1 << 0L), "Invalid Schema Validation Context");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4773
    case 163: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zend_error((1 << 3L), "A non well formed numeric value encountered");
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4774
    case 164: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((id));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4775
    case 165: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((nodep));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4776
    case 166: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((return_value));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4777
    case 167: {
      if (!mem) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((this_ptr));
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4778
    case 168: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4779
    case 169: {
      (buf) = xmlBufferCreate();
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4780
    case 170: {
      (doc_props) = dom_get_doc_props(intern->document);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4781
    case 171: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4782
    case 172: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4783
    case 173: {
      _convert_to_string(((id)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4784
    case 174: {
      _convert_to_string(((nodep)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4785
    case 175: {
      _convert_to_string(((return_value)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4786
    case 176: {
      _convert_to_string(((this_ptr)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4787
    case 177: {
      _efree(((doc_props)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4788
    case 178: {
      _efree(((id)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4789
    case 179: {
      _efree(((nodep)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4790
    case 180: {
      _efree(((return_value)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4791
    case 181: {
      _efree(((this_ptr)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4792
    case 182: {
      _zval_copy_ctor_func((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4793
    case 183: {
      _zval_copy_ctor_func((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4794
    case 184: {
      _zval_copy_ctor_func((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4795
    case 185: {
      _zval_copy_ctor_func((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4796
    case 186: {
      _zval_dtor(((id)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4797
    case 187: {
      _zval_dtor(((nodep)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4798
    case 188: {
      _zval_dtor(((return_value)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4799
    case 189: {
      _zval_dtor(((this_ptr)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4800
    case 190: {
      _zval_dtor_func((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4801
    case 191: {
      _zval_dtor_func((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4802
    case 192: {
      _zval_dtor_func((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4803
    case 193: {
      _zval_dtor_func((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4804
    case 194: {
      _zval_ptr_dtor((&(id)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4805
    case 195: {
      _zval_ptr_dtor((&(nodep)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4806
    case 196: {
      _zval_ptr_dtor((&(return_value)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4807
    case 197: {
      _zval_ptr_dtor((&(this_ptr)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4808
    case 198: {
      buf = xmlBufferCreate();
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4809
    case 199: {
      convert_to_boolean((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4810
    case 200: {
      convert_to_boolean((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4811
    case 201: {
      convert_to_boolean((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4812
    case 202: {
      convert_to_boolean((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4813
    case 203: {
      convert_to_long((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4814
    case 204: {
      convert_to_long((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4815
    case 205: {
      convert_to_long((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4816
    case 206: {
      convert_to_long((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4817
    case 207: {
      doc_props = dom_get_doc_props((intern)->document);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4818
    case 208: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4819
    case 209: {
      doc_props = dom_get_doc_props(intern->document);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4820
    case 210: {
      exit(1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4821
    case 211: {
      format = (doc_props)->formatoutput;
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4822
    case 212: {
      format = doc_props->formatoutput;
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4823
    case 213: {
      gc_remove_zval_from_buffer((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4824
    case 214: {
      gc_remove_zval_from_buffer((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4825
    case 215: {
      gc_remove_zval_from_buffer((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4826
    case 216: {
      gc_remove_zval_from_buffer((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4827
    case 217: {
      gc_zval_check_possible_root(((id)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4828
    case 218: {
      gc_zval_check_possible_root(((nodep)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4829
    case 219: {
      gc_zval_check_possible_root(((return_value)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4830
    case 220: {
      gc_zval_check_possible_root(((this_ptr)));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4831
    case 221: {
      gc_zval_possible_root((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4832
    case 222: {
      gc_zval_possible_root((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4833
    case 223: {
      gc_zval_possible_root((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4834
    case 224: {
      gc_zval_possible_root((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4835
    case 225: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4836
    case 226: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4837
    case 227: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4838
    case 228: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4839
    case 229: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4840
    case 230: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4841
    case 231: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4842
    case 232: {
      i_zval_ptr_dtor((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4843
    case 233: {
      i_zval_ptr_dtor((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4844
    case 234: {
      i_zval_ptr_dtor((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4845
    case 235: {
      i_zval_ptr_dtor((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4846
    case 236: {
      if (!__is_neg("29-236", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){mem, return_value, buf, docp, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "mem", "return_value", "buf", "docp", "node",
                    "format", "size", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr") &&
          (!mem)) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4847
    case 237: {
      if (!__is_neg("29-237", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){mem, return_value, buf, docp, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "mem", "return_value", "buf", "docp", "node",
                    "format", "size", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        if (!mem) {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
        } else {
          do {
            const char *__s = (mem);
            zval *__z = (return_value);
            (*__z).value.str.len = strlen(__s);
            (*__z).value.str.val =
                (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
            (*__z).type = 6;
          } while (0);
        }

      break;
    }
#endif
#ifdef COMPILE_4848
    case 238: {
      if ((!mem) &&
          !__is_neg("29-238", 3, (int *){format, size, ht}, 0, 0, 13,
                    (void **){mem, return_value, buf, docp, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "mem", "return_value", "buf", "docp", "node",
                    "format", "size", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr")) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4849
    case 239: {
      if ((!mem) ||
          __is_neg("29-239", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){mem, return_value, buf, docp, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "mem", "return_value", "buf", "docp", "node",
                   "format", "size", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr")) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4850
    case 240: {
      if (__is_neg("29-240", 3, (int *){format, size, ht}, 0, 0, 13,
                   (void **){mem, return_value, buf, docp, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "mem", "return_value", "buf", "docp", "node",
                   "format", "size", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4851
    case 241: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4852
    case 242: {
      mem = (xmlChar *)xmlBufferContent(buf);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4853
    case 243: {
      php_dom_create_implementation((return_value_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4854
    case 244: {
      php_dom_create_interator((id), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4855
    case 245: {
      php_dom_create_interator((nodep), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4856
    case 246: {
      php_dom_create_interator((return_value), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4857
    case 247: {
      php_dom_create_interator((this_ptr), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4858
    case 248: {
      php_dom_remove_xinclude_nodes((node));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4859
    case 249: {
      php_dom_remove_xinclude_nodes((node)->children);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4860
    case 250: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4861
    case 251: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4862
    case 252: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4863
    case 253: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4864
    case 254: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4865
    case 255: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4866
    case 256: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4867
    case 257: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4868
    case 258: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4869
    case 259: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4870
    case 260: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4871
    case 261: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4872
    case 262: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4873
    case 263: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4874
    case 264: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4875
    case 265: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4876
    case 266: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4877
    case 267: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4878
    case 268: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4879
    case 269: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4880
    case 270: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4881
    case 271: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4882
    case 272: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4883
    case 273: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4884
    case 274: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4885
    case 275: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4886
    case 276: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4887
    case 277: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4888
    case 278: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4889
    case 279: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4890
    case 280: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4891
    case 281: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4892
    case 282: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4893
    case 283: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4894
    case 284: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4895
    case 285: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4896
    case 286: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4897
    case 287: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4898
    case 288: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4899
    case 289: {
      php_dom_throw_error((PHP_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4900
    case 290: {
      php_dom_throw_error((PHP_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4901
    case 291: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4902
    case 292: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4903
    case 293: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4904
    case 294: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4905
    case 295: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4906
    case 296: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4907
    case 297: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4908
    case 298: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4909
    case 299: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4910
    case 300: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4911
    case 301: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4912
    case 302: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4913
    case 303: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4914
    case 304: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4915
    case 305: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4916
    case 306: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4917
    case 307: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4918
    case 308: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4919
    case 309: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4920
    case 310: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4921
    case 311: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4922
    case 312: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4923
    case 313: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4924
    case 314: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4925
    case 315: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4926
    case 316: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4927
    case 317: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4928
    case 318: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4929
    case 319: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4930
    case 320: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4931
    case 321: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4932
    case 322: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4933
    case 323: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4934
    case 324: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4935
    case 325: {
      php_libxml_node_free_resource((node));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4936
    case 326: {
      xmlBufferFree((buf));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4937
    case 327: {
      xmlBufferFree(buf);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4938
    case 328: {
      xmlFreeNode((node));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4939
    case 329: {
      xmlInitParser();
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4940
    case 330: {
      xmlUnlinkNode((node));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4941
    case 331: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4942
    case 332: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4943
    case 333: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4944
    case 334: {
      zval_unset_isref_p((id));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4945
    case 335: {
      zval_unset_isref_p((nodep));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4946
    case 336: {
      zval_unset_isref_p((return_value));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_4947
    case 337: {
      zval_unset_isref_p((this_ptr));
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
    }
    // prophet generated patch
    switch (__choose("__ID30")) {
    case 0: {
      xmlBufferFree(buf);

      break;
    }
#ifdef COMPILE_4948
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4949
    case 2: {
      (buf) = xmlBufferCreate();
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4950
    case 3: {
      (doc_props) = dom_get_doc_props(intern->document);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4951
    case 4: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4952
    case 5: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4953
    case 6: {
      _convert_to_string(((id)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4954
    case 7: {
      _convert_to_string(((nodep)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4955
    case 8: {
      _convert_to_string(((return_value)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4956
    case 9: {
      _convert_to_string(((this_ptr)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4957
    case 10: {
      _efree(((doc_props)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4958
    case 11: {
      _efree(((id)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4959
    case 12: {
      _efree(((nodep)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4960
    case 13: {
      _efree(((return_value)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4961
    case 14: {
      _efree(((this_ptr)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4962
    case 15: {
      _zval_copy_ctor_func((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4963
    case 16: {
      _zval_copy_ctor_func((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4964
    case 17: {
      _zval_copy_ctor_func((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4965
    case 18: {
      _zval_copy_ctor_func((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4966
    case 19: {
      _zval_dtor(((id)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4967
    case 20: {
      _zval_dtor(((nodep)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4968
    case 21: {
      _zval_dtor(((return_value)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4969
    case 22: {
      _zval_dtor(((this_ptr)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4970
    case 23: {
      _zval_dtor_func((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4971
    case 24: {
      _zval_dtor_func((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4972
    case 25: {
      _zval_dtor_func((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4973
    case 26: {
      _zval_dtor_func((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4974
    case 27: {
      _zval_ptr_dtor((&(id)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4975
    case 28: {
      _zval_ptr_dtor((&(nodep)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4976
    case 29: {
      _zval_ptr_dtor((&(return_value)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4977
    case 30: {
      _zval_ptr_dtor((&(this_ptr)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4978
    case 31: {
      buf = xmlBufferCreate();
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4979
    case 32: {
      convert_to_boolean((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4980
    case 33: {
      convert_to_boolean((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4981
    case 34: {
      convert_to_boolean((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4982
    case 35: {
      convert_to_boolean((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4983
    case 36: {
      convert_to_long((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4984
    case 37: {
      convert_to_long((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4985
    case 38: {
      convert_to_long((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4986
    case 39: {
      convert_to_long((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4987
    case 40: {
      doc_props = dom_get_doc_props((intern)->document);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4988
    case 41: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4989
    case 42: {
      doc_props = dom_get_doc_props(intern->document);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4990
    case 43: {
      exit(1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4991
    case 44: {
      format = (doc_props)->formatoutput;
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4992
    case 45: {
      format = doc_props->formatoutput;
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4993
    case 46: {
      gc_remove_zval_from_buffer((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4994
    case 47: {
      gc_remove_zval_from_buffer((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4995
    case 48: {
      gc_remove_zval_from_buffer((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4996
    case 49: {
      gc_remove_zval_from_buffer((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4997
    case 50: {
      gc_zval_check_possible_root(((id)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4998
    case 51: {
      gc_zval_check_possible_root(((nodep)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_4999
    case 52: {
      gc_zval_check_possible_root(((return_value)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5000
    case 53: {
      gc_zval_check_possible_root(((this_ptr)));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5001
    case 54: {
      gc_zval_possible_root((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5002
    case 55: {
      gc_zval_possible_root((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5003
    case 56: {
      gc_zval_possible_root((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5004
    case 57: {
      gc_zval_possible_root((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5005
    case 58: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5006
    case 59: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5007
    case 60: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5008
    case 61: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5009
    case 62: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5010
    case 63: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5011
    case 64: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5012
    case 65: {
      i_zval_ptr_dtor((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5013
    case 66: {
      i_zval_ptr_dtor((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5014
    case 67: {
      i_zval_ptr_dtor((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5015
    case 68: {
      i_zval_ptr_dtor((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5016
    case 69: {
      if (!__is_neg("30-69", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){buf, return_value, mem, docp, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "buf", "return_value", "mem", "docp", "size",
                    "format", "node", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5017
    case 70: {
      if (__is_neg("30-70", 3, (int *){size, format, ht}, 0, 0, 13,
                   (void **){buf, return_value, mem, docp, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "buf", "return_value", "mem", "docp", "size",
                   "format", "node", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5018
    case 71: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5019
    case 72: {
      mem = (xmlChar *)xmlBufferContent(buf);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5020
    case 73: {
      php_dom_create_implementation((return_value_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5021
    case 74: {
      php_dom_create_interator((id), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5022
    case 75: {
      php_dom_create_interator((nodep), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5023
    case 76: {
      php_dom_create_interator((return_value), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5024
    case 77: {
      php_dom_create_interator((this_ptr), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5025
    case 78: {
      php_dom_remove_xinclude_nodes((node));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5026
    case 79: {
      php_dom_remove_xinclude_nodes((node)->children);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5027
    case 80: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5028
    case 81: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5029
    case 82: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5030
    case 83: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5031
    case 84: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5032
    case 85: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5033
    case 86: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5034
    case 87: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5035
    case 88: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5036
    case 89: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5037
    case 90: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5038
    case 91: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5039
    case 92: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5040
    case 93: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5041
    case 94: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5042
    case 95: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5043
    case 96: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5044
    case 97: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5045
    case 98: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5046
    case 99: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5047
    case 100: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5048
    case 101: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5049
    case 102: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5050
    case 103: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5051
    case 104: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5052
    case 105: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5053
    case 106: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5054
    case 107: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5055
    case 108: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5056
    case 109: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5057
    case 110: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5058
    case 111: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5059
    case 112: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5060
    case 113: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5061
    case 114: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5062
    case 115: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5063
    case 116: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5064
    case 117: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5065
    case 118: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5066
    case 119: {
      php_dom_throw_error((PHP_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5067
    case 120: {
      php_dom_throw_error((PHP_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5068
    case 121: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5069
    case 122: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5070
    case 123: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5071
    case 124: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5072
    case 125: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5073
    case 126: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5074
    case 127: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5075
    case 128: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5076
    case 129: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5077
    case 130: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5078
    case 131: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5079
    case 132: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5080
    case 133: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5081
    case 134: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5082
    case 135: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5083
    case 136: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5084
    case 137: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5085
    case 138: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5086
    case 139: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5087
    case 140: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5088
    case 141: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5089
    case 142: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5090
    case 143: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5091
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5092
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5093
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5094
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5095
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5096
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5097
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5098
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5099
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5100
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5101
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5102
    case 155: {
      php_libxml_node_free_resource((node));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5103
    case 156: {
      xmlBufferContent(buf);

      break;
    }
#endif
#ifdef COMPILE_5104
    case 157: {
      xmlBufferDetach(buf);

      break;
    }
#endif
#ifdef COMPILE_5105
    case 158: {
      xmlBufferEmpty(buf);

      break;
    }
#endif
#ifdef COMPILE_5106
    case 159: {
      xmlBufferFree((buf));

      break;
    }
#endif
#ifdef COMPILE_5107
    case 160: {
      xmlBufferFree((buf));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5108
    case 161: {
      xmlBufferFree(buf);
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5109
    case 162: {
      xmlBufferLength(buf);

      break;
    }
#endif
#ifdef COMPILE_5110
    case 163: {
      xmlFreeNode((node));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5111
    case 164: {
      xmlInitParser();
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5112
    case 165: {
      xmlUnlinkNode((node));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5113
    case 166: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5114
    case 167: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5115
    case 168: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5116
    case 169: {
      zval_unset_isref_p((id));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5117
    case 170: {
      zval_unset_isref_p((nodep));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5118
    case 171: {
      zval_unset_isref_p((return_value));
      xmlBufferFree(buf);

      break;
    }
#endif
#ifdef COMPILE_5119
    case 172: {
      zval_unset_isref_p((this_ptr));
      xmlBufferFree(buf);

      break;
    }
#endif
    }
  } else {
#if LIBXML_VERSION >= 20623
    // prophet generated patch
    switch (__choose("__ID31")) {
    case 0: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#ifdef COMPILE_5120
    case 1: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5121
    case 2: {
      (buf) = xmlBufferCreate();
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5122
    case 3: {
      (doc_props) = dom_get_doc_props(intern->document);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5123
    case 4: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5124
    case 5: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5125
    case 6: {
      Debug(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5126
    case 7: {
      _convert_to_string(((id)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5127
    case 8: {
      _convert_to_string(((nodep)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5128
    case 9: {
      _convert_to_string(((return_value)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5129
    case 10: {
      _convert_to_string(((this_ptr)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5130
    case 11: {
      _efree(((doc_props)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5131
    case 12: {
      _efree(((id)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5132
    case 13: {
      _efree(((nodep)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5133
    case 14: {
      _efree(((return_value)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5134
    case 15: {
      _efree(((this_ptr)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5135
    case 16: {
      _zval_copy_ctor_func((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5136
    case 17: {
      _zval_copy_ctor_func((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5137
    case 18: {
      _zval_copy_ctor_func((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5138
    case 19: {
      _zval_copy_ctor_func((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5139
    case 20: {
      _zval_dtor(((id)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5140
    case 21: {
      _zval_dtor(((nodep)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5141
    case 22: {
      _zval_dtor(((return_value)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5142
    case 23: {
      _zval_dtor(((this_ptr)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5143
    case 24: {
      _zval_dtor_func((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5144
    case 25: {
      _zval_dtor_func((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5145
    case 26: {
      _zval_dtor_func((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5146
    case 27: {
      _zval_dtor_func((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5147
    case 28: {
      _zval_ptr_dtor((&(id)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5148
    case 29: {
      _zval_ptr_dtor((&(nodep)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5149
    case 30: {
      _zval_ptr_dtor((&(return_value)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5150
    case 31: {
      _zval_ptr_dtor((&(this_ptr)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5151
    case 32: {
      buf = xmlBufferCreate();
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5152
    case 33: {
      convert_to_boolean((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5153
    case 34: {
      convert_to_boolean((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5154
    case 35: {
      convert_to_boolean((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5155
    case 36: {
      convert_to_boolean((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5156
    case 37: {
      convert_to_long((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5157
    case 38: {
      convert_to_long((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5158
    case 39: {
      convert_to_long((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5159
    case 40: {
      convert_to_long((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5160
    case 41: {
      doc_props = dom_get_doc_props((intern)->document);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5161
    case 42: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5162
    case 43: {
      doc_props = dom_get_doc_props(intern->document);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5163
    case 44: {
      exit(1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5164
    case 45: {
      format = (doc_props)->formatoutput;
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5165
    case 46: {
      format = doc_props->formatoutput;
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5166
    case 47: {
      gc_remove_zval_from_buffer((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5167
    case 48: {
      gc_remove_zval_from_buffer((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5168
    case 49: {
      gc_remove_zval_from_buffer((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5169
    case 50: {
      gc_remove_zval_from_buffer((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5170
    case 51: {
      gc_zval_check_possible_root(((id)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5171
    case 52: {
      gc_zval_check_possible_root(((nodep)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5172
    case 53: {
      gc_zval_check_possible_root(((return_value)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5173
    case 54: {
      gc_zval_check_possible_root(((this_ptr)));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5174
    case 55: {
      gc_zval_possible_root((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5175
    case 56: {
      gc_zval_possible_root((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5176
    case 57: {
      gc_zval_possible_root((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5177
    case 58: {
      gc_zval_possible_root((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5178
    case 59: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5179
    case 60: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5180
    case 61: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);

      break;
    }
#endif
#ifdef COMPILE_5181
    case 62: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5182
    case 63: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5183
    case 64: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5184
    case 65: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5185
    case 66: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5186
    case 67: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5187
    case 68: {
      i_zval_ptr_dtor((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5188
    case 69: {
      i_zval_ptr_dtor((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5189
    case 70: {
      i_zval_ptr_dtor((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5190
    case 71: {
      i_zval_ptr_dtor((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5191
    case 72: {
      if (!__is_neg("31-72", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){docp, mem, buf, return_value, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "docp", "mem", "size", "format", "buf",
                    "return_value", "node", "intern", "nodep", "nodeobj",
                    "doc_props", "id", "dom_node_class_entry",
                    "dom_document_class_entry", "ht", "this_ptr"))
        htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5192
    case 73: {
      if (__is_neg("31-73", 3, (int *){size, format, ht}, 0, 0, 13,
                   (void **){docp, mem, buf, return_value, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "docp", "mem", "size", "format", "buf",
                   "return_value", "node", "intern", "nodep", "nodeobj",
                   "doc_props", "id", "dom_node_class_entry",
                   "dom_document_class_entry", "ht", "this_ptr"))
        return;
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5193
    case 74: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5194
    case 75: {
      mem = (xmlChar *)xmlBufferContent(buf);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5195
    case 76: {
      php_dom_create_implementation((return_value_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5196
    case 77: {
      php_dom_create_interator((id), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5197
    case 78: {
      php_dom_create_interator((nodep), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5198
    case 79: {
      php_dom_create_interator((return_value), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5199
    case 80: {
      php_dom_create_interator((this_ptr), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5200
    case 81: {
      php_dom_remove_xinclude_nodes((node));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5201
    case 82: {
      php_dom_remove_xinclude_nodes((node)->children);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5202
    case 83: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5203
    case 84: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5204
    case 85: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5205
    case 86: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5206
    case 87: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5207
    case 88: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5208
    case 89: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5209
    case 90: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5210
    case 91: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5211
    case 92: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5212
    case 93: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5213
    case 94: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5214
    case 95: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5215
    case 96: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5216
    case 97: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5217
    case 98: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5218
    case 99: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5219
    case 100: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5220
    case 101: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5221
    case 102: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5222
    case 103: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5223
    case 104: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5224
    case 105: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5225
    case 106: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5226
    case 107: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5227
    case 108: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5228
    case 109: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5229
    case 110: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5230
    case 111: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5231
    case 112: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5232
    case 113: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5233
    case 114: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5234
    case 115: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5235
    case 116: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5236
    case 117: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5237
    case 118: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5238
    case 119: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5239
    case 120: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5240
    case 121: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5241
    case 122: {
      php_dom_throw_error((PHP_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5242
    case 123: {
      php_dom_throw_error((PHP_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5243
    case 124: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5244
    case 125: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5245
    case 126: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5246
    case 127: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5247
    case 128: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5248
    case 129: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5249
    case 130: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5250
    case 131: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5251
    case 132: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5252
    case 133: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5253
    case 134: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5254
    case 135: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5255
    case 136: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5256
    case 137: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5257
    case 138: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5258
    case 139: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5259
    case 140: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5260
    case 141: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5261
    case 142: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5262
    case 143: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5263
    case 144: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5264
    case 145: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5265
    case 146: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5266
    case 147: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5267
    case 148: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5268
    case 149: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5269
    case 150: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5270
    case 151: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5271
    case 152: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5272
    case 153: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5273
    case 154: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5274
    case 155: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5275
    case 156: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5276
    case 157: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5277
    case 158: {
      php_libxml_node_free_resource((node));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5278
    case 159: {
      php_printf(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5279
    case 160: {
      printf(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5280
    case 161: {
      scanf(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5281
    case 162: {
      xmlBufferFree((buf));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5282
    case 163: {
      xmlBufferFree(buf);
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5283
    case 164: {
      xmlDocDumpFormatMemory(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5284
    case 165: {
      xmlFreeNode((node));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5285
    case 166: {
      xmlInitParser();
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5286
    case 167: {
      xmlUnlinkNode((node));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5287
    case 168: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5288
    case 169: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5289
    case 170: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5290
    case 171: {
      zval_unset_isref_p((id));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5291
    case 172: {
      zval_unset_isref_p((nodep));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5292
    case 173: {
      zval_unset_isref_p((return_value));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
#ifdef COMPILE_5293
    case 174: {
      zval_unset_isref_p((this_ptr));
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);

      break;
    }
#endif
    }
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    // prophet generated patch
    switch (__choose("__ID32")) {
    case 0: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#ifdef COMPILE_5294
    case 1: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        (*(__xmlSaveNoEmptyTags())) = 1;
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5295
    case 2: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        (buf) = xmlBufferCreate();
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5296
    case 3: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        (doc_props) = dom_get_doc_props(intern->document);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5297
    case 4: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        (executor_globals.argument_stack) =
            zend_vm_stack_new_page(((16 * 1024) - 16));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5298
    case 5: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        (mem) = (xmlChar *)xmlBufferContent(buf);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5299
    case 6: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((id)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5300
    case 7: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((nodep)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5301
    case 8: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((return_value)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5302
    case 9: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _convert_to_string(((this_ptr)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5303
    case 10: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _efree(((doc_props)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5304
    case 11: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _efree(((id)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5305
    case 12: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _efree(((nodep)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5306
    case 13: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _efree(((return_value)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5307
    case 14: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _efree(((this_ptr)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5308
    case 15: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5309
    case 16: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5310
    case 17: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5311
    case 18: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_copy_ctor_func((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5312
    case 19: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((id)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5313
    case 20: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((nodep)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5314
    case 21: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((return_value)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5315
    case 22: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor(((this_ptr)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5316
    case 23: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5317
    case 24: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5318
    case 25: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5319
    case 26: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_dtor_func((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5320
    case 27: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(id)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5321
    case 28: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(nodep)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5322
    case 29: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(return_value)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5323
    case 30: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        _zval_ptr_dtor((&(this_ptr)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5324
    case 31: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        buf = xmlBufferCreate();
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5325
    case 32: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5326
    case 33: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5327
    case 34: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5328
    case 35: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_boolean((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5329
    case 36: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_long((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5330
    case 37: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_long((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5331
    case 38: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_long((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5332
    case 39: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        convert_to_long((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5333
    case 40: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        doc_props = dom_get_doc_props((intern)->document);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5334
    case 41: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        doc_props = dom_get_doc_props((nodeobj)->document);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5335
    case 42: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        doc_props = dom_get_doc_props(intern->document);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5336
    case 43: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        exit(1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5337
    case 44: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        format = (doc_props)->formatoutput;
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5338
    case 45: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        format = doc_props->formatoutput;
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5339
    case 46: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5340
    case 47: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5341
    case 48: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5342
    case 49: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_remove_zval_from_buffer((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5343
    case 50: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((id)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5344
    case 51: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((nodep)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5345
    case 52: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((return_value)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5346
    case 53: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_check_possible_root(((this_ptr)));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5347
    case 54: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5348
    case 55: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5349
    case 56: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5350
    case 57: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        gc_zval_possible_root((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5351
    case 58: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlDocDumpMemoryFormat((docp), &mem, &size, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5352
    case 59: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5353
    case 60: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlDocDumpMemoryFormat(docp, &mem, &size, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5354
    case 61: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5355
    case 62: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5356
    case 63: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5357
    case 64: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5358
    case 65: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5359
    case 66: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5360
    case 67: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5361
    case 68: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        i_zval_ptr_dtor((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5362
    case 69: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        if (!__is_neg("32-69", 3, (int *){size, format, ht}, 0, 0, 13,
                      (void **){return_value, mem, docp, buf, node, intern,
                                nodep, nodeobj, doc_props, id,
                                dom_node_class_entry, dom_document_class_entry,
                                this_ptr},
                      0, 0, 16, "return_value", "mem", "size", "docp", "format",
                      "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                      "id", "dom_node_class_entry", "dom_document_class_entry",
                      "ht", "this_ptr"))
          do {
            const char *__s = (mem);
            int __l = size;
            zval *__z = (return_value);
            (*__z).value.str.len = __l;
            (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
            (*__z).type = 6;
          } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5363
    case 70: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        if (__is_neg("32-70", 3, (int *){size, format, ht}, 0, 0, 13,
                     (void **){return_value, mem, docp, buf, node, intern,
                               nodep, nodeobj, doc_props, id,
                               dom_node_class_entry, dom_document_class_entry,
                               this_ptr},
                     0, 0, 16, "return_value", "mem", "size", "docp", "format",
                     "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                     "id", "dom_node_class_entry", "dom_document_class_entry",
                     "ht", "this_ptr"))
          return;
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5364
    case 71: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                         dom_document_class_entry, &nodep,
                                         dom_node_class_entry) == -1) {
          return;
        }
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5365
    case 72: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        mem = (xmlChar *)xmlBufferContent(buf);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5366
    case 73: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_create_implementation((return_value_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5367
    case 74: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((id), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5368
    case 75: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((nodep), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5369
    case 76: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((return_value), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5370
    case 77: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_create_interator((this_ptr), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5371
    case 78: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_remove_xinclude_nodes((node));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5372
    case 79: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_remove_xinclude_nodes((node)->children);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5373
    case 80: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5374
    case 81: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5375
    case 82: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((DOMSTRING_SIZE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5376
    case 83: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5377
    case 84: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5378
    case 85: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5379
    case 86: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INDEX_SIZE_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5380
    case 87: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INDEX_SIZE_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5381
    case 88: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INDEX_SIZE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5382
    case 89: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5383
    case 90: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5384
    case 91: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5385
    case 92: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_ACCESS_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5386
    case 93: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_ACCESS_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5387
    case 94: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_ACCESS_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5388
    case 95: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5389
    case 96: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5390
    case 97: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_CHARACTER_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5391
    case 98: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5392
    case 99: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5393
    case 100: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_MODIFICATION_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5394
    case 101: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_STATE_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5395
    case 102: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_STATE_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5396
    case 103: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((INVALID_STATE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5397
    case 104: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NAMESPACE_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5398
    case 105: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NAMESPACE_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5399
    case 106: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NAMESPACE_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5400
    case 107: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_FOUND_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5401
    case 108: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_FOUND_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5402
    case 109: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_FOUND_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5403
    case 110: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5404
    case 111: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5405
    case 112: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NOT_SUPPORTED_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5406
    case 113: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5407
    case 114: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5408
    case 115: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5409
    case 116: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5410
    case 117: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5411
    case 118: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5412
    case 119: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((PHP_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5413
    case 120: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((PHP_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5414
    case 121: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5415
    case 122: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((SYNTAX_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5416
    case 123: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((SYNTAX_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5417
    case 124: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((SYNTAX_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5418
    case 125: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((VALIDATION_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5419
    case 126: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((VALIDATION_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5420
    case 127: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((VALIDATION_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5421
    case 128: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5422
    case 129: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5423
    case 130: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error((WRONG_DOCUMENT_ERR),
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5424
    case 131: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_CHARACTER_ERR,
                            dom_get_strict_error((intern)->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5425
    case 132: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_CHARACTER_ERR,
                            dom_get_strict_error((nodeobj)->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5426
    case 133: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_STATE_ERR, 0);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5427
    case 134: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(INVALID_STATE_ERR, 1);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5428
    case 135: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error((intern)->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5429
    case 136: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error((nodeobj)->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5430
    case 137: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5431
    case 138: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Cannot create required DOM object");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5432
    case 139: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Cannot import: Node Type Not Supported");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5433
    case 140: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5434
    case 141: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          (intern)->std.ce->name);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5435
    case 142: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          (nodeobj)->std.ce->name);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5436
    case 143: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          intern->std.ce->name);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5437
    case 144: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5438
    case 145: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Document Missing Root Element");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5439
    case 146: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Empty string supplied as input");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5440
    case 147: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5441
    case 148: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5442
    case 149: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L),
                          "Invalid RelaxNG file source");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5443
    case 150: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5444
    case 151: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5445
    case 152: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5446
    case 153: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5447
    case 154: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5448
    case 155: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        php_libxml_node_free_resource((node));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5449
    case 156: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        xmlBufferFree((buf));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5450
    case 157: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        xmlBufferFree(buf);
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5451
    case 158: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        xmlFreeNode((node));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5452
    case 159: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        xmlInitParser();
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5453
    case 160: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        xmlUnlinkNode((node));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5454
    case 161: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5455
    case 162: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zend_error((1 << 0L), "Invalid Schema Validation Context");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5456
    case 163: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zend_error((1 << 3L), "A non well formed numeric value encountered");
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5457
    case 164: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((id));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5458
    case 165: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((nodep));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5459
    case 166: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((return_value));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5460
    case 167: {
      if (!size) {
        RETVAL_FALSE;
      } else {
        zval_unset_isref_p((this_ptr));
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5461
    case 168: {
      (*(__xmlSaveNoEmptyTags())) = 1;
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5462
    case 169: {
      (buf) = xmlBufferCreate();
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5463
    case 170: {
      (doc_props) = dom_get_doc_props(intern->document);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5464
    case 171: {
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5465
    case 172: {
      (mem) = (xmlChar *)xmlBufferContent(buf);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5466
    case 173: {
      _convert_to_string(((id)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5467
    case 174: {
      _convert_to_string(((nodep)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5468
    case 175: {
      _convert_to_string(((return_value)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5469
    case 176: {
      _convert_to_string(((this_ptr)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5470
    case 177: {
      _efree(((doc_props)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5471
    case 178: {
      _efree(((id)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5472
    case 179: {
      _efree(((nodep)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5473
    case 180: {
      _efree(((return_value)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5474
    case 181: {
      _efree(((this_ptr)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5475
    case 182: {
      _zval_copy_ctor_func((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5476
    case 183: {
      _zval_copy_ctor_func((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5477
    case 184: {
      _zval_copy_ctor_func((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5478
    case 185: {
      _zval_copy_ctor_func((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5479
    case 186: {
      _zval_dtor(((id)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5480
    case 187: {
      _zval_dtor(((nodep)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5481
    case 188: {
      _zval_dtor(((return_value)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5482
    case 189: {
      _zval_dtor(((this_ptr)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5483
    case 190: {
      _zval_dtor_func((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5484
    case 191: {
      _zval_dtor_func((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5485
    case 192: {
      _zval_dtor_func((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5486
    case 193: {
      _zval_dtor_func((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5487
    case 194: {
      _zval_ptr_dtor((&(id)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5488
    case 195: {
      _zval_ptr_dtor((&(nodep)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5489
    case 196: {
      _zval_ptr_dtor((&(return_value)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5490
    case 197: {
      _zval_ptr_dtor((&(this_ptr)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5491
    case 198: {
      buf = xmlBufferCreate();
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5492
    case 199: {
      convert_to_boolean((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5493
    case 200: {
      convert_to_boolean((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5494
    case 201: {
      convert_to_boolean((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5495
    case 202: {
      convert_to_boolean((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5496
    case 203: {
      convert_to_long((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5497
    case 204: {
      convert_to_long((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5498
    case 205: {
      convert_to_long((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5499
    case 206: {
      convert_to_long((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5500
    case 207: {
      doc_props = dom_get_doc_props((intern)->document);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5501
    case 208: {
      doc_props = dom_get_doc_props((nodeobj)->document);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5502
    case 209: {
      doc_props = dom_get_doc_props(intern->document);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5503
    case 210: {
      exit(1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5504
    case 211: {
      format = (doc_props)->formatoutput;
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5505
    case 212: {
      format = doc_props->formatoutput;
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5506
    case 213: {
      gc_remove_zval_from_buffer((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5507
    case 214: {
      gc_remove_zval_from_buffer((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5508
    case 215: {
      gc_remove_zval_from_buffer((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5509
    case 216: {
      gc_remove_zval_from_buffer((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5510
    case 217: {
      gc_zval_check_possible_root(((id)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5511
    case 218: {
      gc_zval_check_possible_root(((nodep)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5512
    case 219: {
      gc_zval_check_possible_root(((return_value)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5513
    case 220: {
      gc_zval_check_possible_root(((this_ptr)));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5514
    case 221: {
      gc_zval_possible_root((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5515
    case 222: {
      gc_zval_possible_root((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5516
    case 223: {
      gc_zval_possible_root((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5517
    case 224: {
      gc_zval_possible_root((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5518
    case 225: {
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5519
    case 226: {
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5520
    case 227: {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5521
    case 228: {
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5522
    case 229: {
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5523
    case 230: {
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5524
    case 231: {
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5525
    case 232: {
      i_zval_ptr_dtor((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5526
    case 233: {
      i_zval_ptr_dtor((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5527
    case 234: {
      i_zval_ptr_dtor((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5528
    case 235: {
      i_zval_ptr_dtor((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5529
    case 236: {
      if (!__is_neg("32-236", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){return_value, mem, docp, buf, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "size", "return_value", "mem", "docp", "format",
                    "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr") &&
          (!size)) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5530
    case 237: {
      if (!__is_neg("32-237", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){return_value, mem, docp, buf, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "size", "return_value", "mem", "docp", "format",
                    "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        if (!size) {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
        } else {
          do {
            const char *__s = (mem);
            int __l = size;
            zval *__z = (return_value);
            (*__z).value.str.len = __l;
            (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
            (*__z).type = 6;
          } while (0);
        }

      break;
    }
#endif
#ifdef COMPILE_5531
    case 238: {
      if ((!size) &&
          !__is_neg("32-238", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){return_value, mem, docp, buf, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "size", "return_value", "mem", "docp", "format",
                    "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr")) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5532
    case 239: {
      if ((!size) ||
          __is_neg("32-239", 3, (int *){size, format, ht}, 0, 0, 13,
                   (void **){return_value, mem, docp, buf, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "size", "return_value", "mem", "docp", "format",
                   "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr")) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5533
    case 240: {
      if (__is_neg("32-240", 3, (int *){size, format, ht}, 0, 0, 13,
                   (void **){return_value, mem, docp, buf, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "size", "return_value", "mem", "docp", "format",
                   "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5534
    case 241: {
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5535
    case 242: {
      mem = (xmlChar *)xmlBufferContent(buf);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5536
    case 243: {
      php_dom_create_implementation((return_value_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5537
    case 244: {
      php_dom_create_interator((id), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5538
    case 245: {
      php_dom_create_interator((nodep), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5539
    case 246: {
      php_dom_create_interator((return_value), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5540
    case 247: {
      php_dom_create_interator((this_ptr), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5541
    case 248: {
      php_dom_remove_xinclude_nodes((node));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5542
    case 249: {
      php_dom_remove_xinclude_nodes((node)->children);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5543
    case 250: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5544
    case 251: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5545
    case 252: {
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5546
    case 253: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5547
    case 254: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5548
    case 255: {
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5549
    case 256: {
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5550
    case 257: {
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5551
    case 258: {
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5552
    case 259: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5553
    case 260: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5554
    case 261: {
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5555
    case 262: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5556
    case 263: {
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5557
    case 264: {
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5558
    case 265: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5559
    case 266: {
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5560
    case 267: {
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5561
    case 268: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5562
    case 269: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5563
    case 270: {
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5564
    case 271: {
      php_dom_throw_error((INVALID_STATE_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5565
    case 272: {
      php_dom_throw_error((INVALID_STATE_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5566
    case 273: {
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5567
    case 274: {
      php_dom_throw_error((NAMESPACE_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5568
    case 275: {
      php_dom_throw_error((NAMESPACE_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5569
    case 276: {
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5570
    case 277: {
      php_dom_throw_error((NOT_FOUND_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5571
    case 278: {
      php_dom_throw_error((NOT_FOUND_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5572
    case 279: {
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5573
    case 280: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5574
    case 281: {
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5575
    case 282: {
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5576
    case 283: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5577
    case 284: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5578
    case 285: {
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5579
    case 286: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5580
    case 287: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5581
    case 288: {
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5582
    case 289: {
      php_dom_throw_error((PHP_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5583
    case 290: {
      php_dom_throw_error((PHP_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5584
    case 291: {
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5585
    case 292: {
      php_dom_throw_error((SYNTAX_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5586
    case 293: {
      php_dom_throw_error((SYNTAX_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5587
    case 294: {
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5588
    case 295: {
      php_dom_throw_error((VALIDATION_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5589
    case 296: {
      php_dom_throw_error((VALIDATION_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5590
    case 297: {
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5591
    case 298: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5592
    case 299: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5593
    case 300: {
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5594
    case 301: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5595
    case 302: {
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5596
    case 303: {
      php_dom_throw_error(INVALID_STATE_ERR, 0);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5597
    case 304: {
      php_dom_throw_error(INVALID_STATE_ERR, 1);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5598
    case 305: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5599
    case 306: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5600
    case 307: {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5601
    case 308: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5602
    case 309: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5603
    case 310: {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5604
    case 311: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5605
    case 312: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5606
    case 313: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5607
    case 314: {
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5608
    case 315: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5609
    case 316: {
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5610
    case 317: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5611
    case 318: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5612
    case 319: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5613
    case 320: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5614
    case 321: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5615
    case 322: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5616
    case 323: {
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5617
    case 324: {
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5618
    case 325: {
      php_libxml_node_free_resource((node));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5619
    case 326: {
      xmlBufferFree((buf));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5620
    case 327: {
      xmlBufferFree(buf);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5621
    case 328: {
      xmlFreeNode((node));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5622
    case 329: {
      xmlInitParser();
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5623
    case 330: {
      xmlUnlinkNode((node));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5624
    case 331: {
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5625
    case 332: {
      zend_error((1 << 0L), "Invalid Schema Validation Context");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5626
    case 333: {
      zend_error((1 << 3L), "A non well formed numeric value encountered");
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5627
    case 334: {
      zval_unset_isref_p((id));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5628
    case 335: {
      zval_unset_isref_p((nodep));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5629
    case 336: {
      zval_unset_isref_p((return_value));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
#ifdef COMPILE_5630
    case 337: {
      zval_unset_isref_p((this_ptr));
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }

      break;
    }
#endif
    }
    if (mem)
      xmlFree(mem);
  }
}
/* }}} end dom_document_save_html */

#endif /* defined(LIBXML_HTML_ENABLED) */

/* {{{ proto boolean DOMDocument::registerNodeClass(string baseclass, string
   extendedclass); Register extended class used to create base node type */
PHP_METHOD(domdocument, registerNodeClass) {
  zval *id;
  xmlDoc *docp;
  char *baseclass = NULL, *extendedclass = NULL;
  int baseclass_len = 0, extendedclass_len = 0;
  zend_class_entry *basece = NULL, *ce = NULL;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oss!",
                                   &id, dom_document_class_entry, &baseclass,
                                   &baseclass_len, &extendedclass,
                                   &extendedclass_len) == FAILURE) {
    return;
  }

  if (baseclass_len) {
    zend_class_entry **pce;
    if (zend_lookup_class(baseclass, baseclass_len, &pce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR, "Class %s does not exist",
                       baseclass);
      return;
    }
    basece = *pce;
  }

  if (basece == NULL ||
      !instanceof_function(basece, dom_node_class_entry TSRMLS_CC)) {
    php_error_docref(NULL TSRMLS_CC, E_ERROR,
                     "Class %s is not derived from DOMNode.", baseclass);
    return;
  }

  if (extendedclass_len) {
    zend_class_entry **pce;
    if (zend_lookup_class(extendedclass, extendedclass_len, &pce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR, "Class %s does not exist",
                       extendedclass);
    }
    ce = *pce;
  }

  if (ce == NULL || instanceof_function(ce, basece TSRMLS_CC)) {

    DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

    if (dom_set_doc_classmap(intern->document, basece, ce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR,
                       "Class %s could not be registered.", extendedclass);
    }
    RETURN_TRUE;
  } else {
    php_error_docref(NULL TSRMLS_CC, E_ERROR,
                     "Class %s is not derived from %s.", extendedclass,
                     baseclass);
  }

  RETURN_FALSE;
}
/* }}} */

#endif /* HAVE_LIBXML && HAVE_DOM */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
// prophet generated patch
switch (__choose("__ID33")) {
case 0: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#ifdef COMPILE_5631
case 1: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (*(__xmlSaveNoEmptyTags())) = 1;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5632
case 2: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (buf) = xmlBufferCreate();
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5633
case 3: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (doc_props) = dom_get_doc_props(intern->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5634
case 4: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5635
case 5: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (mem) = (xmlChar *)xmlBufferContent(buf);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5636
case 6: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5637
case 7: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5638
case 8: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5639
case 9: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5640
case 10: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((doc_props)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5641
case 11: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5642
case 12: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5643
case 13: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5644
case 14: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5645
case 15: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5646
case 16: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zend_mem_block_size(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5647
case 17: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5648
case 18: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5649
case 19: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5650
case 20: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5651
case 21: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5652
case 22: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5653
case 23: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5654
case 24: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5655
case 25: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5656
case 26: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5657
case 27: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5658
case 28: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5659
case 29: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5660
case 30: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5661
case 31: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5662
case 32: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5663
case 33: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      brk(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5664
case 34: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      buf = xmlBufferCreate();
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5665
case 35: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5666
case 36: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5667
case 37: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5668
case 38: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5669
case 39: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5670
case 40: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5671
case 41: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5672
case 42: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5673
case 43: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      dlclose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5674
case 44: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      doc_props = dom_get_doc_props((intern)->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5675
case 45: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      doc_props = dom_get_doc_props((nodeobj)->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5676
case 46: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      doc_props = dom_get_doc_props(intern->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5677
case 47: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      endDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5678
case 48: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      exit(1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5679
case 49: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      format = (doc_props)->formatoutput;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5680
case 50: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      format = doc_props->formatoutput;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5681
case 51: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      free(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5682
case 52: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5683
case 53: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5684
case 54: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5685
case 55: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5686
case 56: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5687
case 57: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5688
case 58: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5689
case 59: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5690
case 60: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5691
case 61: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5692
case 62: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5693
case 63: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5694
case 64: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getColumnNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5695
case 65: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getLineNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5696
case 66: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getNamespace(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5697
case 67: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getPublicId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5698
case 68: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getSystemId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5699
case 69: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      hasExternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5700
case 70: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      hasInternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5701
case 71: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5702
case 72: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5703
case 73: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5704
case 74: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5705
case 75: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5706
case 76: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5707
case 77: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5708
case 78: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5709
case 79: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5710
case 80: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5711
case 81: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5712
case 82: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      iconv_close(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5713
case 83: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      if (!__is_neg("33-83", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){mem, return_value, docp, buf, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "mem", "return_value", "size", "docp", "format",
                    "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5714
case 84: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      if (__is_neg("33-84", 3, (int *){size, format, ht}, 0, 0, 13,
                   (void **){mem, return_value, docp, buf, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "mem", "return_value", "size", "docp", "format",
                   "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5715
case 85: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5716
case 86: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      isStandalone(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5717
case 87: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      list_entry_destructor(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5718
case 88: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      mem = (xmlChar *)xmlBufferContent(buf);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5719
case 89: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_implementation((return_value_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5720
case 90: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((id), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5721
case 91: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((nodep), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5722
case 92: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((return_value), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5723
case 93: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((this_ptr), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5724
case 94: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_remove_xinclude_nodes((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5725
case 95: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_remove_xinclude_nodes((node)->children);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5726
case 96: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5727
case 97: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5728
case 98: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5729
case 99: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5730
case 100: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5731
case 101: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5732
case 102: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5733
case 103: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5734
case 104: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5735
case 105: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5736
case 106: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5737
case 107: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5738
case 108: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5739
case 109: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5740
case 110: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5741
case 111: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5742
case 112: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5743
case 113: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5744
case 114: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5745
case 115: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5746
case 116: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5747
case 117: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_STATE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5748
case 118: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_STATE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5749
case 119: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5750
case 120: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NAMESPACE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5751
case 121: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NAMESPACE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5752
case 122: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5753
case 123: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_FOUND_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5754
case 124: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_FOUND_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5755
case 125: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5756
case 126: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5757
case 127: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5758
case 128: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5759
case 129: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5760
case 130: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5761
case 131: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5762
case 132: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5763
case 133: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5764
case 134: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5765
case 135: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((PHP_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5766
case 136: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((PHP_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5767
case 137: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5768
case 138: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((SYNTAX_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5769
case 139: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((SYNTAX_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5770
case 140: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5771
case 141: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((VALIDATION_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5772
case 142: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((VALIDATION_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5773
case 143: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5774
case 144: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5775
case 145: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5776
case 146: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5777
case 147: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5778
case 148: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5779
case 149: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_STATE_ERR, 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5780
case 150: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_STATE_ERR, 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5781
case 151: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5782
case 152: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5783
case 153: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5784
case 154: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5785
case 155: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5786
case 156: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5787
case 157: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5788
case 158: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5789
case 159: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5790
case 160: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5791
case 161: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5792
case 162: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5793
case 163: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5794
case 164: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5795
case 165: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5796
case 166: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5797
case 167: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5798
case 168: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5799
case 169: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5800
case 170: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5801
case 171: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_libxml_node_free_resource((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5802
case 172: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      plist_entry_destructor(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5803
case 173: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      startDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5804
case 174: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      timer_delete(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5805
case 175: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      timer_getoverrun(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5806
case 176: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlBufferFree((buf));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5807
case 177: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlBufferFree(buf);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5808
case 178: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlCtxtGetLastError(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5809
case 179: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlCtxtResetLastError(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5810
case 180: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlFileClose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5811
case 181: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlFreeNode((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5812
case 182: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlIOFTPClose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5813
case 183: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlIOHTTPClose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5814
case 184: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlInitParser();
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5815
case 185: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlMemFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5816
case 186: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2EndDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5817
case 187: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetColumnNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5818
case 188: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetLineNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5819
case 189: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetPublicId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5820
case 190: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetSystemId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5821
case 191: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2HasExternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5822
case 192: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2HasInternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5823
case 193: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2IsStandalone(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5824
case 194: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2StartDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5825
case 195: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlUnlinkNode((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5826
case 196: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlXPathWrapExternal(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5827
case 197: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5828
case 198: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_error((1 << 0L), "Invalid Schema Validation Context");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5829
case 199: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_error((1 << 3L), "A non well formed numeric value encountered");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5830
case 200: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_free(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5831
case 201: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_free_int(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5832
case 202: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_push(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5833
case 203: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_push_nocheck(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5834
case 204: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5835
case 205: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5836
case 206: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5837
case 207: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5838
case 208: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (*(__xmlSaveNoEmptyTags())) = 1;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5839
case 209: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (buf) = xmlBufferCreate();
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5840
case 210: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (doc_props) = dom_get_doc_props(intern->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5841
case 211: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (executor_globals.argument_stack) =
          zend_vm_stack_new_page(((16 * 1024) - 16));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5842
case 212: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      (mem) = (xmlChar *)xmlBufferContent(buf);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5843
case 213: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5844
case 214: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5845
case 215: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5846
case 216: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _convert_to_string(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5847
case 217: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((doc_props)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5848
case 218: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5849
case 219: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5850
case 220: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5851
case 221: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5852
case 222: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _efree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5853
case 223: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zend_mem_block_size(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5854
case 224: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5855
case 225: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5856
case 226: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5857
case 227: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_copy_ctor_func((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5858
case 228: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5859
case 229: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5860
case 230: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5861
case 231: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5862
case 232: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5863
case 233: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5864
case 234: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5865
case 235: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_dtor_func((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5866
case 236: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5867
case 237: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5868
case 238: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5869
case 239: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      _zval_ptr_dtor((&(this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5870
case 240: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      brk(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5871
case 241: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      buf = xmlBufferCreate();
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5872
case 242: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5873
case 243: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5874
case 244: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5875
case 245: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_boolean((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5876
case 246: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5877
case 247: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5878
case 248: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5879
case 249: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      convert_to_long((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5880
case 250: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      dlclose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5881
case 251: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      doc_props = dom_get_doc_props((intern)->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5882
case 252: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      doc_props = dom_get_doc_props((nodeobj)->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5883
case 253: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      doc_props = dom_get_doc_props(intern->document);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5884
case 254: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      endDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5885
case 255: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      exit(1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5886
case 256: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      format = (doc_props)->formatoutput;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5887
case 257: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      format = doc_props->formatoutput;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5888
case 258: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      free(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5889
case 259: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5890
case 260: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5891
case 261: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5892
case 262: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_remove_zval_from_buffer((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5893
case 263: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((id)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5894
case 264: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((nodep)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5895
case 265: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((return_value)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5896
case 266: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_check_possible_root(((this_ptr)));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5897
case 267: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5898
case 268: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5899
case 269: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5900
case 270: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      gc_zval_possible_root((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5901
case 271: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getColumnNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5902
case 272: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getLineNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5903
case 273: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getNamespace(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5904
case 274: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getPublicId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5905
case 275: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      getSystemId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5906
case 276: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      hasExternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5907
case 277: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      hasInternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5908
case 278: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlDocDumpMemoryFormat((docp), &mem, &size, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5909
case 279: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5910
case 280: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5911
case 281: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5912
case 282: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5913
case 283: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5914
case 284: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5915
case 285: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5916
case 286: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5917
case 287: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5918
case 288: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      i_zval_ptr_dtor((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5919
case 289: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      iconv_close(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5920
case 290: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      if (!__is_neg("33-290", 3, (int *){size, format, ht}, 0, 0, 13,
                    (void **){mem, return_value, docp, buf, node, intern, nodep,
                              nodeobj, doc_props, id, dom_node_class_entry,
                              dom_document_class_entry, this_ptr},
                    0, 0, 16, "mem", "return_value", "size", "docp", "format",
                    "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                    "id", "dom_node_class_entry", "dom_document_class_entry",
                    "ht", "this_ptr"))
        xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5921
case 291: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      if (__is_neg("33-291", 3, (int *){size, format, ht}, 0, 0, 13,
                   (void **){mem, return_value, docp, buf, node, intern, nodep,
                             nodeobj, doc_props, id, dom_node_class_entry,
                             dom_document_class_entry, this_ptr},
                   0, 0, 16, "mem", "return_value", "size", "docp", "format",
                   "buf", "node", "intern", "nodep", "nodeobj", "doc_props",
                   "id", "dom_node_class_entry", "dom_document_class_entry",
                   "ht", "this_ptr"))
        return;
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5922
case 292: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                       dom_document_class_entry, &nodep,
                                       dom_node_class_entry) == -1) {
        return;
      }
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5923
case 293: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      isStandalone(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5924
case 294: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      list_entry_destructor(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5925
case 295: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      mem = (xmlChar *)xmlBufferContent(buf);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5926
case 296: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_implementation((return_value_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5927
case 297: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((id), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5928
case 298: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((nodep), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5929
case 299: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((return_value), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5930
case 300: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_create_interator((this_ptr), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5931
case 301: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_remove_xinclude_nodes((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5932
case 302: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_remove_xinclude_nodes((node)->children);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5933
case 303: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5934
case 304: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5935
case 305: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((DOMSTRING_SIZE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5936
case 306: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5937
case 307: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5938
case 308: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5939
case 309: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INDEX_SIZE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5940
case 310: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INDEX_SIZE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5941
case 311: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INDEX_SIZE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5942
case 312: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5943
case 313: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5944
case 314: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5945
case 315: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_ACCESS_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5946
case 316: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_ACCESS_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5947
case 317: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_ACCESS_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5948
case 318: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5949
case 319: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5950
case 320: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_CHARACTER_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5951
case 321: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5952
case 322: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5953
case 323: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_MODIFICATION_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5954
case 324: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_STATE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5955
case 325: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_STATE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5956
case 326: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((INVALID_STATE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5957
case 327: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NAMESPACE_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5958
case 328: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NAMESPACE_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5959
case 329: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NAMESPACE_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5960
case 330: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_FOUND_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5961
case 331: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_FOUND_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5962
case 332: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_FOUND_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5963
case 333: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5964
case 334: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5965
case 335: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NOT_SUPPORTED_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5966
case 336: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5967
case 337: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5968
case 338: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5969
case 339: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5970
case 340: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5971
case 341: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5972
case 342: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((PHP_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5973
case 343: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((PHP_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5974
case 344: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5975
case 345: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((SYNTAX_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5976
case 346: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((SYNTAX_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5977
case 347: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5978
case 348: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((VALIDATION_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5979
case 349: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((VALIDATION_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5980
case 350: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((VALIDATION_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5981
case 351: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5982
case 352: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5983
case 353: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error((WRONG_DOCUMENT_ERR),
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5984
case 354: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((intern)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5985
case 355: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_CHARACTER_ERR,
                          dom_get_strict_error((nodeobj)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5986
case 356: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_STATE_ERR, 0);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5987
case 357: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(INVALID_STATE_ERR, 1);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5988
case 358: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((intern)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5989
case 359: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error((nodeobj)->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5990
case 360: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5991
case 361: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot create required DOM object");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5992
case 362: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Cannot import: Node Type Not Supported");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5993
case 363: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5994
case 364: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (intern)->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5995
case 365: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        (nodeobj)->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5996
case 366: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        intern->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5997
case 367: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                        nodeobj->std.ce->name);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5998
case 368: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Document Missing Root Element");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_5999
case 369: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L),
                        "Empty string supplied as input");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6000
case 370: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6001
case 371: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6002
case 372: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6003
case 373: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6004
case 374: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6005
case 375: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6006
case 376: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6007
case 377: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6008
case 378: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      php_libxml_node_free_resource((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6009
case 379: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      plist_entry_destructor(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6010
case 380: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      startDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6011
case 381: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      timer_delete(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6012
case 382: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      timer_getoverrun(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6013
case 383: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlBufferFree((buf));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6014
case 384: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlBufferFree(buf);
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6015
case 385: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlCtxtGetLastError(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6016
case 386: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlCtxtResetLastError(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6017
case 387: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlFileClose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6018
case 388: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlFreeNode((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6019
case 389: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlIOFTPClose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6020
case 390: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlIOHTTPClose(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6021
case 391: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlInitParser();
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6022
case 392: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlMemFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6023
case 393: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2EndDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6024
case 394: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetColumnNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6025
case 395: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetLineNumber(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6026
case 396: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetPublicId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6027
case 397: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2GetSystemId(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6028
case 398: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2HasExternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6029
case 399: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2HasInternalSubset(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6030
case 400: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2IsStandalone(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6031
case 401: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlSAX2StartDocument(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6032
case 402: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlUnlinkNode((node));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6033
case 403: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      xmlXPathWrapExternal(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6034
case 404: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6035
case 405: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_error((1 << 0L), "Invalid Schema Validation Context");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6036
case 406: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_error((1 << 3L), "A non well formed numeric value encountered");
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6037
case 407: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_free(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6038
case 408: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_free_int(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6039
case 409: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_push(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6040
case 410: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zend_vm_stack_push_nocheck(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6041
case 411: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((id));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6042
case 412: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((nodep));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6043
case 413: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((return_value));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6044
case 414: {
  if (nodep != NULL) {
    /* Dump contents of Node */
    DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document) TSRMLS_CC);
      RETURN_FALSE;
    }

    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer");
      RETURN_FALSE;
    }

    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRING(mem, 1);
    }
    xmlBufferFree(buf);
  } else {
#if LIBXML_VERSION >= 20623
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
#else
    htmlDocDumpMemory(docp, &mem, &size);
#endif
    if (!size) {
      RETVAL_FALSE;
    } else {
      RETVAL_STRINGL(mem, size, 1);
    }
    if (mem)
      zval_unset_isref_p((this_ptr));
    xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6045
case 415: {
  (*(__xmlSaveNoEmptyTags())) = 1;
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6046
case 416: {
  (buf) = xmlBufferCreate();
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6047
case 417: {
  (doc_props) = dom_get_doc_props(intern->document);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6048
case 418: {
  (executor_globals.argument_stack) =
      zend_vm_stack_new_page(((16 * 1024) - 16));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6049
case 419: {
  (mem) = (xmlChar *)xmlBufferContent(buf);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6050
case 420: {
  _convert_to_string(((id)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6051
case 421: {
  _convert_to_string(((nodep)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6052
case 422: {
  _convert_to_string(((return_value)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6053
case 423: {
  _convert_to_string(((this_ptr)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6054
case 424: {
  _efree(((doc_props)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6055
case 425: {
  _efree(((id)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6056
case 426: {
  _efree(((nodep)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6057
case 427: {
  _efree(((return_value)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6058
case 428: {
  _efree(((this_ptr)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6059
case 429: {
  _zval_copy_ctor_func((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6060
case 430: {
  _zval_copy_ctor_func((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6061
case 431: {
  _zval_copy_ctor_func((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6062
case 432: {
  _zval_copy_ctor_func((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6063
case 433: {
  _zval_dtor(((id)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6064
case 434: {
  _zval_dtor(((nodep)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6065
case 435: {
  _zval_dtor(((return_value)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6066
case 436: {
  _zval_dtor(((this_ptr)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6067
case 437: {
  _zval_dtor_func((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6068
case 438: {
  _zval_dtor_func((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6069
case 439: {
  _zval_dtor_func((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6070
case 440: {
  _zval_dtor_func((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6071
case 441: {
  _zval_ptr_dtor((&(id)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6072
case 442: {
  _zval_ptr_dtor((&(nodep)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6073
case 443: {
  _zval_ptr_dtor((&(return_value)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6074
case 444: {
  _zval_ptr_dtor((&(this_ptr)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6075
case 445: {
  buf = xmlBufferCreate();
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6076
case 446: {
  convert_to_boolean((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6077
case 447: {
  convert_to_boolean((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6078
case 448: {
  convert_to_boolean((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6079
case 449: {
  convert_to_boolean((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6080
case 450: {
  convert_to_long((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6081
case 451: {
  convert_to_long((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6082
case 452: {
  convert_to_long((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6083
case 453: {
  convert_to_long((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6084
case 454: {
  doc_props = dom_get_doc_props((intern)->document);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6085
case 455: {
  doc_props = dom_get_doc_props((nodeobj)->document);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6086
case 456: {
  doc_props = dom_get_doc_props(intern->document);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6087
case 457: {
  exit(1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6088
case 458: {
  format = (doc_props)->formatoutput;
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6089
case 459: {
  format = doc_props->formatoutput;
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6090
case 460: {
  gc_remove_zval_from_buffer((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6091
case 461: {
  gc_remove_zval_from_buffer((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6092
case 462: {
  gc_remove_zval_from_buffer((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6093
case 463: {
  gc_remove_zval_from_buffer((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6094
case 464: {
  gc_zval_check_possible_root(((id)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6095
case 465: {
  gc_zval_check_possible_root(((nodep)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6096
case 466: {
  gc_zval_check_possible_root(((return_value)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6097
case 467: {
  gc_zval_check_possible_root(((this_ptr)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6098
case 468: {
  gc_zval_possible_root((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6099
case 469: {
  gc_zval_possible_root((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6100
case 470: {
  gc_zval_possible_root((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6101
case 471: {
  gc_zval_possible_root((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6102
case 472: {
  htmlDocDumpMemoryFormat((docp), &mem, &size, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6103
case 473: {
  htmlDocDumpMemoryFormat(docp, &(mem), &size, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6104
case 474: {
  htmlDocDumpMemoryFormat(docp, &mem, &size, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6105
case 475: {
  htmlNodeDumpFormatOutput((buf), docp, node, 0, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6106
case 476: {
  htmlNodeDumpFormatOutput(buf, (docp), node, 0, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6107
case 477: {
  htmlNodeDumpFormatOutput(buf, docp, (node), 0, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6108
case 478: {
  htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6109
case 479: {
  i_zval_ptr_dtor((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6110
case 480: {
  i_zval_ptr_dtor((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6111
case 481: {
  i_zval_ptr_dtor((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6112
case 482: {
  i_zval_ptr_dtor((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6113
case 483: {
  if (!__is_neg("33-483", 3, (int *){format, ht, size}, 0, 0, 13,
                (void **){nodep, return_value, node, nodeobj, doc_props, docp,
                          intern, id, buf, dom_node_class_entry,
                          dom_document_class_entry, this_ptr, mem},
                0, 0, 16, "nodep", "return_value", "node", "nodeobj", "format",
                "doc_props", "docp", "intern", "id", "buf",
                "dom_node_class_entry", "dom_document_class_entry", "ht",
                "this_ptr", "mem", "size") &&
      (nodep != ((void *)0))) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6114
case 484: {
  if (!__is_neg("33-484", 3, (int *){format, ht, size}, 0, 0, 13,
                (void **){nodep, return_value, node, nodeobj, doc_props, docp,
                          intern, id, buf, dom_node_class_entry,
                          dom_document_class_entry, this_ptr, mem},
                0, 0, 16, "nodep", "return_value", "node", "nodeobj", "format",
                "doc_props", "docp", "intern", "id", "buf",
                "dom_node_class_entry", "dom_document_class_entry", "ht",
                "this_ptr", "mem", "size"))
    if (nodep != ((void *)0)) {
      {
        nodeobj = (dom_object *)zend_object_store_get_object(nodep);
        if (nodeobj->ptr == ((void *)0) ||
            !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
          php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                            nodeobj->std.ce->name);
          {
            { (*return_value).type = 0; };
            return;
          };
        }
      };
      if (node->doc != docp) {
        php_dom_throw_error(WRONG_DOCUMENT_ERR,
                            dom_get_strict_error(intern->document));
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }
      buf = xmlBufferCreate();
      if (!buf) {
        php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
        {
          do {
            zval *__z = (return_value);
            (*__z).value.lval = ((0) != 0);
            (*__z).type = 3;
          } while (0);
          return;
        };
      }
      htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
      mem = (xmlChar *)xmlBufferContent(buf);
      if (!mem) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          zval *__z = (return_value);
          (*__z).value.str.len = strlen(__s);
          (*__z).value.str.val =
              (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }
      xmlBufferFree(buf);
    } else {
      htmlDocDumpMemoryFormat(docp, &mem, &size, format);
      if (!size) {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
      } else {
        do {
          const char *__s = (mem);
          int __l = size;
          zval *__z = (return_value);
          (*__z).value.str.len = __l;
          (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
          (*__z).type = 6;
        } while (0);
      }
      if (mem)
        xmlFree(mem);
    }

  break;
}
#endif
#ifdef COMPILE_6115
case 485: {
  if ((nodep != ((void *)0)) &&
      !__is_neg("33-485", 3, (int *){format, ht, size}, 0, 0, 13,
                (void **){nodep, return_value, node, nodeobj, doc_props, docp,
                          intern, id, buf, dom_node_class_entry,
                          dom_document_class_entry, this_ptr, mem},
                0, 0, 16, "nodep", "return_value", "node", "nodeobj", "format",
                "doc_props", "docp", "intern", "id", "buf",
                "dom_node_class_entry", "dom_document_class_entry", "ht",
                "this_ptr", "mem", "size")) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6116
case 486: {
  if ((nodep != ((void *)0)) ||
      __is_neg("33-486", 3, (int *){format, ht, size}, 0, 0, 13,
               (void **){nodep, return_value, node, nodeobj, doc_props, docp,
                         intern, id, buf, dom_node_class_entry,
                         dom_document_class_entry, this_ptr, mem},
               0, 0, 16, "nodep", "return_value", "node", "nodeobj", "format",
               "doc_props", "docp", "intern", "id", "buf",
               "dom_node_class_entry", "dom_document_class_entry", "ht",
               "this_ptr", "mem", "size")) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6117
case 487: {
  if (__is_neg("33-487", 3, (int *){format, ht, size}, 0, 0, 13,
               (void **){nodep, return_value, node, nodeobj, doc_props, docp,
                         intern, id, buf, dom_node_class_entry,
                         dom_document_class_entry, this_ptr, mem},
               0, 0, 16, "nodep", "return_value", "node", "nodeobj", "format",
               "doc_props", "docp", "intern", "id", "buf",
               "dom_node_class_entry", "dom_document_class_entry", "ht",
               "this_ptr", "mem", "size"))
    return;
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6118
case 488: {
  if (zend_parse_method_parameters((ht), (this_ptr), "O|O!", &id,
                                   dom_document_class_entry, &nodep,
                                   dom_node_class_entry) == -1) {
    return;
  }
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6119
case 489: {
  mem = (xmlChar *)xmlBufferContent(buf);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6120
case 490: {
  memset(&(*return_value), 0, sizeof(*(&(*return_value))));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6121
case 491: {
  memset(&nodeobj->std, 0, sizeof(*(&nodeobj->std)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6122
case 492: {
  memset(((php_libxml_node_ptr *)nodeobj->ptr), 0,
         sizeof(*(((php_libxml_node_ptr *)nodeobj->ptr))));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6123
case 493: {
  memset(intern, 0, sizeof(*(intern)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6124
case 494: {
  memset(node, 0, sizeof(*(node)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6125
case 495: {
  memset(nodeobj, 0, sizeof(*(nodeobj)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6126
case 496: {
  memset(nodeobj->std.ce, 0, sizeof(*(nodeobj->std.ce)));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6127
case 497: {
  php_dom_create_implementation((return_value_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6128
case 498: {
  php_dom_create_interator((id), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6129
case 499: {
  php_dom_create_interator((nodep), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6130
case 500: {
  php_dom_create_interator((return_value), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6131
case 501: {
  php_dom_create_interator((this_ptr), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6132
case 502: {
  php_dom_remove_xinclude_nodes((node));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6133
case 503: {
  php_dom_remove_xinclude_nodes((node)->children);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6134
case 504: {
  php_dom_throw_error((DOMSTRING_SIZE_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6135
case 505: {
  php_dom_throw_error((DOMSTRING_SIZE_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6136
case 506: {
  php_dom_throw_error((DOMSTRING_SIZE_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6137
case 507: {
  php_dom_throw_error((HIERARCHY_REQUEST_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6138
case 508: {
  php_dom_throw_error((HIERARCHY_REQUEST_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6139
case 509: {
  php_dom_throw_error((HIERARCHY_REQUEST_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6140
case 510: {
  php_dom_throw_error((INDEX_SIZE_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6141
case 511: {
  php_dom_throw_error((INDEX_SIZE_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6142
case 512: {
  php_dom_throw_error((INDEX_SIZE_ERR), dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6143
case 513: {
  php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6144
case 514: {
  php_dom_throw_error((INUSE_ATTRIBUTE_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6145
case 515: {
  php_dom_throw_error((INUSE_ATTRIBUTE_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6146
case 516: {
  php_dom_throw_error((INVALID_ACCESS_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6147
case 517: {
  php_dom_throw_error((INVALID_ACCESS_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6148
case 518: {
  php_dom_throw_error((INVALID_ACCESS_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6149
case 519: {
  php_dom_throw_error((INVALID_CHARACTER_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6150
case 520: {
  php_dom_throw_error((INVALID_CHARACTER_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6151
case 521: {
  php_dom_throw_error((INVALID_CHARACTER_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6152
case 522: {
  php_dom_throw_error((INVALID_MODIFICATION_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6153
case 523: {
  php_dom_throw_error((INVALID_MODIFICATION_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6154
case 524: {
  php_dom_throw_error((INVALID_MODIFICATION_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6155
case 525: {
  php_dom_throw_error((INVALID_STATE_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6156
case 526: {
  php_dom_throw_error((INVALID_STATE_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6157
case 527: {
  php_dom_throw_error((INVALID_STATE_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6158
case 528: {
  php_dom_throw_error((NAMESPACE_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6159
case 529: {
  php_dom_throw_error((NAMESPACE_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6160
case 530: {
  php_dom_throw_error((NAMESPACE_ERR), dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6161
case 531: {
  php_dom_throw_error((NOT_FOUND_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6162
case 532: {
  php_dom_throw_error((NOT_FOUND_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6163
case 533: {
  php_dom_throw_error((NOT_FOUND_ERR), dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6164
case 534: {
  php_dom_throw_error((NOT_SUPPORTED_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6165
case 535: {
  php_dom_throw_error((NOT_SUPPORTED_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6166
case 536: {
  php_dom_throw_error((NOT_SUPPORTED_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6167
case 537: {
  php_dom_throw_error((NO_DATA_ALLOWED_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6168
case 538: {
  php_dom_throw_error((NO_DATA_ALLOWED_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6169
case 539: {
  php_dom_throw_error((NO_DATA_ALLOWED_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6170
case 540: {
  php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6171
case 541: {
  php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6172
case 542: {
  php_dom_throw_error((NO_MODIFICATION_ALLOWED_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6173
case 543: {
  php_dom_throw_error((PHP_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6174
case 544: {
  php_dom_throw_error((PHP_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6175
case 545: {
  php_dom_throw_error((PHP_ERR), dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6176
case 546: {
  php_dom_throw_error((SYNTAX_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6177
case 547: {
  php_dom_throw_error((SYNTAX_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6178
case 548: {
  php_dom_throw_error((SYNTAX_ERR), dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6179
case 549: {
  php_dom_throw_error((VALIDATION_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6180
case 550: {
  php_dom_throw_error((VALIDATION_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6181
case 551: {
  php_dom_throw_error((VALIDATION_ERR), dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6182
case 552: {
  php_dom_throw_error((WRONG_DOCUMENT_ERR), 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6183
case 553: {
  php_dom_throw_error((WRONG_DOCUMENT_ERR), 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6184
case 554: {
  php_dom_throw_error((WRONG_DOCUMENT_ERR),
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6185
case 555: {
  php_dom_throw_error(INVALID_CHARACTER_ERR,
                      dom_get_strict_error((intern)->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6186
case 556: {
  php_dom_throw_error(INVALID_CHARACTER_ERR,
                      dom_get_strict_error((nodeobj)->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6187
case 557: {
  php_dom_throw_error(INVALID_STATE_ERR, 0);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6188
case 558: {
  php_dom_throw_error(INVALID_STATE_ERR, 1);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6189
case 559: {
  php_dom_throw_error(WRONG_DOCUMENT_ERR,
                      dom_get_strict_error((intern)->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6190
case 560: {
  php_dom_throw_error(WRONG_DOCUMENT_ERR,
                      dom_get_strict_error((nodeobj)->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6191
case 561: {
  php_dom_throw_error(WRONG_DOCUMENT_ERR,
                      dom_get_strict_error(intern->document));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6192
case 562: {
  php_error_docref0(((void *)0), (1 << 1L),
                    "Cannot create required DOM object");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6193
case 563: {
  php_error_docref0(((void *)0), (1 << 1L),
                    "Cannot import: Node Type Not Supported");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6194
case 564: {
  php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6195
case 565: {
  php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                    (intern)->std.ce->name);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6196
case 566: {
  php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                    (nodeobj)->std.ce->name);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6197
case 567: {
  php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                    intern->std.ce->name);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6198
case 568: {
  php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                    nodeobj->std.ce->name);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6199
case 569: {
  php_error_docref0(((void *)0), (1 << 1L), "Document Missing Root Element");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6200
case 570: {
  php_error_docref0(((void *)0), (1 << 1L), "Empty string supplied as input");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6201
case 571: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Document Encoding");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6202
case 572: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Filename");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6203
case 573: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG file source");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6204
case 574: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid RelaxNG");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6205
case 575: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema file source");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6206
case 576: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema source");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6207
case 577: {
  php_error_docref0(((void *)0), (1 << 1L), "Invalid Schema");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6208
case 578: {
  php_error_docref0(((void *)0), (1 << 1L), "Not yet implemented");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6209
case 579: {
  php_libxml_node_free_resource((node));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6210
case 580: {
  xmlBufferFree((buf));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6211
case 581: {
  xmlBufferFree(buf);
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6212
case 582: {
  xmlFreeNode((node));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6213
case 583: {
  xmlInitParser();
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6214
case 584: {
  xmlUnlinkNode((node));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6215
case 585: {
  zend_error((1 << 0L), "Invalid RelaxNG Validation Context");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6216
case 586: {
  zend_error((1 << 0L), "Invalid Schema Validation Context");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6217
case 587: {
  zend_error((1 << 3L), "A non well formed numeric value encountered");
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6218
case 588: {
  zval_unset_isref_p((id));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6219
case 589: {
  zval_unset_isref_p((nodep));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6220
case 590: {
  zval_unset_isref_p((return_value));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
#ifdef COMPILE_6221
case 591: {
  zval_unset_isref_p((this_ptr));
  if (nodep != ((void *)0)) {
    {
      nodeobj = (dom_object *)zend_object_store_get_object(nodep);
      if (nodeobj->ptr == ((void *)0) ||
          !(node = (xmlNodePtr)((php_libxml_node_ptr *)nodeobj->ptr)->node)) {
        php_error_docref0(((void *)0), (1 << 1L), "Couldn't fetch %s",
                          nodeobj->std.ce->name);
        {
          { (*return_value).type = 0; };
          return;
        };
      }
    };
    if (node->doc != docp) {
      php_dom_throw_error(WRONG_DOCUMENT_ERR,
                          dom_get_strict_error(intern->document));
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    buf = xmlBufferCreate();
    if (!buf) {
      php_error_docref0(((void *)0), (1 << 1L), "Could not fetch buffer");
      {
        do {
          zval *__z = (return_value);
          (*__z).value.lval = ((0) != 0);
          (*__z).type = 3;
        } while (0);
        return;
      };
    }
    htmlNodeDumpFormatOutput(buf, docp, node, 0, format);
    mem = (xmlChar *)xmlBufferContent(buf);
    if (!mem) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        zval *__z = (return_value);
        (*__z).value.str.len = strlen(__s);
        (*__z).value.str.val =
            (1 ? _estrndup((__s), ((*__z).value.str.len)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    xmlBufferFree(buf);
  } else {
    htmlDocDumpMemoryFormat(docp, &mem, &size, format);
    if (!size) {
      do {
        zval *__z = (return_value);
        (*__z).value.lval = ((0) != 0);
        (*__z).type = 3;
      } while (0);
    } else {
      do {
        const char *__s = (mem);
        int __l = size;
        zval *__z = (return_value);
        (*__z).value.str.len = __l;
        (*__z).value.str.val = (1 ? _estrndup((__s), (__l)) : (char *)__s);
        (*__z).type = 6;
      } while (0);
    }
    if (mem)
      xmlFree(mem);
  }

  break;
}
#endif
}
}
/* }}} end dom_document_save_html */

#endif /* defined(LIBXML_HTML_ENABLED) */

/* {{{ proto boolean DOMDocument::registerNodeClass(string baseclass, string
   extendedclass); Register extended class used to create base node type */
PHP_METHOD(domdocument, registerNodeClass) {
  zval *id;
  xmlDoc *docp;
  char *baseclass = NULL, *extendedclass = NULL;
  int baseclass_len = 0, extendedclass_len = 0;
  zend_class_entry *basece = NULL, *ce = NULL;
  dom_object *intern;

  if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oss!",
                                   &id, dom_document_class_entry, &baseclass,
                                   &baseclass_len, &extendedclass,
                                   &extendedclass_len) == FAILURE) {
    return;
  }

  if (baseclass_len) {
    zend_class_entry **pce;
    if (zend_lookup_class(baseclass, baseclass_len, &pce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR, "Class %s does not exist",
                       baseclass);
      return;
    }
    basece = *pce;
  }

  if (basece == NULL ||
      !instanceof_function(basece, dom_node_class_entry TSRMLS_CC)) {
    php_error_docref(NULL TSRMLS_CC, E_ERROR,
                     "Class %s is not derived from DOMNode.", baseclass);
    return;
  }

  if (extendedclass_len) {
    zend_class_entry **pce;
    if (zend_lookup_class(extendedclass, extendedclass_len, &pce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR, "Class %s does not exist",
                       extendedclass);
    }
    ce = *pce;
  }

  if (ce == NULL || instanceof_function(ce, basece TSRMLS_CC)) {

    DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

    if (dom_set_doc_classmap(intern->document, basece, ce TSRMLS_CC) ==
        FAILURE) {
      php_error_docref(NULL TSRMLS_CC, E_ERROR,
                       "Class %s could not be registered.", extendedclass);
    }
    RETURN_TRUE;
  } else {
    php_error_docref(NULL TSRMLS_CC, E_ERROR,
                     "Class %s is not derived from %s.", extendedclass,
                     baseclass);
  }

  RETURN_FALSE;
}
/* }}} */

#endif /* HAVE_LIBXML && HAVE_DOM */

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
