Initialize the program!
Generating repair candidates!
Processing bresenham.cpp
Total 1864 different repair schemas!!!!
Total 2422 different repair candidate templates for scoring!!!
Total 625 different partial repair candidate templates!!
Trying different candidates!
candidate count: 1864
BasicTester pointer: 0x5628c843e6b0
StringConstTester pointer: 0x5628c7b69270
CondTester pointer: 0x5628c8351960
Generating Candidates...
Candidates size: 1864
Generating Codes...
[7] Preprocess the following candidate with CondTester:
1864 Candidates
Generating patches with CondTester...

current candidate: 0
parent stmt: c817b298
current stmt: c817b200
stmt: switch(__choose("__ID0")){
	case 0: {
ystep = 1
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
x1 = y1;
y0 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
x0 = y0;
error = error + deltaerr;
a = y0;
a = x0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
ystep = 1;
ystep = 1;

break;
}
}

current candidate: 1
parent stmt: c817b298
current stmt: c83e1150
stmt: switch(__choose("__ID1")){
	case 0: {
if (!__is_neg())
    ystep = 1;

break;
}
	case 1: {
if (!__is_neg())
    ystep = 1;

break;
}
}

current candidate: 2
parent stmt: c817b298
current stmt: c83e6fe8
stmt: switch(__choose("__ID2")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 3
parent stmt: c81e8d70
current stmt: c81e8b98
stmt: switch(__choose("__ID3")){
	case 0: {
var.first = x
break;
}
	case 1: {
if (__is_neg())
    return;
if (__is_neg())
    break;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
line.push_back(var);
--this->current;
--this->_M_p;
++this->iter;
--this->_M_current;
++this->_M_p;
++this->current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
var.second = y;
var.first = y;
var.second = x;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
if (this->capacity() == this->size())
    return false;
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
y1 = a;
x0 = x1;
y0 = y1;
x1 = y1;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
x0 = y0;
y0 = a;
error = error + deltaerr;
a = y0;
a = x0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
error = error - 1;
ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
var.first = x;
var.first = x;

break;
}
}

current candidate: 4
parent stmt: c81e8d70
current stmt: c81e8c40
stmt: switch(__choose("__ID4")){
	case 0: {
var.second = y
break;
}
	case 1: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
if (__is_neg())
    return;
if (__is_neg())
    break;
line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.second = x;
var.first = x;
var.first = y;
--this->current;
--this->_M_p;
--this->_M_current;
++this->current;
++this->iter;
++this->_M_p;
++this->_M_current;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
x1 = y1;
x0 = x1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = a;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
a = x0;
x0 = y0;
a = y0;
y0 = a;
error = error + deltaerr;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
error = error - 1;
ystep = -1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
var.second = y;
var.second = y;

break;
}
}

current candidate: 5
parent stmt: c81e8d70
current stmt: c81e8d30
stmt: switch(__choose("__ID5")){
	case 0: {
line.push_back(var)
break;
}
	case 1: {
if (!__is_neg())
    line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
if (__is_neg())
    return;
if (__is_neg())
    break;
++this->_M_p;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
--this->_M_current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x0 = x1;
x1 = y1;
y0 = y1;
y1 = a;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
var.second = y;
var.first = y;
var.second = x;
var.first = x;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
x0 = y0;
error = error + deltaerr;
a = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
ystep = -1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
line.push_back(var);

break;
}
}

current candidate: 6
parent stmt: c81e8d70
current stmt: c83d5740
stmt: switch(__choose("__ID6")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 7
parent stmt: c81e8d70
current stmt: c83d5980
stmt: switch(__choose("__ID7")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 8
parent stmt: c81e8d70
current stmt: c83d5bf0
stmt: switch(__choose("__ID8")){
	case 0: {
if (!__is_neg())
    line.push_back(var);

break;
}
	case 1: {
if (!__is_neg())
    line.push_back(var);

break;
}
}

current candidate: 9
parent stmt: c81e8d70
current stmt: c8420b00
stmt: switch(__choose("__ID9")){
	case 0: {
if (!__is_neg())
    var.first = x;

break;
}
	case 1: {
if (!__is_neg())
    var.first = x;

break;
}
}

current candidate: 10
parent stmt: c81e8d70
current stmt: c84269f8
stmt: switch(__choose("__ID10")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 11
parent stmt: c81e8d70
current stmt: c8426c38
stmt: switch(__choose("__ID11")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 12
parent stmt: c81e8d70
current stmt: c8426ea8
stmt: switch(__choose("__ID12")){
	case 0: {
if (!__is_neg())
    var.second = y;

break;
}
	case 1: {
if (!__is_neg())
    var.second = y;

break;
}
}

current candidate: 13
parent stmt: c81e8d70
current stmt: c842b180
stmt: switch(__choose("__ID13")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 14
parent stmt: c81e8d70
current stmt: c842b3c0
stmt: switch(__choose("__ID14")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 15
parent stmt: c81e90b0
current stmt: c81e8d98
stmt: switch(__choose("__ID15")){
	case 0: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
line.push_back(var);
if (__is_neg())
    return;
if (__is_neg())
    break;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.first = y;
var.second = x;
var.second = y;
var.first = x;
--this->current;
++this->_M_current;
--this->_M_p;
--this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_up();
this->_M_shrink_to_fit();
if (this->capacity() == this->size())
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x1;
x1 = a;
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
x1 = y1;
y1 = a;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
x0 = y0;
y0 = a;
a = x0;
a = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 16
parent stmt: c81e90b0
current stmt: c81e8e70
stmt: switch(__choose("__ID16")){
	case 0: {
error = error + deltaerr
break;
}
	case 1: {
if (__is_neg())
    break;
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_p;
--this->_M_p;
++this->_M_current;
++this->current;
--this->current;
++this->iter;
--this->_M_current;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
line.push_back(var);
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
x1 = a;
x0 = x1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = y1;
x1 = y1;
a = x1;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = x0;
x0 = y0;
a = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
var.first = x;
var.second = y;
var.second = x;
var.first = y;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
ystep = 1;
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
error = error + deltaerr;
error = error + deltaerr;

break;
}
}

current candidate: 17
parent stmt: c81e90b0
current stmt: c81e9098
stmt: switch(__choose("__ID17")){
	case 0: {
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    break;
if (__is_neg())
    return;
error = error + deltaerr;
++this->current;
--this->_M_current;
--this->current;
--this->_M_p;
++this->iter;
++this->_M_current;
++this->_M_p;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
line.push_back(var);
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
a = x1;
x0 = x1;
x1 = a;
x1 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
y1 = a;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
error = error - 1;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
x0 = y0;
a = x0;
a = y0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
var.second = y;
var.first = x;
var.first = y;
var.second = x;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
ystep = 1;
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 18
parent stmt: c81e90b0
current stmt: c8412668
stmt: switch(__choose("__ID18")){
	case 0: {
if (!__is_neg())
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }

break;
}
	case 1: {
if (!__is_neg())
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }

break;
}
}

current candidate: 19
parent stmt: c81e90b0
current stmt: c84128f8
stmt: switch(__choose("__ID19")){
	case 0: {
if (!__is_neg() && (steep)) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if (!__is_neg() && (steep)) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 20
parent stmt: c81e90b0
current stmt: c8420650
stmt: switch(__choose("__ID20")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 21
parent stmt: c81e90b0
current stmt: c8420890
stmt: switch(__choose("__ID21")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 22
parent stmt: c81e90b0
current stmt: c842b670
stmt: switch(__choose("__ID22")){
	case 0: {
if ((steep) && !__is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if ((steep) && !__is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 23
parent stmt: c81e90b0
current stmt: c842b918
stmt: switch(__choose("__ID23")){
	case 0: {
if ((steep) || __is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if ((steep) || __is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 24
parent stmt: c81e90b0
current stmt: c842bb98
stmt: switch(__choose("__ID24")){
	case 0: {
if (!__is_neg())
    error = error + deltaerr;

break;
}
	case 1: {
if (!__is_neg())
    error = error + deltaerr;

break;
}
}

current candidate: 25
parent stmt: c81e90b0
current stmt: c8436648
stmt: switch(__choose("__ID25")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 26
parent stmt: c81e90b0
current stmt: c8436888
stmt: switch(__choose("__ID26")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 27
parent stmt: c81e90b0
current stmt: c8436af8
stmt: switch(__choose("__ID27")){
	case 0: {
if (!__is_neg())
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }

break;
}
}

current candidate: 28
parent stmt: c81e90b0
current stmt: c843c9f0
stmt: switch(__choose("__ID28")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 29
parent stmt: c81e90b0
current stmt: c8447f78
stmt: switch(__choose("__ID29")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 30
parent stmt: c81e90b0
current stmt: c8448228
stmt: switch(__choose("__ID30")){
	case 0: {
if ((error >= 0.5) && !__is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
if ((error >= 0.5) && !__is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 31
parent stmt: c81e90b0
current stmt: c84484c0
stmt: switch(__choose("__ID31")){
	case 0: {
if ((error >= 0.5) || __is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
if ((error >= 0.5) || __is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 32
parent stmt: c81e9110
current stmt: c8179c60
stmt: switch(__choose("__ID32")){
	case 0: {
short x0 = 0, y0 = 0;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_p;
++this->_M_current;
++this->iter;
++this->current;
--this->_M_current;
--this->current;
--this->_M_p;
--this->_M_impl._M_finish;
throw;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x1 = y1;
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
short x0 = 0, y0 = 0;

break;
}
}

current candidate: 33
parent stmt: c81e9110
current stmt: c817a1e8
stmt: switch(__choose("__ID33")){
	case 0: {
bool steep = abs((int)(y1 - y0)) > abs((int)(x1 - x0));

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
y0 = y1;
x0 = x1;
x1 = y1;
--this->_M_p;
++this->iter;
--this->_M_current;
++this->current;
++this->_M_current;
++this->_M_p;
--this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
x0 = y0;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
bool steep = abs((int)(y1 - y0)) > abs((int)(x1 - x0));

break;
}
}

current candidate: 34
parent stmt: c81e9110
current stmt: c817a280
stmt: switch(__choose("__ID34")){
	case 0: {
short a;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_p;
--this->current;
--this->_M_current;
++this->iter;
++this->_M_p;
++this->current;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
if (__is_neg())
    return;
y0 = y1;
x1 = y1;
x0 = x1;
x0 = y0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
short a;

break;
}
}

current candidate: 35
parent stmt: c81e9110
current stmt: c817a610
stmt: switch(__choose("__ID35")){
	case 0: {
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->iter;
--this->current;
--this->_M_current;
--this->_M_p;
++this->_M_current;
++this->current;
++this->_M_p;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x0 = x1;
x1 = a;
a = x1;
x1 = y1;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x0;
y0 = a;
x0 = y0;
a = y0;
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 36
parent stmt: c81e9110
current stmt: c817aa40
stmt: switch(__choose("__ID36")){
	case 0: {
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
a = x1;
x0 = x1;
x1 = a;
y0 = y1;
x1 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x0;
a = y0;
x0 = y0;
y0 = a;
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_shrink_to_fit();
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 37
parent stmt: c81e9110
current stmt: c817ab98
stmt: switch(__choose("__ID37")){
	case 0: {
int deltax = x1 - x0;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
--this->_M_current;
++this->iter;
++this->current;
--this->current;
--this->_M_p;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
a = x1;
y1 = a;
y0 = y1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x0;
y0 = a;
x0 = y0;
a = y0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int deltax = x1 - x0;

break;
}
}

current candidate: 38
parent stmt: c81e9110
current stmt: c817ae58
stmt: switch(__choose("__ID38")){
	case 0: {
int deltay = abs((int)(y1 - y0));

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
x1 = y1;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = a;
x0 = y0;
a = y0;
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
x0 = x1;
a = x1;
x1 = a;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
a = x0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int deltay = abs((int)(y1 - y0));

break;
}
}

current candidate: 39
parent stmt: c81e9110
current stmt: c817af28
stmt: switch(__choose("__ID39")){
	case 0: {
float error = 0;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
--this->_M_current;
++this->_M_current;
++this->current;
++this->_M_p;
--this->current;
--this->_M_p;
++this->iter;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
a = x1;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
this->_M_erase_at_end(begin());
if (this->capacity() == this->size())
    return false;
this->_M_shrink_to_fit();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x0;
a = y0;
x0 = y0;
y0 = a;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
float error = 0;

break;
}
}

current candidate: 40
parent stmt: c81e9110
current stmt: c817b068
stmt: switch(__choose("__ID40")){
	case 0: {
float deltaerr = deltay / deltax;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->current;
++this->iter;
--this->_M_p;
--this->_M_current;
++this->_M_current;
++this->_M_p;
--this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
x1 = a;
x0 = x1;
a = x1;
y0 = y1;
x1 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
x0 = y0;
y0 = a;
a = y0;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
float deltaerr = deltay / deltax;

break;
}
}

current candidate: 41
parent stmt: c81e9110
current stmt: c817b100
stmt: switch(__choose("__ID41")){
	case 0: {
int ystep;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_p;
--this->_M_current;
--this->current;
++this->_M_p;
++this->current;
++this->iter;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
x1 = a;
x0 = x1;
a = x1;
y1 = a;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
a = x0;
error = error + deltaerr;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
x0 = y0;
y0 = a;
a = y0;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int ystep;

break;
}
}

current candidate: 42
parent stmt: c81e9110
current stmt: c817b298
stmt: switch(__choose("__ID42")){
	case 0: {
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y0 = y1;
y1 = a;
x1 = y1;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = -1;
ystep = 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 43
parent stmt: c81e9110
current stmt: c817b390
stmt: switch(__choose("__ID43")){
	case 0: {
int y = y0;

break;
}
	case 1: {
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_current;
--this->_M_p;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
if (this->capacity() == this->size())
    return false;
this->_M_reallocate(this->size());
this->_M_bump_down();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x1 = a;
x0 = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
ystep = 1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int y = y0;

break;
}
}

current candidate: 44
parent stmt: c81e9110
current stmt: c81c0180
stmt: switch(__choose("__ID44")){
	case 0: {
std::pair<int, int> var;

break;
}
	case 1: {
if (__is_neg())
    return;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_current;
++this->current;
++this->_M_p;
--this->_M_p;
--this->current;
--this->_M_current;
++this->iter;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_shrink_to_fit();
this->_M_bump_down();
this->_M_reallocate(this->size());
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
y0 = y1;
y1 = a;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
x1 = a;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = y0;
a = x0;
x0 = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
std::pair<int, int> var;

break;
}
}

current candidate: 45
parent stmt: c81e9110
current stmt: c81e90d8
stmt: switch(__choose("__ID45")){
	case 0: {
for (int x = x0; x < x1; x++) {
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }
    error = error + deltaerr;
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }
}

break;
}
	case 1: {
line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.first = y;
var.second = y;
--this->current;
--this->_M_p;
++this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
error = error + deltaerr;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = a;
x0 = x1;
x1 = y1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
ystep = 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
for (int x = x0; x < x1; x++) {
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }
    error = error + deltaerr;
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }
}

break;
}
}

current candidate: 46
parent stmt: c81e9110
current stmt: c8271ae0
stmt: switch(__choose("__ID46")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 47
parent stmt: c81e9110
current stmt: c835b788
stmt: switch(__choose("__ID47")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 48
parent stmt: c81e9110
current stmt: c8368cb8
stmt: switch(__choose("__ID48")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 49
parent stmt: c81e9110
current stmt: c8368e08
stmt: switch(__choose("__ID49")){
	case 0: {
if (!__is_neg())
    if (steep) {
        a = x0;
        x0 = y0;
        y0 = a;
        a = x1;
        x1 = y1;
        y1 = a;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (steep) {
        a = x0;
        x0 = y0;
        y0 = a;
        a = x1;
        x1 = y1;
        y1 = a;
    }

break;
}
}

current candidate: 50
parent stmt: c81e9110
current stmt: c836ec00
stmt: switch(__choose("__ID50")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 51
parent stmt: c81e9110
current stmt: c837f4e8
stmt: switch(__choose("__ID51")){
	case 0: {
if ((steep) && !__is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((steep) && !__is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 52
parent stmt: c81e9110
current stmt: c837f680
stmt: switch(__choose("__ID52")){
	case 0: {
if ((steep) || __is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((steep) || __is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 53
parent stmt: c81e9110
current stmt: c837f7f0
stmt: switch(__choose("__ID53")){
	case 0: {
if (!__is_neg())
    if (x0 > x1) {
        a = x0;
        x0 = x1;
        x1 = a;
        a = y0;
        y0 = y1;
        y1 = a;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (x0 > x1) {
        a = x0;
        x0 = x1;
        x1 = a;
        a = y0;
        y0 = y1;
        y1 = a;
    }

break;
}
}

current candidate: 54
parent stmt: c81e9110
current stmt: c83855e8
stmt: switch(__choose("__ID54")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 55
parent stmt: c81e9110
current stmt: c8385798
stmt: switch(__choose("__ID55")){
	case 0: {
if ((x0 > x1) && !__is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((x0 > x1) && !__is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 56
parent stmt: c81e9110
current stmt: c8385930
stmt: switch(__choose("__ID56")){
	case 0: {
if ((x0 > x1) || __is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((x0 > x1) || __is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 57
parent stmt: c81e9110
current stmt: c8390778
stmt: switch(__choose("__ID57")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 58
parent stmt: c81e9110
current stmt: c8390968
stmt: switch(__choose("__ID58")){
	case 0: {
if (!__is_neg())
    if (y0 < y1)
        ystep = 1;
    else
        ystep = -1;

break;
}
	case 1: {
if (!__is_neg())
    if (y0 < y1)
        ystep = 1;
    else
        ystep = -1;

break;
}
}

current candidate: 59
parent stmt: c81e9110
current stmt: c839e910
stmt: switch(__choose("__ID59")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 60
parent stmt: c81e9110
current stmt: c83a47b8
stmt: switch(__choose("__ID60")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 61
parent stmt: c81e9110
current stmt: c83b3fa0
stmt: switch(__choose("__ID61")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 62
parent stmt: c81e9110
current stmt: c83b9dd8
stmt: switch(__choose("__ID62")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 63
parent stmt: c81e9110
current stmt: c83e0f40
stmt: switch(__choose("__ID63")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 64
parent stmt: c81e9110
current stmt: c83f5378
stmt: switch(__choose("__ID64")){
	case 0: {
if ((y0 < y1) && !__is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if ((y0 < y1) && !__is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 65
parent stmt: c81e9110
current stmt: c83f55c0
stmt: switch(__choose("__ID65")){
	case 0: {
if ((y0 < y1) || __is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if ((y0 < y1) || __is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 66
parent stmt: c81e9110
current stmt: c83fb500
stmt: switch(__choose("__ID66")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 67
parent stmt: c81e9110
current stmt: c8405d18
stmt: switch(__choose("__ID67")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 68
parent stmt: c81e9110
current stmt: c8405f48
stmt: switch(__choose("__ID68")){
	case 0: {
if (!__is_neg())
    for (int x = x0; x < x1; x++) {
        if (steep) {
            var.first = y;
            var.second = x;
            line.push_back(var);
        } else {
            var.first = x;
            var.second = y;
            line.push_back(var);
        }
        error = error + deltaerr;
        if (error >= 0.5) {
            y += ystep;
            error = error - 1;
        }
    }

break;
}
	case 1: {
if (!__is_neg())
    for (int x = x0; x < x1; x++) {
        if (steep) {
            var.first = y;
            var.second = x;
            line.push_back(var);
        } else {
            var.first = x;
            var.second = y;
            line.push_back(var);
        }
        error = error + deltaerr;
        if (error >= 0.5) {
            y += ystep;
            error = error - 1;
        }
    }

break;
}
}

current candidate: 69
parent stmt: c81e9110
current stmt: c8412418
stmt: switch(__choose("__ID69")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 70
parent stmt: c81f3db0
current stmt: c81ed8d0
stmt: switch(__choose("__ID70")){
	case 0: {
FILE *f = fopen(argv[1], "r");

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return 0;
++this->_M_p;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
--this->_M_current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
FILE *f = fopen(argv[1], "r");

break;
}
}

current candidate: 71
parent stmt: c81f3db0
current stmt: c81eda00
stmt: switch(__choose("__ID71")){
	case 0: {
int x, y;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->iter;
--this->_M_current;
--this->current;
--this->_M_p;
++this->_M_current;
++this->_M_p;
++this->current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return 0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int x, y;

break;
}
}

current candidate: 72
parent stmt: c81f3db0
current stmt: c81edc28
stmt: switch(__choose("__ID72")){
	case 0: {
fscanf(f, "%d %d\n", &x, &y)
break;
}
	case 1: {
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
fscanf(f, "%d %d\n", &x, &y);

break;
}
}

current candidate: 73
parent stmt: c81f3db0
current stmt: c81edd98
stmt: switch(__choose("__ID73")){
	case 0: {
fclose(f)
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return 0;
++this->current;
--this->_M_p;
--this->current;
++this->iter;
--this->_M_current;
++this->_M_p;
++this->_M_current;
throw;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_bump_up();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
fclose(f);

break;
}
}

current candidate: 74
parent stmt: c81f3db0
current stmt: c81f3400
stmt: switch(__choose("__ID74")){
	case 0: {
DiscreteLine line;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_current;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
if (__is_neg())
    return 0;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
DiscreteLine line;

break;
}
}

current candidate: 75
parent stmt: c81f3db0
current stmt: c81f3558
stmt: switch(__choose("__ID75")){
	case 0: {
buggy(x, y, line)
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
buggy(x, y, line);
if (__is_neg())
    return 0;
--this->_M_current;
--this->_M_p;
--this->current;
++this->_M_p;
++this->iter;
++this->current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
buggy(x, y, line);

break;
}
}

current candidate: 76
parent stmt: c81f3db0
current stmt: c81f3d78
stmt: switch(__choose("__ID76")){
	case 0: {
for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
    printf("%d %d\n", line[i].first, line[i].second);

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
buggy(x, y, line);
if (__is_neg())
    return 0;
--this->_M_p;
--this->current;
++this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_up();
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
    printf("%d %d\n", line[i].first, line[i].second);

break;
}
}

current candidate: 77
parent stmt: c81f3db0
current stmt: c844e428
stmt: switch(__choose("__ID77")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 78
parent stmt: c81f3db0
current stmt: c844e4f0
stmt: switch(__choose("__ID78")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 79
parent stmt: c81f3db0
current stmt: c845b428
stmt: switch(__choose("__ID79")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 80
parent stmt: c81f3db0
current stmt: c845b510
stmt: switch(__choose("__ID80")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 81
parent stmt: c81f3db0
current stmt: c845b6b8
stmt: switch(__choose("__ID81")){
	case 0: {
fscanf(f, __is_neg(), &x, &y)
break;
}
	case 1: {
fscanf(f, __is_neg(), &x, &y);

break;
}
}

current candidate: 82
parent stmt: c81f3db0
current stmt: c845b730
stmt: switch(__choose("__ID82")){
	case 0: {
if (!__is_neg())
    fscanf(f, "%d %d\n", &x, &y);

break;
}
	case 1: {
if (!__is_neg())
    fscanf(f, "%d %d\n", &x, &y);

break;
}
}

current candidate: 83
parent stmt: c81f3db0
current stmt: c8463458
stmt: switch(__choose("__ID83")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 84
parent stmt: c81f3db0
current stmt: c8463580
stmt: switch(__choose("__ID84")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 85
parent stmt: c81f3db0
current stmt: c8463768
stmt: switch(__choose("__ID85")){
	case 0: {
if (!__is_neg())
    fclose(f);

break;
}
	case 1: {
if (!__is_neg())
    fclose(f);

break;
}
}

current candidate: 86
parent stmt: c81f3db0
current stmt: c846e310
stmt: switch(__choose("__ID86")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 87
parent stmt: c81f3db0
current stmt: c846e438
stmt: switch(__choose("__ID87")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 88
parent stmt: c81f3db0
current stmt: c84743c8
stmt: switch(__choose("__ID88")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 89
parent stmt: c81f3db0
current stmt: c84744f0
stmt: switch(__choose("__ID89")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 90
parent stmt: c81f3db0
current stmt: c8474640
stmt: switch(__choose("__ID90")){
	case 0: {
if (!__is_neg())
    buggy(x, y, line);

break;
}
	case 1: {
if (!__is_neg())
    buggy(x, y, line);

break;
}
}

current candidate: 91
parent stmt: c81f3db0
current stmt: c8482ee0
stmt: switch(__choose("__ID91")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 92
parent stmt: c81f3db0
current stmt: c8483028
stmt: switch(__choose("__ID92")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 93
parent stmt: c81f3db0
current stmt: c8483198
stmt: switch(__choose("__ID93")){
	case 0: {
if (!__is_neg())
    for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
        printf("%d %d\n", line[i].first, line[i].second);

break;
}
	case 1: {
if (!__is_neg())
    for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
        printf("%d %d\n", line[i].first, line[i].second);

break;
}
}

current candidate: 94
parent stmt: c81f3db0
current stmt: c848aaf0
stmt: switch(__choose("__ID94")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 95
parent stmt: c81f3db0
current stmt: c848ac38
stmt: switch(__choose("__ID95")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}
Generating patches...
Patch Generated!
[7] CondTester, a patch instance with id 0:
codes size: 1
res size: 1
result size: 1863
Spawn 1 instances, now Total 1
Single building for Tester 0x5628c8351960 id 1863 failed as well!
[9] Preprocess the following candidate with StringConstTester:
1864

current candidate: 96
parent stmt: c817b298
current stmt: c817b200
stmt: switch(__choose("__ID96")){
	case 0: {
ystep = 1
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
x1 = y1;
y0 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
x0 = y0;
error = error + deltaerr;
a = y0;
a = x0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
ystep = 1;
ystep = 1;

break;
}
}

current candidate: 97
parent stmt: c817b298
current stmt: c83e1150
stmt: switch(__choose("__ID97")){
	case 0: {
if (!__is_neg())
    ystep = 1;

break;
}
	case 1: {
if (!__is_neg())
    ystep = 1;

break;
}
}

current candidate: 98
parent stmt: c817b298
current stmt: c83e6fe8
stmt: switch(__choose("__ID98")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 99
parent stmt: c81e8d70
current stmt: c81e8b98
stmt: switch(__choose("__ID99")){
	case 0: {
var.first = x
break;
}
	case 1: {
if (__is_neg())
    return;
if (__is_neg())
    break;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
line.push_back(var);
--this->current;
--this->_M_p;
++this->iter;
--this->_M_current;
++this->_M_p;
++this->current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
var.second = y;
var.first = y;
var.second = x;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
if (this->capacity() == this->size())
    return false;
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
y1 = a;
x0 = x1;
y0 = y1;
x1 = y1;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
x0 = y0;
y0 = a;
error = error + deltaerr;
a = y0;
a = x0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
error = error - 1;
ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
var.first = x;
var.first = x;

break;
}
}

current candidate: 100
parent stmt: c81e8d70
current stmt: c81e8c40
stmt: switch(__choose("__ID100")){
	case 0: {
var.second = y
break;
}
	case 1: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
if (__is_neg())
    return;
if (__is_neg())
    break;
line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.second = x;
var.first = x;
var.first = y;
--this->current;
--this->_M_p;
--this->_M_current;
++this->current;
++this->iter;
++this->_M_p;
++this->_M_current;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
x1 = y1;
x0 = x1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = a;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
a = x0;
x0 = y0;
a = y0;
y0 = a;
error = error + deltaerr;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
error = error - 1;
ystep = -1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
var.second = y;
var.second = y;

break;
}
}

current candidate: 101
parent stmt: c81e8d70
current stmt: c81e8d30
stmt: switch(__choose("__ID101")){
	case 0: {
line.push_back(var)
break;
}
	case 1: {
if (!__is_neg())
    line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
if (__is_neg())
    return;
if (__is_neg())
    break;
++this->_M_p;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
--this->_M_current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x0 = x1;
x1 = y1;
y0 = y1;
y1 = a;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
var.second = y;
var.first = y;
var.second = x;
var.first = x;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
x0 = y0;
error = error + deltaerr;
a = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
ystep = -1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
line.push_back(var);

break;
}
}

current candidate: 102
parent stmt: c81e8d70
current stmt: c83d5740
stmt: switch(__choose("__ID102")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 103
parent stmt: c81e8d70
current stmt: c83d5980
stmt: switch(__choose("__ID103")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 104
parent stmt: c81e8d70
current stmt: c83d5bf0
stmt: switch(__choose("__ID104")){
	case 0: {
if (!__is_neg())
    line.push_back(var);

break;
}
	case 1: {
if (!__is_neg())
    line.push_back(var);

break;
}
}

current candidate: 105
parent stmt: c81e8d70
current stmt: c8420b00
stmt: switch(__choose("__ID105")){
	case 0: {
if (!__is_neg())
    var.first = x;

break;
}
	case 1: {
if (!__is_neg())
    var.first = x;

break;
}
}

current candidate: 106
parent stmt: c81e8d70
current stmt: c84269f8
stmt: switch(__choose("__ID106")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 107
parent stmt: c81e8d70
current stmt: c8426c38
stmt: switch(__choose("__ID107")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 108
parent stmt: c81e8d70
current stmt: c8426ea8
stmt: switch(__choose("__ID108")){
	case 0: {
if (!__is_neg())
    var.second = y;

break;
}
	case 1: {
if (!__is_neg())
    var.second = y;

break;
}
}

current candidate: 109
parent stmt: c81e8d70
current stmt: c842b180
stmt: switch(__choose("__ID109")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 110
parent stmt: c81e8d70
current stmt: c842b3c0
stmt: switch(__choose("__ID110")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 111
parent stmt: c81e90b0
current stmt: c81e8d98
stmt: switch(__choose("__ID111")){
	case 0: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
line.push_back(var);
if (__is_neg())
    return;
if (__is_neg())
    break;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.first = y;
var.second = x;
var.second = y;
var.first = x;
--this->current;
++this->_M_current;
--this->_M_p;
--this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_up();
this->_M_shrink_to_fit();
if (this->capacity() == this->size())
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x1;
x1 = a;
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
x1 = y1;
y1 = a;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
x0 = y0;
y0 = a;
a = x0;
a = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 112
parent stmt: c81e90b0
current stmt: c81e8e70
stmt: switch(__choose("__ID112")){
	case 0: {
error = error + deltaerr
break;
}
	case 1: {
if (__is_neg())
    break;
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_p;
--this->_M_p;
++this->_M_current;
++this->current;
--this->current;
++this->iter;
--this->_M_current;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
line.push_back(var);
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
x1 = a;
x0 = x1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = y1;
x1 = y1;
a = x1;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = x0;
x0 = y0;
a = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
var.first = x;
var.second = y;
var.second = x;
var.first = y;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
ystep = 1;
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
error = error + deltaerr;
error = error + deltaerr;

break;
}
}

current candidate: 113
parent stmt: c81e90b0
current stmt: c81e9098
stmt: switch(__choose("__ID113")){
	case 0: {
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    break;
if (__is_neg())
    return;
error = error + deltaerr;
++this->current;
--this->_M_current;
--this->current;
--this->_M_p;
++this->iter;
++this->_M_current;
++this->_M_p;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
line.push_back(var);
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
a = x1;
x0 = x1;
x1 = a;
x1 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
y1 = a;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
error = error - 1;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
x0 = y0;
a = x0;
a = y0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
var.second = y;
var.first = x;
var.first = y;
var.second = x;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
ystep = 1;
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 114
parent stmt: c81e90b0
current stmt: c8412668
stmt: switch(__choose("__ID114")){
	case 0: {
if (!__is_neg())
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }

break;
}
	case 1: {
if (!__is_neg())
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }

break;
}
}

current candidate: 115
parent stmt: c81e90b0
current stmt: c84128f8
stmt: switch(__choose("__ID115")){
	case 0: {
if (!__is_neg() && (steep)) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if (!__is_neg() && (steep)) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 116
parent stmt: c81e90b0
current stmt: c8420650
stmt: switch(__choose("__ID116")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 117
parent stmt: c81e90b0
current stmt: c8420890
stmt: switch(__choose("__ID117")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 118
parent stmt: c81e90b0
current stmt: c842b670
stmt: switch(__choose("__ID118")){
	case 0: {
if ((steep) && !__is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if ((steep) && !__is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 119
parent stmt: c81e90b0
current stmt: c842b918
stmt: switch(__choose("__ID119")){
	case 0: {
if ((steep) || __is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if ((steep) || __is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 120
parent stmt: c81e90b0
current stmt: c842bb98
stmt: switch(__choose("__ID120")){
	case 0: {
if (!__is_neg())
    error = error + deltaerr;

break;
}
	case 1: {
if (!__is_neg())
    error = error + deltaerr;

break;
}
}

current candidate: 121
parent stmt: c81e90b0
current stmt: c8436648
stmt: switch(__choose("__ID121")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 122
parent stmt: c81e90b0
current stmt: c8436888
stmt: switch(__choose("__ID122")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 123
parent stmt: c81e90b0
current stmt: c8436af8
stmt: switch(__choose("__ID123")){
	case 0: {
if (!__is_neg())
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }

break;
}
}

current candidate: 124
parent stmt: c81e90b0
current stmt: c843c9f0
stmt: switch(__choose("__ID124")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 125
parent stmt: c81e90b0
current stmt: c8447f78
stmt: switch(__choose("__ID125")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 126
parent stmt: c81e90b0
current stmt: c8448228
stmt: switch(__choose("__ID126")){
	case 0: {
if ((error >= 0.5) && !__is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
if ((error >= 0.5) && !__is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 127
parent stmt: c81e90b0
current stmt: c84484c0
stmt: switch(__choose("__ID127")){
	case 0: {
if ((error >= 0.5) || __is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
if ((error >= 0.5) || __is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 128
parent stmt: c81e9110
current stmt: c8179c60
stmt: switch(__choose("__ID128")){
	case 0: {
short x0 = 0, y0 = 0;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_p;
++this->_M_current;
++this->iter;
++this->current;
--this->_M_current;
--this->current;
--this->_M_p;
--this->_M_impl._M_finish;
throw;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x1 = y1;
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
short x0 = 0, y0 = 0;

break;
}
}

current candidate: 129
parent stmt: c81e9110
current stmt: c817a1e8
stmt: switch(__choose("__ID129")){
	case 0: {
bool steep = abs((int)(y1 - y0)) > abs((int)(x1 - x0));

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
y0 = y1;
x0 = x1;
x1 = y1;
--this->_M_p;
++this->iter;
--this->_M_current;
++this->current;
++this->_M_current;
++this->_M_p;
--this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
x0 = y0;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
bool steep = abs((int)(y1 - y0)) > abs((int)(x1 - x0));

break;
}
}

current candidate: 130
parent stmt: c81e9110
current stmt: c817a280
stmt: switch(__choose("__ID130")){
	case 0: {
short a;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_p;
--this->current;
--this->_M_current;
++this->iter;
++this->_M_p;
++this->current;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
if (__is_neg())
    return;
y0 = y1;
x1 = y1;
x0 = x1;
x0 = y0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
short a;

break;
}
}

current candidate: 131
parent stmt: c81e9110
current stmt: c817a610
stmt: switch(__choose("__ID131")){
	case 0: {
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->iter;
--this->current;
--this->_M_current;
--this->_M_p;
++this->_M_current;
++this->current;
++this->_M_p;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x0 = x1;
x1 = a;
a = x1;
x1 = y1;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x0;
y0 = a;
x0 = y0;
a = y0;
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 132
parent stmt: c81e9110
current stmt: c817aa40
stmt: switch(__choose("__ID132")){
	case 0: {
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
a = x1;
x0 = x1;
x1 = a;
y0 = y1;
x1 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x0;
a = y0;
x0 = y0;
y0 = a;
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_shrink_to_fit();
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 133
parent stmt: c81e9110
current stmt: c817ab98
stmt: switch(__choose("__ID133")){
	case 0: {
int deltax = x1 - x0;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
--this->_M_current;
++this->iter;
++this->current;
--this->current;
--this->_M_p;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
a = x1;
y1 = a;
y0 = y1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x0;
y0 = a;
x0 = y0;
a = y0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int deltax = x1 - x0;

break;
}
}

current candidate: 134
parent stmt: c81e9110
current stmt: c817ae58
stmt: switch(__choose("__ID134")){
	case 0: {
int deltay = abs((int)(y1 - y0));

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
x1 = y1;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = a;
x0 = y0;
a = y0;
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
x0 = x1;
a = x1;
x1 = a;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
a = x0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int deltay = abs((int)(y1 - y0));

break;
}
}

current candidate: 135
parent stmt: c81e9110
current stmt: c817af28
stmt: switch(__choose("__ID135")){
	case 0: {
float error = 0;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
--this->_M_current;
++this->_M_current;
++this->current;
++this->_M_p;
--this->current;
--this->_M_p;
++this->iter;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
a = x1;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
this->_M_erase_at_end(begin());
if (this->capacity() == this->size())
    return false;
this->_M_shrink_to_fit();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x0;
a = y0;
x0 = y0;
y0 = a;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
float error = 0;

break;
}
}

current candidate: 136
parent stmt: c81e9110
current stmt: c817b068
stmt: switch(__choose("__ID136")){
	case 0: {
float deltaerr = deltay / deltax;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->current;
++this->iter;
--this->_M_p;
--this->_M_current;
++this->_M_current;
++this->_M_p;
--this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
x1 = a;
x0 = x1;
a = x1;
y0 = y1;
x1 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
x0 = y0;
y0 = a;
a = y0;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
float deltaerr = deltay / deltax;

break;
}
}

current candidate: 137
parent stmt: c81e9110
current stmt: c817b100
stmt: switch(__choose("__ID137")){
	case 0: {
int ystep;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_p;
--this->_M_current;
--this->current;
++this->_M_p;
++this->current;
++this->iter;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
x1 = a;
x0 = x1;
a = x1;
y1 = a;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
a = x0;
error = error + deltaerr;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
x0 = y0;
y0 = a;
a = y0;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int ystep;

break;
}
}

current candidate: 138
parent stmt: c81e9110
current stmt: c817b298
stmt: switch(__choose("__ID138")){
	case 0: {
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y0 = y1;
y1 = a;
x1 = y1;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = -1;
ystep = 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 139
parent stmt: c81e9110
current stmt: c817b390
stmt: switch(__choose("__ID139")){
	case 0: {
int y = y0;

break;
}
	case 1: {
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_current;
--this->_M_p;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
if (this->capacity() == this->size())
    return false;
this->_M_reallocate(this->size());
this->_M_bump_down();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x1 = a;
x0 = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
ystep = 1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int y = y0;

break;
}
}

current candidate: 140
parent stmt: c81e9110
current stmt: c81c0180
stmt: switch(__choose("__ID140")){
	case 0: {
std::pair<int, int> var;

break;
}
	case 1: {
if (__is_neg())
    return;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_current;
++this->current;
++this->_M_p;
--this->_M_p;
--this->current;
--this->_M_current;
++this->iter;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_shrink_to_fit();
this->_M_bump_down();
this->_M_reallocate(this->size());
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
y0 = y1;
y1 = a;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
x1 = a;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = y0;
a = x0;
x0 = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
std::pair<int, int> var;

break;
}
}

current candidate: 141
parent stmt: c81e9110
current stmt: c81e90d8
stmt: switch(__choose("__ID141")){
	case 0: {
for (int x = x0; x < x1; x++) {
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }
    error = error + deltaerr;
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }
}

break;
}
	case 1: {
line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.first = y;
var.second = y;
--this->current;
--this->_M_p;
++this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
error = error + deltaerr;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = a;
x0 = x1;
x1 = y1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
ystep = 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
for (int x = x0; x < x1; x++) {
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }
    error = error + deltaerr;
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }
}

break;
}
}

current candidate: 142
parent stmt: c81e9110
current stmt: c8271ae0
stmt: switch(__choose("__ID142")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 143
parent stmt: c81e9110
current stmt: c835b788
stmt: switch(__choose("__ID143")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 144
parent stmt: c81e9110
current stmt: c8368cb8
stmt: switch(__choose("__ID144")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 145
parent stmt: c81e9110
current stmt: c8368e08
stmt: switch(__choose("__ID145")){
	case 0: {
if (!__is_neg())
    if (steep) {
        a = x0;
        x0 = y0;
        y0 = a;
        a = x1;
        x1 = y1;
        y1 = a;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (steep) {
        a = x0;
        x0 = y0;
        y0 = a;
        a = x1;
        x1 = y1;
        y1 = a;
    }

break;
}
}

current candidate: 146
parent stmt: c81e9110
current stmt: c836ec00
stmt: switch(__choose("__ID146")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 147
parent stmt: c81e9110
current stmt: c837f4e8
stmt: switch(__choose("__ID147")){
	case 0: {
if ((steep) && !__is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((steep) && !__is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 148
parent stmt: c81e9110
current stmt: c837f680
stmt: switch(__choose("__ID148")){
	case 0: {
if ((steep) || __is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((steep) || __is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 149
parent stmt: c81e9110
current stmt: c837f7f0
stmt: switch(__choose("__ID149")){
	case 0: {
if (!__is_neg())
    if (x0 > x1) {
        a = x0;
        x0 = x1;
        x1 = a;
        a = y0;
        y0 = y1;
        y1 = a;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (x0 > x1) {
        a = x0;
        x0 = x1;
        x1 = a;
        a = y0;
        y0 = y1;
        y1 = a;
    }

break;
}
}

current candidate: 150
parent stmt: c81e9110
current stmt: c83855e8
stmt: switch(__choose("__ID150")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 151
parent stmt: c81e9110
current stmt: c8385798
stmt: switch(__choose("__ID151")){
	case 0: {
if ((x0 > x1) && !__is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((x0 > x1) && !__is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 152
parent stmt: c81e9110
current stmt: c8385930
stmt: switch(__choose("__ID152")){
	case 0: {
if ((x0 > x1) || __is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((x0 > x1) || __is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 153
parent stmt: c81e9110
current stmt: c8390778
stmt: switch(__choose("__ID153")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 154
parent stmt: c81e9110
current stmt: c8390968
stmt: switch(__choose("__ID154")){
	case 0: {
if (!__is_neg())
    if (y0 < y1)
        ystep = 1;
    else
        ystep = -1;

break;
}
	case 1: {
if (!__is_neg())
    if (y0 < y1)
        ystep = 1;
    else
        ystep = -1;

break;
}
}

current candidate: 155
parent stmt: c81e9110
current stmt: c839e910
stmt: switch(__choose("__ID155")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 156
parent stmt: c81e9110
current stmt: c83a47b8
stmt: switch(__choose("__ID156")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 157
parent stmt: c81e9110
current stmt: c83b3fa0
stmt: switch(__choose("__ID157")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 158
parent stmt: c81e9110
current stmt: c83b9dd8
stmt: switch(__choose("__ID158")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 159
parent stmt: c81e9110
current stmt: c83e0f40
stmt: switch(__choose("__ID159")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 160
parent stmt: c81e9110
current stmt: c83f5378
stmt: switch(__choose("__ID160")){
	case 0: {
if ((y0 < y1) && !__is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if ((y0 < y1) && !__is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 161
parent stmt: c81e9110
current stmt: c83f55c0
stmt: switch(__choose("__ID161")){
	case 0: {
if ((y0 < y1) || __is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if ((y0 < y1) || __is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 162
parent stmt: c81e9110
current stmt: c83fb500
stmt: switch(__choose("__ID162")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 163
parent stmt: c81e9110
current stmt: c8405d18
stmt: switch(__choose("__ID163")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 164
parent stmt: c81e9110
current stmt: c8405f48
stmt: switch(__choose("__ID164")){
	case 0: {
if (!__is_neg())
    for (int x = x0; x < x1; x++) {
        if (steep) {
            var.first = y;
            var.second = x;
            line.push_back(var);
        } else {
            var.first = x;
            var.second = y;
            line.push_back(var);
        }
        error = error + deltaerr;
        if (error >= 0.5) {
            y += ystep;
            error = error - 1;
        }
    }

break;
}
	case 1: {
if (!__is_neg())
    for (int x = x0; x < x1; x++) {
        if (steep) {
            var.first = y;
            var.second = x;
            line.push_back(var);
        } else {
            var.first = x;
            var.second = y;
            line.push_back(var);
        }
        error = error + deltaerr;
        if (error >= 0.5) {
            y += ystep;
            error = error - 1;
        }
    }

break;
}
}

current candidate: 165
parent stmt: c81e9110
current stmt: c8412418
stmt: switch(__choose("__ID165")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 166
parent stmt: c81f3db0
current stmt: c81ed8d0
stmt: switch(__choose("__ID166")){
	case 0: {
FILE *f = fopen(argv[1], "r");

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return 0;
++this->_M_p;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
--this->_M_current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
FILE *f = fopen(argv[1], "r");

break;
}
}

current candidate: 167
parent stmt: c81f3db0
current stmt: c81eda00
stmt: switch(__choose("__ID167")){
	case 0: {
int x, y;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->iter;
--this->_M_current;
--this->current;
--this->_M_p;
++this->_M_current;
++this->_M_p;
++this->current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return 0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int x, y;

break;
}
}

current candidate: 168
parent stmt: c81f3db0
current stmt: c81edc28
stmt: switch(__choose("__ID168")){
	case 0: {
fscanf(f, "%d %d\n", &x, &y)
break;
}
	case 1: {
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
fscanf(f, "%d %d\n", &x, &y);

break;
}
}

current candidate: 169
parent stmt: c81f3db0
current stmt: c81edd98
stmt: switch(__choose("__ID169")){
	case 0: {
fclose(f)
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return 0;
++this->current;
--this->_M_p;
--this->current;
++this->iter;
--this->_M_current;
++this->_M_p;
++this->_M_current;
throw;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_bump_up();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
fclose(f);

break;
}
}

current candidate: 170
parent stmt: c81f3db0
current stmt: c81f3400
stmt: switch(__choose("__ID170")){
	case 0: {
DiscreteLine line;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_current;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
if (__is_neg())
    return 0;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
DiscreteLine line;

break;
}
}

current candidate: 171
parent stmt: c81f3db0
current stmt: c81f3558
stmt: switch(__choose("__ID171")){
	case 0: {
buggy(x, y, line)
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
buggy(x, y, line);
if (__is_neg())
    return 0;
--this->_M_current;
--this->_M_p;
--this->current;
++this->_M_p;
++this->iter;
++this->current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
buggy(x, y, line);

break;
}
}

current candidate: 172
parent stmt: c81f3db0
current stmt: c81f3d78
stmt: switch(__choose("__ID172")){
	case 0: {
for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
    printf("%d %d\n", line[i].first, line[i].second);

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
buggy(x, y, line);
if (__is_neg())
    return 0;
--this->_M_p;
--this->current;
++this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_up();
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
    printf("%d %d\n", line[i].first, line[i].second);

break;
}
}

current candidate: 173
parent stmt: c81f3db0
current stmt: c844e428
stmt: switch(__choose("__ID173")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 174
parent stmt: c81f3db0
current stmt: c844e4f0
stmt: switch(__choose("__ID174")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 175
parent stmt: c81f3db0
current stmt: c845b428
stmt: switch(__choose("__ID175")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 176
parent stmt: c81f3db0
current stmt: c845b510
stmt: switch(__choose("__ID176")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 177
parent stmt: c81f3db0
current stmt: c845b6b8
stmt: switch(__choose("__ID177")){
	case 0: {
fscanf(f, __is_neg(), &x, &y)
break;
}
	case 1: {
fscanf(f, __is_neg(), &x, &y);

break;
}
}

current candidate: 178
parent stmt: c81f3db0
current stmt: c845b730
stmt: switch(__choose("__ID178")){
	case 0: {
if (!__is_neg())
    fscanf(f, "%d %d\n", &x, &y);

break;
}
	case 1: {
if (!__is_neg())
    fscanf(f, "%d %d\n", &x, &y);

break;
}
}

current candidate: 179
parent stmt: c81f3db0
current stmt: c8463458
stmt: switch(__choose("__ID179")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 180
parent stmt: c81f3db0
current stmt: c8463580
stmt: switch(__choose("__ID180")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 181
parent stmt: c81f3db0
current stmt: c8463768
stmt: switch(__choose("__ID181")){
	case 0: {
if (!__is_neg())
    fclose(f);

break;
}
	case 1: {
if (!__is_neg())
    fclose(f);

break;
}
}

current candidate: 182
parent stmt: c81f3db0
current stmt: c846e310
stmt: switch(__choose("__ID182")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 183
parent stmt: c81f3db0
current stmt: c846e438
stmt: switch(__choose("__ID183")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 184
parent stmt: c81f3db0
current stmt: c84743c8
stmt: switch(__choose("__ID184")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 185
parent stmt: c81f3db0
current stmt: c84744f0
stmt: switch(__choose("__ID185")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 186
parent stmt: c81f3db0
current stmt: c8474640
stmt: switch(__choose("__ID186")){
	case 0: {
if (!__is_neg())
    buggy(x, y, line);

break;
}
	case 1: {
if (!__is_neg())
    buggy(x, y, line);

break;
}
}

current candidate: 187
parent stmt: c81f3db0
current stmt: c8482ee0
stmt: switch(__choose("__ID187")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 188
parent stmt: c81f3db0
current stmt: c8483028
stmt: switch(__choose("__ID188")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 189
parent stmt: c81f3db0
current stmt: c8483198
stmt: switch(__choose("__ID189")){
	case 0: {
if (!__is_neg())
    for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
        printf("%d %d\n", line[i].first, line[i].second);

break;
}
	case 1: {
if (!__is_neg())
    for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
        printf("%d %d\n", line[i].first, line[i].second);

break;
}
}

current candidate: 190
parent stmt: c81f3db0
current stmt: c848aaf0
stmt: switch(__choose("__ID190")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 191
parent stmt: c81f3db0
current stmt: c848ac38
stmt: switch(__choose("__ID191")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}
Generating patches...
[9] StringConstTester, a patch instance with id 0:
Spawn 1 instances, now Total 2
Single building for Tester 0x5628c7b69270 id 0 failed as well!
[11] Preprocess the following candidate with BasicTester:
1864

current candidate: 192
parent stmt: c817b298
current stmt: c817b200
stmt: switch(__choose("__ID192")){
	case 0: {
ystep = 1
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
x1 = y1;
y0 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
x0 = y0;
error = error + deltaerr;
a = y0;
a = x0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
ystep = 1;
ystep = 1;

break;
}
}

current candidate: 193
parent stmt: c817b298
current stmt: c83e1150
stmt: switch(__choose("__ID193")){
	case 0: {
if (!__is_neg())
    ystep = 1;

break;
}
	case 1: {
if (!__is_neg())
    ystep = 1;

break;
}
}

current candidate: 194
parent stmt: c817b298
current stmt: c83e6fe8
stmt: switch(__choose("__ID194")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 195
parent stmt: c81e8d70
current stmt: c81e8b98
stmt: switch(__choose("__ID195")){
	case 0: {
var.first = x
break;
}
	case 1: {
if (__is_neg())
    return;
if (__is_neg())
    break;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
line.push_back(var);
--this->current;
--this->_M_p;
++this->iter;
--this->_M_current;
++this->_M_p;
++this->current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
var.second = y;
var.first = y;
var.second = x;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
if (this->capacity() == this->size())
    return false;
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
y1 = a;
x0 = x1;
y0 = y1;
x1 = y1;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
x0 = y0;
y0 = a;
error = error + deltaerr;
a = y0;
a = x0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
error = error - 1;
ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
var.first = x;
var.first = x;

break;
}
}

current candidate: 196
parent stmt: c81e8d70
current stmt: c81e8c40
stmt: switch(__choose("__ID196")){
	case 0: {
var.second = y
break;
}
	case 1: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
if (__is_neg())
    return;
if (__is_neg())
    break;
line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.second = x;
var.first = x;
var.first = y;
--this->current;
--this->_M_p;
--this->_M_current;
++this->current;
++this->iter;
++this->_M_p;
++this->_M_current;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
x1 = y1;
x0 = x1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = a;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
a = x0;
x0 = y0;
a = y0;
y0 = a;
error = error + deltaerr;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
error = error - 1;
ystep = -1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
var.second = y;
var.second = y;

break;
}
}

current candidate: 197
parent stmt: c81e8d70
current stmt: c81e8d30
stmt: switch(__choose("__ID197")){
	case 0: {
line.push_back(var)
break;
}
	case 1: {
if (!__is_neg())
    line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
if (__is_neg())
    return;
if (__is_neg())
    break;
++this->_M_p;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
--this->_M_current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x0 = x1;
x1 = y1;
y0 = y1;
y1 = a;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
var.second = y;
var.first = y;
var.second = x;
var.first = x;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
x0 = y0;
error = error + deltaerr;
a = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
ystep = -1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
line.push_back(var);

break;
}
}

current candidate: 198
parent stmt: c81e8d70
current stmt: c83d5740
stmt: switch(__choose("__ID198")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 199
parent stmt: c81e8d70
current stmt: c83d5980
stmt: switch(__choose("__ID199")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 200
parent stmt: c81e8d70
current stmt: c83d5bf0
stmt: switch(__choose("__ID200")){
	case 0: {
if (!__is_neg())
    line.push_back(var);

break;
}
	case 1: {
if (!__is_neg())
    line.push_back(var);

break;
}
}

current candidate: 201
parent stmt: c81e8d70
current stmt: c8420b00
stmt: switch(__choose("__ID201")){
	case 0: {
if (!__is_neg())
    var.first = x;

break;
}
	case 1: {
if (!__is_neg())
    var.first = x;

break;
}
}

current candidate: 202
parent stmt: c81e8d70
current stmt: c84269f8
stmt: switch(__choose("__ID202")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 203
parent stmt: c81e8d70
current stmt: c8426c38
stmt: switch(__choose("__ID203")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 204
parent stmt: c81e8d70
current stmt: c8426ea8
stmt: switch(__choose("__ID204")){
	case 0: {
if (!__is_neg())
    var.second = y;

break;
}
	case 1: {
if (!__is_neg())
    var.second = y;

break;
}
}

current candidate: 205
parent stmt: c81e8d70
current stmt: c842b180
stmt: switch(__choose("__ID205")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 206
parent stmt: c81e8d70
current stmt: c842b3c0
stmt: switch(__choose("__ID206")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 207
parent stmt: c81e90b0
current stmt: c81e8d98
stmt: switch(__choose("__ID207")){
	case 0: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
line.push_back(var);
if (__is_neg())
    return;
if (__is_neg())
    break;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.first = y;
var.second = x;
var.second = y;
var.first = x;
--this->current;
++this->_M_current;
--this->_M_p;
--this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_up();
this->_M_shrink_to_fit();
if (this->capacity() == this->size())
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x1;
x1 = a;
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
x1 = y1;
y1 = a;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
x0 = y0;
y0 = a;
a = x0;
a = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = 1;
ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 208
parent stmt: c81e90b0
current stmt: c81e8e70
stmt: switch(__choose("__ID208")){
	case 0: {
error = error + deltaerr
break;
}
	case 1: {
if (__is_neg())
    break;
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_p;
--this->_M_p;
++this->_M_current;
++this->current;
--this->current;
++this->iter;
--this->_M_current;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
line.push_back(var);
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
x1 = a;
x0 = x1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = y1;
x1 = y1;
a = x1;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = x0;
x0 = y0;
a = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
var.first = x;
var.second = y;
var.second = x;
var.first = y;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
ystep = 1;
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
error = error + deltaerr;
error = error + deltaerr;

break;
}
}

current candidate: 209
parent stmt: c81e90b0
current stmt: c81e9098
stmt: switch(__choose("__ID209")){
	case 0: {
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    break;
if (__is_neg())
    return;
error = error + deltaerr;
++this->current;
--this->_M_current;
--this->current;
--this->_M_p;
++this->iter;
++this->_M_current;
++this->_M_p;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
line.push_back(var);
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
a = x1;
x0 = x1;
x1 = a;
x1 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
y1 = a;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
error = error - 1;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
x0 = y0;
a = x0;
a = y0;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
var.second = y;
var.first = x;
var.first = y;
var.second = x;
if (steep) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}
ystep = 1;
ystep = -1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 210
parent stmt: c81e90b0
current stmt: c8412668
stmt: switch(__choose("__ID210")){
	case 0: {
if (!__is_neg())
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }

break;
}
	case 1: {
if (!__is_neg())
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }

break;
}
}

current candidate: 211
parent stmt: c81e90b0
current stmt: c84128f8
stmt: switch(__choose("__ID211")){
	case 0: {
if (!__is_neg() && (steep)) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if (!__is_neg() && (steep)) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 212
parent stmt: c81e90b0
current stmt: c8420650
stmt: switch(__choose("__ID212")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 213
parent stmt: c81e90b0
current stmt: c8420890
stmt: switch(__choose("__ID213")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 214
parent stmt: c81e90b0
current stmt: c842b670
stmt: switch(__choose("__ID214")){
	case 0: {
if ((steep) && !__is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if ((steep) && !__is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 215
parent stmt: c81e90b0
current stmt: c842b918
stmt: switch(__choose("__ID215")){
	case 0: {
if ((steep) || __is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
	case 1: {
if ((steep) || __is_neg()) {
    var.first = y;
    var.second = x;
    line.push_back(var);
} else {
    var.first = x;
    var.second = y;
    line.push_back(var);
}

break;
}
}

current candidate: 216
parent stmt: c81e90b0
current stmt: c842bb98
stmt: switch(__choose("__ID216")){
	case 0: {
if (!__is_neg())
    error = error + deltaerr;

break;
}
	case 1: {
if (!__is_neg())
    error = error + deltaerr;

break;
}
}

current candidate: 217
parent stmt: c81e90b0
current stmt: c8436648
stmt: switch(__choose("__ID217")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 218
parent stmt: c81e90b0
current stmt: c8436888
stmt: switch(__choose("__ID218")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 219
parent stmt: c81e90b0
current stmt: c8436af8
stmt: switch(__choose("__ID219")){
	case 0: {
if (!__is_neg())
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }

break;
}
}

current candidate: 220
parent stmt: c81e90b0
current stmt: c843c9f0
stmt: switch(__choose("__ID220")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 221
parent stmt: c81e90b0
current stmt: c8447f78
stmt: switch(__choose("__ID221")){
	case 0: {
if (__is_neg())
    break;

break;
}
	case 1: {
if (__is_neg())
    break;

break;
}
}

current candidate: 222
parent stmt: c81e90b0
current stmt: c8448228
stmt: switch(__choose("__ID222")){
	case 0: {
if ((error >= 0.5) && !__is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
if ((error >= 0.5) && !__is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 223
parent stmt: c81e90b0
current stmt: c84484c0
stmt: switch(__choose("__ID223")){
	case 0: {
if ((error >= 0.5) || __is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
	case 1: {
if ((error >= 0.5) || __is_neg()) {
    y += ystep;
    error = error - 1;
}

break;
}
}

current candidate: 224
parent stmt: c81e9110
current stmt: c8179c60
stmt: switch(__choose("__ID224")){
	case 0: {
short x0 = 0, y0 = 0;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_p;
++this->_M_current;
++this->iter;
++this->current;
--this->_M_current;
--this->current;
--this->_M_p;
--this->_M_impl._M_finish;
throw;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
x1 = y1;
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
short x0 = 0, y0 = 0;

break;
}
}

current candidate: 225
parent stmt: c81e9110
current stmt: c817a1e8
stmt: switch(__choose("__ID225")){
	case 0: {
bool steep = abs((int)(y1 - y0)) > abs((int)(x1 - x0));

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
y0 = y1;
x0 = x1;
x1 = y1;
--this->_M_p;
++this->iter;
--this->_M_current;
++this->current;
++this->_M_current;
++this->_M_p;
--this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
x0 = y0;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
bool steep = abs((int)(y1 - y0)) > abs((int)(x1 - x0));

break;
}
}

current candidate: 226
parent stmt: c81e9110
current stmt: c817a280
stmt: switch(__choose("__ID226")){
	case 0: {
short a;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_p;
--this->current;
--this->_M_current;
++this->iter;
++this->_M_p;
++this->current;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
if (__is_neg())
    return;
y0 = y1;
x1 = y1;
x0 = x1;
x0 = y0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
short a;

break;
}
}

current candidate: 227
parent stmt: c81e9110
current stmt: c817a610
stmt: switch(__choose("__ID227")){
	case 0: {
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->iter;
--this->current;
--this->_M_current;
--this->_M_p;
++this->_M_current;
++this->current;
++this->_M_p;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x0 = x1;
x1 = a;
a = x1;
x1 = y1;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x0;
y0 = a;
x0 = y0;
a = y0;
if (__is_neg())
    return;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 228
parent stmt: c81e9110
current stmt: c817aa40
stmt: switch(__choose("__ID228")){
	case 0: {
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
a = x1;
x0 = x1;
x1 = a;
y0 = y1;
x1 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x0;
a = y0;
x0 = y0;
y0 = a;
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_shrink_to_fit();
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 229
parent stmt: c81e9110
current stmt: c817ab98
stmt: switch(__choose("__ID229")){
	case 0: {
int deltax = x1 - x0;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
--this->_M_current;
++this->iter;
++this->current;
--this->current;
--this->_M_p;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
a = x1;
y1 = a;
y0 = y1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
a = x0;
y0 = a;
x0 = y0;
a = y0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int deltax = x1 - x0;

break;
}
}

current candidate: 230
parent stmt: c81e9110
current stmt: c817ae58
stmt: switch(__choose("__ID230")){
	case 0: {
int deltay = abs((int)(y1 - y0));

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
x1 = y1;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
y0 = a;
x0 = y0;
a = y0;
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
x0 = x1;
a = x1;
x1 = a;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
a = x0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int deltay = abs((int)(y1 - y0));

break;
}
}

current candidate: 231
parent stmt: c81e9110
current stmt: c817af28
stmt: switch(__choose("__ID231")){
	case 0: {
float error = 0;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return;
--this->_M_current;
++this->_M_current;
++this->current;
++this->_M_p;
--this->current;
--this->_M_p;
++this->iter;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
x1 = a;
x0 = x1;
a = x1;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
this->_M_bump_up();
this->_M_erase_at_end(begin());
if (this->capacity() == this->size())
    return false;
this->_M_shrink_to_fit();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x0;
a = y0;
x0 = y0;
y0 = a;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
float error = 0;

break;
}
}

current candidate: 232
parent stmt: c81e9110
current stmt: c817b068
stmt: switch(__choose("__ID232")){
	case 0: {
float deltaerr = deltay / deltax;

break;
}
	case 1: {
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->current;
++this->iter;
--this->_M_p;
--this->_M_current;
++this->_M_current;
++this->_M_p;
--this->current;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
x1 = a;
x0 = x1;
a = x1;
y0 = y1;
x1 = y1;
y1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
x0 = y0;
y0 = a;
a = y0;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
float deltaerr = deltay / deltax;

break;
}
}

current candidate: 233
parent stmt: c81e9110
current stmt: c817b100
stmt: switch(__choose("__ID233")){
	case 0: {
int ystep;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_p;
--this->_M_current;
--this->current;
++this->_M_p;
++this->current;
++this->iter;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return;
x1 = a;
x0 = x1;
a = x1;
y1 = a;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
a = x0;
error = error + deltaerr;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
x0 = y0;
y0 = a;
a = y0;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int ystep;

break;
}
}

current candidate: 234
parent stmt: c81e9110
current stmt: c817b298
stmt: switch(__choose("__ID234")){
	case 0: {
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
--this->_M_p;
--this->_M_current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
++this->_M_impl._M_finish;
throw;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y0 = y1;
y1 = a;
x1 = y1;
x1 = a;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = -1;
ystep = 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 235
parent stmt: c81e9110
current stmt: c817b390
stmt: switch(__choose("__ID235")){
	case 0: {
int y = y0;

break;
}
	case 1: {
if (__is_neg())
    return;
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->current;
++this->iter;
++this->current;
++this->_M_p;
++this->_M_current;
--this->_M_current;
--this->_M_p;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
throw;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_shrink_to_fit();
if (this->capacity() == this->size())
    return false;
this->_M_reallocate(this->size());
this->_M_bump_down();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
y1 = a;
y0 = y1;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x1 = a;
x0 = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
ystep = 1;
error = error - 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int y = y0;

break;
}
}

current candidate: 236
parent stmt: c81e9110
current stmt: c81c0180
stmt: switch(__choose("__ID236")){
	case 0: {
std::pair<int, int> var;

break;
}
	case 1: {
if (__is_neg())
    return;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_offset = 0;
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->_M_current;
++this->current;
++this->_M_p;
--this->_M_p;
--this->current;
--this->_M_current;
++this->iter;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_up();
this->_M_shrink_to_fit();
this->_M_bump_down();
this->_M_reallocate(this->size());
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
y0 = y1;
y1 = a;
x1 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
x0 = x1;
x1 = a;
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
error = error + deltaerr;
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
y0 = a;
a = y0;
a = x0;
x0 = y0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
ystep = 1;
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
std::pair<int, int> var;

break;
}
}

current candidate: 237
parent stmt: c81e9110
current stmt: c81e90d8
stmt: switch(__choose("__ID237")){
	case 0: {
for (int x = x0; x < x1; x++) {
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }
    error = error + deltaerr;
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }
}

break;
}
	case 1: {
line.push_back(var);
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
var.first = y;
var.second = y;
--this->current;
--this->_M_p;
++this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_erase_at_end(begin());
this->_M_shrink_to_fit();
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
error = error + deltaerr;
y1 = a;
y0 = y1;
if (x0 > x1) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}
if (steep) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}
a = x1;
x1 = a;
x0 = x1;
x1 = y1;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
y0 = a;
a = y0;
x0 = y0;
a = x0;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
error = error - 1;
if (error >= 0.5) {
    y += ystep;
    error = error - 1;
}
if (y0 < y1)
    ystep = 1;
else
    ystep = -1;
ystep = -1;
ystep = 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
for (int x = x0; x < x1; x++) {
    if (steep) {
        var.first = y;
        var.second = x;
        line.push_back(var);
    } else {
        var.first = x;
        var.second = y;
        line.push_back(var);
    }
    error = error + deltaerr;
    if (error >= 0.5) {
        y += ystep;
        error = error - 1;
    }
}

break;
}
}

current candidate: 238
parent stmt: c81e9110
current stmt: c8271ae0
stmt: switch(__choose("__ID238")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 239
parent stmt: c81e9110
current stmt: c835b788
stmt: switch(__choose("__ID239")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 240
parent stmt: c81e9110
current stmt: c8368cb8
stmt: switch(__choose("__ID240")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 241
parent stmt: c81e9110
current stmt: c8368e08
stmt: switch(__choose("__ID241")){
	case 0: {
if (!__is_neg())
    if (steep) {
        a = x0;
        x0 = y0;
        y0 = a;
        a = x1;
        x1 = y1;
        y1 = a;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (steep) {
        a = x0;
        x0 = y0;
        y0 = a;
        a = x1;
        x1 = y1;
        y1 = a;
    }

break;
}
}

current candidate: 242
parent stmt: c81e9110
current stmt: c836ec00
stmt: switch(__choose("__ID242")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 243
parent stmt: c81e9110
current stmt: c837f4e8
stmt: switch(__choose("__ID243")){
	case 0: {
if ((steep) && !__is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((steep) && !__is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 244
parent stmt: c81e9110
current stmt: c837f680
stmt: switch(__choose("__ID244")){
	case 0: {
if ((steep) || __is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((steep) || __is_neg()) {
    a = x0;
    x0 = y0;
    y0 = a;
    a = x1;
    x1 = y1;
    y1 = a;
}

break;
}
}

current candidate: 245
parent stmt: c81e9110
current stmt: c837f7f0
stmt: switch(__choose("__ID245")){
	case 0: {
if (!__is_neg())
    if (x0 > x1) {
        a = x0;
        x0 = x1;
        x1 = a;
        a = y0;
        y0 = y1;
        y1 = a;
    }

break;
}
	case 1: {
if (!__is_neg())
    if (x0 > x1) {
        a = x0;
        x0 = x1;
        x1 = a;
        a = y0;
        y0 = y1;
        y1 = a;
    }

break;
}
}

current candidate: 246
parent stmt: c81e9110
current stmt: c83855e8
stmt: switch(__choose("__ID246")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 247
parent stmt: c81e9110
current stmt: c8385798
stmt: switch(__choose("__ID247")){
	case 0: {
if ((x0 > x1) && !__is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((x0 > x1) && !__is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 248
parent stmt: c81e9110
current stmt: c8385930
stmt: switch(__choose("__ID248")){
	case 0: {
if ((x0 > x1) || __is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
	case 1: {
if ((x0 > x1) || __is_neg()) {
    a = x0;
    x0 = x1;
    x1 = a;
    a = y0;
    y0 = y1;
    y1 = a;
}

break;
}
}

current candidate: 249
parent stmt: c81e9110
current stmt: c8390778
stmt: switch(__choose("__ID249")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 250
parent stmt: c81e9110
current stmt: c8390968
stmt: switch(__choose("__ID250")){
	case 0: {
if (!__is_neg())
    if (y0 < y1)
        ystep = 1;
    else
        ystep = -1;

break;
}
	case 1: {
if (!__is_neg())
    if (y0 < y1)
        ystep = 1;
    else
        ystep = -1;

break;
}
}

current candidate: 251
parent stmt: c81e9110
current stmt: c839e910
stmt: switch(__choose("__ID251")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 252
parent stmt: c81e9110
current stmt: c83a47b8
stmt: switch(__choose("__ID252")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 253
parent stmt: c81e9110
current stmt: c83b3fa0
stmt: switch(__choose("__ID253")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 254
parent stmt: c81e9110
current stmt: c83b9dd8
stmt: switch(__choose("__ID254")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 255
parent stmt: c81e9110
current stmt: c83e0f40
stmt: switch(__choose("__ID255")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 256
parent stmt: c81e9110
current stmt: c83f5378
stmt: switch(__choose("__ID256")){
	case 0: {
if ((y0 < y1) && !__is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if ((y0 < y1) && !__is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 257
parent stmt: c81e9110
current stmt: c83f55c0
stmt: switch(__choose("__ID257")){
	case 0: {
if ((y0 < y1) || __is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
	case 1: {
if ((y0 < y1) || __is_neg())
    ystep = 1;
else
    ystep = -1;

break;
}
}

current candidate: 258
parent stmt: c81e9110
current stmt: c83fb500
stmt: switch(__choose("__ID258")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 259
parent stmt: c81e9110
current stmt: c8405d18
stmt: switch(__choose("__ID259")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 260
parent stmt: c81e9110
current stmt: c8405f48
stmt: switch(__choose("__ID260")){
	case 0: {
if (!__is_neg())
    for (int x = x0; x < x1; x++) {
        if (steep) {
            var.first = y;
            var.second = x;
            line.push_back(var);
        } else {
            var.first = x;
            var.second = y;
            line.push_back(var);
        }
        error = error + deltaerr;
        if (error >= 0.5) {
            y += ystep;
            error = error - 1;
        }
    }

break;
}
	case 1: {
if (!__is_neg())
    for (int x = x0; x < x1; x++) {
        if (steep) {
            var.first = y;
            var.second = x;
            line.push_back(var);
        } else {
            var.first = x;
            var.second = y;
            line.push_back(var);
        }
        error = error + deltaerr;
        if (error >= 0.5) {
            y += ystep;
            error = error - 1;
        }
    }

break;
}
}

current candidate: 261
parent stmt: c81e9110
current stmt: c8412418
stmt: switch(__choose("__ID261")){
	case 0: {
if (__is_neg())
    return;

break;
}
	case 1: {
if (__is_neg())
    return;

break;
}
}

current candidate: 262
parent stmt: c81f3db0
current stmt: c81ed8d0
stmt: switch(__choose("__ID262")){
	case 0: {
FILE *f = fopen(argv[1], "r");

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return 0;
++this->_M_p;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
--this->_M_current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_deallocate();
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
FILE *f = fopen(argv[1], "r");

break;
}
}

current candidate: 263
parent stmt: c81f3db0
current stmt: c81eda00
stmt: switch(__choose("__ID263")){
	case 0: {
int x, y;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
++this->iter;
--this->_M_current;
--this->current;
--this->_M_p;
++this->_M_current;
++this->_M_p;
++this->current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_up();
this->_M_erase_at_end(begin());
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
if (__is_neg())
    return 0;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
int x, y;

break;
}
}

current candidate: 264
parent stmt: c81f3db0
current stmt: c81edc28
stmt: switch(__choose("__ID264")){
	case 0: {
fscanf(f, "%d %d\n", &x, &y)
break;
}
	case 1: {
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
fscanf(f, "%d %d\n", &x, &y);

break;
}
}

current candidate: 265
parent stmt: c81f3db0
current stmt: c81edd98
stmt: switch(__choose("__ID265")){
	case 0: {
fclose(f)
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
if (__is_neg())
    return 0;
++this->current;
--this->_M_p;
--this->current;
++this->iter;
--this->_M_current;
++this->_M_p;
++this->_M_current;
throw;
++this->_M_impl._M_finish;
--this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_shrink_to_fit();
this->_M_erase_at_end(begin());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_bump_down();
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
if (this->capacity() == this->size())
    return false;
this->_M_bump_up();
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
fclose(f);

break;
}
}

current candidate: 266
parent stmt: c81f3db0
current stmt: c81f3400
stmt: switch(__choose("__ID266")){
	case 0: {
DiscreteLine line;

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
--this->_M_current;
--this->_M_p;
--this->current;
++this->current;
++this->iter;
++this->_M_p;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
if (__is_neg())
    return 0;
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_shrink_to_fit();
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
DiscreteLine line;

break;
}
}

current candidate: 267
parent stmt: c81f3db0
current stmt: c81f3558
stmt: switch(__choose("__ID267")){
	case 0: {
buggy(x, y, line)
break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
buggy(x, y, line);
if (__is_neg())
    return 0;
--this->_M_current;
--this->_M_p;
--this->current;
++this->_M_p;
++this->iter;
++this->current;
++this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
this->clear();
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
this->_M_bump_up();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
this->_M_offset = int(_S_word_bit) - 1;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
buggy(x, y, line);

break;
}
}

current candidate: 268
parent stmt: c81f3db0
current stmt: c81f3d78
stmt: switch(__choose("__ID268")){
	case 0: {
for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
    printf("%d %d\n", line[i].first, line[i].second);

break;
}
	case 1: {
this->_M_offset = 0;
if (this->_M_offset++ == int(_S_word_bit) - 1) {
    this->_M_offset = 0;
    ++this->_M_p;
}
this->_M_impl._M_start = std::vector<bool, type-parameter-0-0>::iterator(0, 0);
buggy(x, y, line);
if (__is_neg())
    return 0;
--this->_M_p;
--this->current;
++this->_M_current;
++this->_M_p;
++this->iter;
++this->current;
--this->_M_current;
throw;
--this->_M_impl._M_finish;
++this->_M_impl._M_finish;
this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->clear();
this->_M_deallocate();
std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
this->_M_impl._M_start = std::_Bit_iterator();
this->_M_impl._M_finish = std::_Bit_iterator();
this->_M_impl._M_end_of_storage = std::_Bvector_base::_Bit_pointer();
this->_M_impl._M_finish = this->_M_impl._M_start;
this->_M_impl._M_finish = nullptr;
this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
this->_M_impl._M_end_of_storage = std::vector<bool, type-parameter-0-0>::_Bit_pointer();
this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
this->_M_impl._M_end_of_storage = nullptr;
this->_M_impl._M_start = nullptr;
this->_M_impl._M_finish = __tmp + __old_size;
this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
_Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
this->_M_bump_up();
this->_M_shrink_to_fit();
this->_M_reallocate(this->size());
this->_M_erase_at_end(begin());
this->_M_bump_down();
if (this->capacity() == this->size())
    return false;
if (this->capacity() - this->size() < int(_S_word_bit))
    return false;
this->_M_erase_at_end(this->_M_impl._M_start);
this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - this->size(), __val, _M_get_Tp_allocator());
this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
this->_M_impl._M_end_of_storage = __new_start + __len;
if (this->_M_offset-- == 0) {
    this->_M_offset = int(_S_word_bit) - 1;
    --this->_M_p;
}
this->_M_offset = int(_S_word_bit) - 1;
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
if (__is_neg())
    return 1;
if (this->_M_end_of_storage)
    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
    printf("%d %d\n", line[i].first, line[i].second);

break;
}
}

current candidate: 269
parent stmt: c81f3db0
current stmt: c844e428
stmt: switch(__choose("__ID269")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 270
parent stmt: c81f3db0
current stmt: c844e4f0
stmt: switch(__choose("__ID270")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 271
parent stmt: c81f3db0
current stmt: c845b428
stmt: switch(__choose("__ID271")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 272
parent stmt: c81f3db0
current stmt: c845b510
stmt: switch(__choose("__ID272")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 273
parent stmt: c81f3db0
current stmt: c845b6b8
stmt: switch(__choose("__ID273")){
	case 0: {
fscanf(f, __is_neg(), &x, &y)
break;
}
	case 1: {
fscanf(f, __is_neg(), &x, &y);

break;
}
}

current candidate: 274
parent stmt: c81f3db0
current stmt: c845b730
stmt: switch(__choose("__ID274")){
	case 0: {
if (!__is_neg())
    fscanf(f, "%d %d\n", &x, &y);

break;
}
	case 1: {
if (!__is_neg())
    fscanf(f, "%d %d\n", &x, &y);

break;
}
}

current candidate: 275
parent stmt: c81f3db0
current stmt: c8463458
stmt: switch(__choose("__ID275")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 276
parent stmt: c81f3db0
current stmt: c8463580
stmt: switch(__choose("__ID276")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 277
parent stmt: c81f3db0
current stmt: c8463768
stmt: switch(__choose("__ID277")){
	case 0: {
if (!__is_neg())
    fclose(f);

break;
}
	case 1: {
if (!__is_neg())
    fclose(f);

break;
}
}

current candidate: 278
parent stmt: c81f3db0
current stmt: c846e310
stmt: switch(__choose("__ID278")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 279
parent stmt: c81f3db0
current stmt: c846e438
stmt: switch(__choose("__ID279")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 280
parent stmt: c81f3db0
current stmt: c84743c8
stmt: switch(__choose("__ID280")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 281
parent stmt: c81f3db0
current stmt: c84744f0
stmt: switch(__choose("__ID281")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 282
parent stmt: c81f3db0
current stmt: c8474640
stmt: switch(__choose("__ID282")){
	case 0: {
if (!__is_neg())
    buggy(x, y, line);

break;
}
	case 1: {
if (!__is_neg())
    buggy(x, y, line);

break;
}
}

current candidate: 283
parent stmt: c81f3db0
current stmt: c8482ee0
stmt: switch(__choose("__ID283")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 284
parent stmt: c81f3db0
current stmt: c8483028
stmt: switch(__choose("__ID284")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}

current candidate: 285
parent stmt: c81f3db0
current stmt: c8483198
stmt: switch(__choose("__ID285")){
	case 0: {
if (!__is_neg())
    for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
        printf("%d %d\n", line[i].first, line[i].second);

break;
}
	case 1: {
if (!__is_neg())
    for (unsigned int i = 0, end = line.size(); i != line.size(); i++)
        printf("%d %d\n", line[i].first, line[i].second);

break;
}
}

current candidate: 286
parent stmt: c81f3db0
current stmt: c848aaf0
stmt: switch(__choose("__ID286")){
	case 0: {
if (__is_neg())
    return 0;

break;
}
	case 1: {
if (__is_neg())
    return 0;

break;
}
}

current candidate: 287
parent stmt: c81f3db0
current stmt: c848ac38
stmt: switch(__choose("__ID287")){
	case 0: {
if (__is_neg())
    return 1;

break;
}
	case 1: {
if (__is_neg())
    return 1;

break;
}
}
Generating patches...
[11] BasicTester, a patch instance with id 0:
Spawn 1 instances, now Total 3
Single building for Tester 0x5628c843e6b0 id 1 failed as well!
Generating Result...The total number of synthesis runs: 0
The total number of concrete conds: 0
The total number of explored concrete patches: 7266
result size: 0
Repair process ends without working fix!!
Total 1864 different repair schemas!!!!
Total 2422 different repair candidate templates for scoring!!!
Total number of compiles: 3
Total number of test eval: 0
